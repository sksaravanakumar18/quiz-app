[
  {
    "id": 1,
    "topic": "DevOps",
    "question": "For this question, refer to the Mountkirk Games case study.\nMountkirk Games wants to set up a continuous delivery pipeline. Their architecture includes many small services that they want to be able to update and roll back quickly. Mountkirk Games has the following requirements:\n\n* Services are deployed redundantly across multiple regions in the US and Europe.\n* Only frontend services are exposed on the public internet.\n* They can provide a single frontend IP for their fleet of services.\n* Deployment artifacts are immutable.\n\nWhich set of products should they use?",
    "options": {
      "A": "Google Cloud Storage, Google Cloud Dataflow, Google Compute Engine",
      "B": "Google Cloud Storage, Google App Engine, Google Network Load Balancer",
      "C": "Google Kubernetes Registry, Google Container Engine, Google HTTP(S) Load Balancer",
      "D": "Google Cloud Functions, Google Cloud Pub/Sub, Google Cloud Deployment Manager"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To meet the requirements for deploying containerized microservices redundantly across regions with immutable artifacts, quick updates/rollbacks, and a single frontend IP, the best combination is: Google Container Registry (now Artifact Registry) for storing immutable Docker images, Google Kubernetes Engine (GKE) for orchestrating container deployment across multiple regions, and a Global HTTP(S) Load Balancer to provide a single frontend IP and route traffic to the appropriate regional GKE clusters. Option C accurately reflects these components (using the older names Container Registry and Container Engine for Artifact Registry and Kubernetes Engine). Option A is for data processing. Option B uses App Engine (less flexible for complex microservices) and Network LB (Layer 4, not ideal for HTTP routing). Option D uses serverless components not suited for deploying a fleet of potentially complex services.",
    "conditions": [
      "Architecture includes many small services",
      "Need quick updates and rollbacks",
      "Deploy redundantly across multiple regions (US, Europe)",
      "Only frontend services exposed publicly",
      "Single frontend IP required",
      "Immutable deployment artifacts needed"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong>: Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong><strong>Business Requirements </strong>: </strong><br> Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical requirements: </strong><br> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive statement: </strong><br> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 2,
    "topic": "IAM & Security",
    "question": "For this question, refer to the Mountkirk Games case study\nMountkirk Games needs to create a repeatable and configurable mechanism for deploying isolated application environments. Developers and testers can access each other's environments and resources, but they cannot access staging or production resources. The staging environment needs access to some services from production.\nWhat should you do to isolate development environments from staging and production?",
    "options": {
      "A": "Create a project for development and test and another for staging and production.",
      "B": "Create a network for development and test and another for staging and production.",
      "C": "Create one subnetwork for development and another for staging and production.",
      "D": "Create one project for development, a second for staging and a third for production."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "GCP Projects provide the strongest isolation boundary for resources, billing, and IAM policies. Creating separate projects for Development, Staging, and Production (D) allows for granular access control. Developers/testers can be granted roles in the Development project, limited roles (if any) in Staging, and no access to Production. Staging resources (e.g., via service accounts) can be granted specific access to necessary Production services while maintaining overall isolation. Combining environments in projects (A) or using network/subnet boundaries (B, C) does not provide sufficient IAM isolation.",
    "conditions": [
      "Need repeatable deployment of isolated environments (Dev, Test, Staging, Prod)",
      "Dev/Testers access each other's environments, but not Staging/Prod",
      "Staging needs access to some Prod services"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong>: Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong><strong>Business Requirements </strong>: </strong><br> Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical requirements: </strong><br> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive statement: </strong><br> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 3,
    "topic": "DevOps",
    "question": "For this question, refer to the Mountkirk Games case study.\nMountkirk Games wants you to design their new testing strategy. How should the test coverage differ from their existing backends on the other platforms?",
    "options": {
      "A": "Tests should scale well beyond the prior approaches.",
      "B": "Unit tests are no longer required, only end-to-end tests.",
      "C": "Tests should be applied after the release is in the production environment.",
      "D": "Tests should include directly testing the Google Cloud Platform (GCP) infrastructure."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Mountkirk Games experienced scaling problems with their previous architecture. Migrating to GCP aims to address this. Therefore, the new testing strategy must validate the application's ability to handle scale effectively. Tests need to cover scenarios at expected peak load and beyond (A) to ensure the new GCP-based backend meets performance and scaling requirements, which was a weakness previously. Unit tests remain essential (B is incorrect). Testing before production is critical (C is incorrect). Testing should focus on the application on GCP, not GCP itself (D is incorrect).",
    "conditions": [
      "Designing new testing strategy for GCP-based backend",
      "Previous platform had scaling issues",
      "GCP backend needs to scale dynamically"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong>: Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong><strong>Business Requirements </strong>: </strong><br> Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical requirements: </strong><br> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive statement: </strong><br> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 4,
    "topic": "Case Study Analysis",
    "question": "For this question, refer to the TerramEarth case study.\nTerramEarth's CTO wants to use the raw data from connected vehicles to help identify approximately when a vehicle in the field will have a catastrophic failure.\nYou want to allow analysts to centrally query the vehicle data.\nWhich architecture should you recommend?\nA) [Image depicting FTP -> GCLB -> GKE -> PubSub -> Dataflow -> BigQuery -> Analysts]\nB) [Image depicting FTP -> App Engine Flex -> PubSub -> Dataflow -> BigQuery -> Analysts]\nC) [Image depicting FTP -> GCLB -> GKE -> PubSub -> Dataflow -> Cloud SQL -> Analysts]\nD) [Image depicting FTP -> App Engine Flex -> PubSub -> Dataflow -> Cloud SQL -> Analysts]",
    "options": {
      "A": "Option A",
      "B": "Option B",
      "C": "Option C",
      "D": "Option D"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The goal is large-scale data ingestion and analysis for predictive maintenance. The architecture needs components for ingestion, processing, and querying. BigQuery is the appropriate service for analysts to centrally query large volumes of vehicle data. Dataflow is suitable for processing streaming (or batch) data from Pub/Sub. Pub/Sub acts as a scalable ingestion buffer. An ingestion layer (GKE or App Engine Flex) receives data (via FTP in this diagram, though ideally a more direct method like IoT Core/Pub/Sub) and pushes it to Pub/Sub. GCLB can distribute incoming load. Option A shows this flow using GKE for ingestion and BigQuery for analysis, fitting the requirements. Cloud SQL (C, D) is not suitable for large-scale analytics on terabytes of vehicle data.",
    "conditions": [
      "Use raw data from connected vehicles",
      "Predict vehicle failures",
      "Allow central querying by analysts"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong>: There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong><strong>Business Requirements </strong>: </strong><br> Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical requirements: </strong><br> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive statement: </strong><br> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 5,
    "topic": "Storage",
    "question": "For this question, refer to the TerramEarth case study.\nTerramEarth has equipped unconnected trucks with servers and sensors to collet telemetry data. Next year they want to use the data to train machine learning models. They want to store this data in the cloud while reducing costs. What should they do?",
    "options": {
      "A": "Have the vehicle’ computer compress the data in hourly snapshots, and store it in a Google Cloud storage (GCS) Nearline bucket.",
      "B": "Push the telemetry data in Real-time to a streaming dataflow job that compresses the data, and store it in Google BigQuery.",
      "C": "Push the telemetry data in real-time to a streaming dataflow job that compresses the data, and store it in Cloud Bigtable.",
      "D": "Have the vehicle's computer compress the data in hourly snapshots, a Store it in a GCS Coldline bucket."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "The data is for ML training *next year*, indicating infrequent access until then. Cost reduction is a priority. Storing compressed hourly snapshots minimizes the number of objects. Cloud Storage Coldline offers the lowest storage cost for data accessed infrequently (less than annually). Therefore, compressing data locally and uploading snapshots to Coldline Storage (D) is the most cost-effective approach for this use case. Nearline (A) is more expensive than Coldline. Real-time streaming and storage in BigQuery (B) or Bigtable (C) are significantly more expensive and unnecessary given the access pattern.",
    "conditions": [
      "Store telemetry data from unconnected trucks",
      "Data needed next year for ML training",
      "Reduce storage costs"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong>: There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong><strong>Business Requirements </strong>: </strong><br> Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical requirements: </strong><br> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive statement: </strong><br> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 6,
    "topic": "Data Processing",
    "question": "For this question, refer to the TerramEarth case study.\nTerramEarth plans to connect all 20 million vehicles in the field to the cloud. This increases the volume to 20 million 600 byte records a second for 40 TB an hour.\nHow should you design the data ingestion?",
    "options": {
      "A": "Vehicles write data directly to GCS.",
      "B": "Vehicles write data directly to Google Cloud Pub/Sub.",
      "C": "Vehicles stream data directly to Google BigQuery.",
      "D": "Vehicles continue to write data using the existing system (FTP)."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "At 20 million messages per second, a highly scalable and durable ingestion service is required. Cloud Pub/Sub is designed for this scale, acting as a global message bus that can absorb massive amounts of streaming data and buffer it for downstream processing. Writing directly to GCS (A) is less suitable for high-frequency streaming events. Streaming directly to BigQuery (C) has lower ingestion limits than Pub/Sub. The existing FTP system (D) cannot handle this scale.",
    "conditions": [
      "Connect 20 million vehicles",
      "Data rate: 20 million records/sec (40 TB/hour)",
      "Design data ingestion mechanism"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong>: There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong><strong>Business Requirements </strong>: </strong><br> Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical requirements: </strong><br> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive statement: </strong><br> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 7,
    "topic": "Case Study Analysis",
    "question": "For this question refer to the TerramEarth case study.\nWhich of TerramEarth's legacy enterprise processes will experience significant change as a result of increased Google Cloud Platform adoption.",
    "options": {
      "A": "Opex/capex allocation, LAN changes, capacity planning",
      "B": "Capacity planning, TCO calculations, opex/capex allocation",
      "C": "Capacity planning, utilization measurement, data center expansion",
      "D": "Data Center expansion, TCO calculations, utilization measurement"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Adopting GCP significantly changes financial and planning processes. Capacity Planning shifts from procuring physical hardware long in advance to dynamically provisioning cloud resources. Opex/Capex Allocation shifts from large upfront capital expenses (servers, data centers) to ongoing operational expenses (cloud service usage). Total Cost of Ownership (TCO) calculations must be revised to account for cloud pricing models, elasticity, and reduced operational overhead. Data center expansion (C, D) becomes irrelevant. LAN changes (A) are less impacted than core capacity/financial processes.",
    "conditions": [
      "Identify legacy enterprise processes significantly changed by GCP adoption"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong>: There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong><strong>Business Requirements </strong>: </strong><br> Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical requirements: </strong><br> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive statement: </strong><br> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 8,
    "topic": "Security",
    "question": "For this question, refer to the TerramEarth case study.\nYour agricultural division is experimenting with fully autonomous vehicles.\nYou want your architecture to promote strong security during vehicle operation. Which two architecture should you consider?\nChoose 2 answers:",
    "options": {
      "A": "Treat every micro service call between modules on the vehicle as untrusted.",
      "B": "Require IPv6 for connectivity to ensure a secure address space.",
      "C": "Use a trusted platform module (TPM) and verify firmware and binaries on boot.",
      "D": "Use a functional programming language to isolate code execution cycles.",
      "E": "Use multiple connectivity subsystems for redundancy.",
      "F": "Enclose the vehicle's drive electronics in a Faraday cage to isolate chips."
    },
    "correctAnswer": [
      "A",
      "C"
    ],
    "explanation": "For strong security in autonomous vehicles: A) Implementing a zero-trust model within the vehicle, where inter-module communication requires authentication and authorization, hardens the system against internal compromises. C) Using a TPM for secure boot and runtime integrity checks ensures the system starts with trusted code and detects tampering. IPv6 (B) doesn't inherently guarantee security. Functional programming (D) has benefits but isn't a primary security architecture choice. Redundancy (E) is for reliability. Faraday cages (F) protect against EMI, not typical cyber threats.",
    "conditions": [
      "Designing architecture for autonomous vehicles",
      "Promote strong security during operation"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong>: There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong><strong>Business Requirements </strong>: </strong><br> Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical requirements: </strong><br> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive statement: </strong><br> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 9,
    "topic": "API Management",
    "question": "For this question, refer to the TerramEarth case study.\nThe TerramEarth development team wants to create an API to meet the company's Business Requirements. You want the development team to focus their development effort on business value versus creating a custom framework. Which method should they use?",
    "options": {
      "A": "Use Google App Engine with Google Cloud Endpoint Focus on an API for dealers and partners.",
      "B": "Use Google App Engine with a JAX-RS Jersey Java-based framewor Focus on an API for the public.",
      "C": "Use Google App Engine with the Swagger (open API Specification) framewor Focus on an API for the public.",
      "D": "Use Google Container Engine with a Django Python containe Focus on an API for the public.",
      "E": "Use Google Container Engine with a Tomcat container with the Swagger (Open API Specification) framewor Focus on an API for dealers and partners."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To minimize custom framework development and focus on business value (supporting dealers/partners), using a managed platform like App Engine combined with an API management framework like Cloud Endpoints is ideal. Cloud Endpoints handles boilerplate API tasks (authentication, monitoring, quotas), allowing developers to focus on the API logic. Targeting dealers and partners aligns with Business Requirements.",
    "conditions": [
      "Create API to support dealers and partners",
      "Minimize custom framework development",
      "Focus on business value"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong>: There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong><strong>Business Requirements </strong>: </strong><br> Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical requirements: </strong><br> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive statement: </strong><br> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 10,
    "topic": "IAM & Security",
    "question": "For this question, refer to the JencoMart case study.\nThe JencoMart security team requires that all Google Cloud Platform infrastructure is deployed using a least privilege model with separation of duties for administration between production and development resources. What Google domain and project structure should you recommend?",
    "options": {
      "A": "Create two G Suite accounts to manage users: one for development/test/staging and one for production Each account should contain one project for every application.",
      "B": "Create two G Suite accounts to manage users: one with a single project for all development applications and one with a single project for all production applications.",
      "C": "Create a single G Suite account to manage users with each stage of each application in its own project.",
      "D": "Create a single G Suite account to manage users with one project for the development/test/staging environment and one project for the production environment."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Using a single Google Workspace/Cloud Identity domain simplifies user management. Separating Production resources into their own project(s) distinct from Development/Test/Staging projects allows for applying different, more restrictive IAM policies to Production, enforcing least privilege and separation of duties. Developers can have broader permissions in Dev/Test, while access to Prod is tightly controlled. Option D provides this clear separation between Prod and Non-Prod environments using distinct projects under a single user management domain.",
    "conditions": [
      "Deploy GCP infrastructure",
      "Requirement: Least privilege",
      "Requirement: Separation of duties (Prod vs. Dev admin)"
    ],
    "caseStudyContext": "Introductory Info\n<strong>Company overview: </strong><br>- JencoMart is a global retailer with over 10,000 stores in 16 countries. The stores carry a range of goods, such as groceries, tires, and jewelry. One of the company’s core values is excellent customer service. In addition, they recently introduced an environmental policy to reduce their carbon output by 50% over the next 5 years.\nCompany background - JencoMart started as a general store in 1931, and has grown into one of the world's leading brands, known for great value and customer service. Over time, the company transitioned from only physical stores to a stores and online hybrid model, with 25% of sales online. Currently, JencoMart has little presence in Asia, but considers that market key for future growth.\n<strong>Solution Concept </strong><br> - JencoMart wants to migrate several critical applications to the cloud but has not completed a technical review to determine their suitability for the cloud and the engineering required for migration. They currently host all of these applications on infrastructure that is at its end of life and is no longer supported.\n<strong>Existing Technical Environment </strong><br> - JencoMart hosts all of its applications in 4 data centers: 3 in North American and 1 in Europe; most applications are dual-homed. JencoMart understands the dependencies and resource usage metrics of their on-premises architecture. Application: Customer loyalty portal LAMP (Linux, Apache, MySQL and PHP) application served from the two JencoMart-owned U.S. data centers.\nDatabase - Oracle Database stores user profiles - 20 TB - Complex table structure - Well maintained, clean data - Strong backup strategy PostgreSQL database stores user credentials - Single-homed in US West - No redundancy - Backed up every 12 hours - 100% uptime service level agreement (SLA) - Authenticates all users Compute - 30 machines in US West Coast, each machine has: - Twin, dual core CPUs - 32 GB of RAM - Twin 250 GB HDD (RAID 1) 20 machines in US East Coast, each machine has: - Single, dual-core CPU - 24 GB of RAM - Twin 250 GB HDD (RAID 1) Storage - Access to shared 100 TB SAN in each location Tape backup every week\n<strong>Business Requirements </strong><br> - Optimize for capacity during peak periods and value during off-peak periods Guarantee service availability and support Reduce on-premises footprint and associated financial and environmental impact Move to outsourcing model to avoid large upfront costs associated with infrastructure purchase Expand services into Asia\n<strong>Technical Requirements -</strong> Assess key application for cloud suitability Modify applications for the cloud Move applications to a new infrastructure Leverage managed services wherever feasible Sunset 20% of capacity in existing data centers Decrease latency in Asia\n<strong>CEO Statement </strong><br> - JencoMart will continue to develop personal relationships with our customers as more people access the web. The future of our retail business is in the global market and the connection between online and in-store experiences. As a large, global company, we also have a responsibility to the environment through ‘green’ initiatives and policies.\n<strong>CTO Statement  </strong><br>- The challenges of operating data centers prevent focus on key technologies critical to our long-term success. Migrating our data services to a public cloud infrastructure will allow us to focus on big data and machine learning to improve our service to customers.\nCFO Statement - Since its founding, JencoMart has invested heavily in our data services infrastructure. However, because of changing market trends, we need to outsource our infrastructure to ensure our long-term success. This model will allow us to respond to increasing customer demand during peak periods and reduce costs."
  },
  {
    "id": 11,
    "topic": "Compute",
    "question": "For this question, refer to the Dress4Win case study.\nThe Dress4Win security team has disabled external SSH access into production virtual machines (VMs) on Google Cloud Platform (GCP). The operations team needs to remotely manage the VMs, build and push Docker containers, and manage Google Cloud Storage objects. What can they do?",
    "options": {
      "A": "Grant the operations engineers access to use Google Cloud Shell.",
      "B": "Configure a VPN connection to GCP to allow SSH access to the cloud VMs.",
      "C": "Develop a new access request process that grants temporary SSH access to cloud VMs when an operations engineer needs to perform a task.",
      "D": "Have the development team build an API service that allows the operations team to execute specific remote procedure calls to accomplish their tasks."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Cloud Shell provides a pre-configured, browser-based command-line environment with necessary tools like `gcloud`, `gsutil`, and `docker`. It authenticates using the user's Cloud Console credentials. Operations engineers can use Cloud Shell to manage GCS objects, build/push containers (to GCR/Artifact Registry), and connect to VMs (even those without external IPs, using IAP tunneling via `gcloud compute ssh`) without needing direct external SSH access from their own machines. This satisfies the requirements while respecting the security constraint.",
    "conditions": [
      "External SSH access to production VMs disabled",
      "Operations team needs remote VM management",
      "Operations team needs to build/push Docker containers",
      "Operations team needs to manage GCS objects"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, ecommerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong>: For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL. One server for user data, inventory, static data (MySQL 5.7, 8 core CPUs, 128 GB of RAM, 2x 5 TB HDD (RAID 1)). Compute: 40 web application servers providing micro-services based APIs and static content (Tomcat - Java, Nginx, Four core CPUs, 32 GB of RAM). 20 Apache Hadoop/Spark servers (Data analysis, Real-time trending calculations, Eight core CPUs, 128 GB of RAM, 4x 5 TB HDD (RAID 1)). Three RabbitMQ servers for messaging, social notifications, and events (Eight core CPUs, 32GB of RAM). Miscellaneous servers (Jenkins, monitoring, bastion hosts, security scanners, Eight core CPUs, 32GB of RAM). Storage appliances: iSCSI for VM hosts. Fibre channel SAN - MySQL databases (1 PB total storage; 400 TB available). NAS - image storage, logs, backups (100 TB total storage; 35 TB available).\n<strong><strong>Business Requirements </strong>: </strong><br> Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and identity and access management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud.\n<strong>Technical requirements: </strong><br> Easily create non-production environments in the cloud. Implement an automation framework for provisioning resources in cloud. Implement a continuous deployment process for deploying applications to the on-premises data center or cloud. Support failover of the production environment to cloud during an emergency. Encrypt data on the wire and at rest. Support multiple private connections between the production data center and cloud environment.\n<strong>Executive statement: </strong><br> Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a competitor could use a public cloud platform to offset their up-front investment and free them to focus on developing better features. Our traffic patterns are highest in the mornings and weekend evenings; during other times, 80% of our capacity is sitting idle. Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next five years for a public cloud strategy achieves a cost reduction between 30% and 50% over our current model."
  },
  {
    "id": 12,
    "topic": "Storage",
    "question": "At Dress4Win, an operations engineer wants to create a tow-cost solution to remotely archive copies of database backup files.\nThe database files are compressed tar files stored in their current data center.\nHow should he proceed?",
    "options": {
      "A": "Create a cron script using gsutil to copy the files to a Coldline Storage bucket.",
      "B": "Create a cron script using gsutil to copy the files to a Regional Storage bucket.",
      "C": "Create a Cloud Storage Transfer Service Job to copy the files to a Coldline Storage bucket.",
      "D": "Create a Cloud Storage Transfer Service job to copy the files to a Regional Storage bucket."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The goal is low-cost archival of backup files from an on-premises data center. Cloud Storage Coldline provides the lowest storage cost for infrequently accessed data. Since the files originate on-premises, `gsutil` is the standard tool for uploading them to Cloud Storage. Automating this upload using a cron script running on-premises is a common pattern. Storage Transfer Service (C, D) is mainly for cloud-to-cloud or large online transfers from HTTP sources, not directly from on-prem filesystems. Regional storage (B, D) is more expensive than Coldline for archival.",
    "conditions": [
      "Low-cost archival needed",
      "Archive database backups (compressed tar files)",
      "Files originate from on-premises data center"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, ecommerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong>: For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL. One server for user data, inventory, static data (MySQL 5.7, 8 core CPUs, 128 GB of RAM, 2x 5 TB HDD (RAID 1)). Compute: 40 web application servers providing micro-services based APIs and static content (Tomcat - Java, Nginx, Four core CPUs, 32 GB of RAM). 20 Apache Hadoop/Spark servers (Data analysis, Real-time trending calculations, Eight core CPUs, 128 GB of RAM, 4x 5 TB HDD (RAID 1)). Three RabbitMQ servers for messaging, social notifications, and events (Eight core CPUs, 32GB of RAM). Miscellaneous servers (Jenkins, monitoring, bastion hosts, security scanners, Eight core CPUs, 32GB of RAM). Storage appliances: iSCSI for VM hosts. Fibre channel SAN - MySQL databases (1 PB total storage; 400 TB available). NAS - image storage, logs, backups (100 TB total storage; 35 TB available).\n<strong><strong>Business Requirements </strong>: </strong><br> Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and identity and access management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud.\n<strong>Technical requirements: </strong><br> Easily create non-production environments in the cloud. Implement an automation framework for provisioning resources in cloud. Implement a continuous deployment process for deploying applications to the on-premises data center or cloud. Support failover of the production environment to cloud during an emergency. Encrypt data on the wire and at rest. Support multiple private connections between the production data center and cloud environment.\n<strong>Executive statement: </strong><br> Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a competitor could use a public cloud platform to offset their up-front investment and free them to focus on developing better features. Our traffic patterns are highest in the mornings and weekend evenings; during other times, 80% of our capacity is sitting idle. Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years for a public cloud strategy achieves a cost reduction between 30% and 50% over our current model."
  },
  {
    "id": 13,
    "topic": "DevOps",
    "question": "For this question, refer to the Dress4Win case study.\nDress4Win has end-to-end tests covering 100% of their endpoints. They want to ensure that the move to the cloud does not introduce any new bugs. Which additional testing methods should the developers employ to prevent an outage?",
    "options": {
      "A": "They should enable Google Stackdriver Debugger on the application code to show errors in the code.",
      "B": "They should add additional unit tests and production scale load tests on their cloud staging environment.",
      "C": "They should run the end-to-end tests in the cloud staging environment to determine if the code is working as intended.",
      "D": "They should add canary tests so developers can measure how much of an impact the new release causes to latency."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "While existing end-to-end tests are valuable (and should be run in the cloud environment - C), they don't guarantee bug prevention or performance at scale. To thoroughly vet the cloud migration: Unit tests ensure individual code components function correctly after potential refactoring or environment changes. Production-scale load tests simulate realistic user traffic in the cloud staging environment to identify performance bottlenecks, scaling issues, or bugs that only manifest under load. These additions (B) provide deeper coverage than just re-running existing end-to-end tests. Debugger (A) is for troubleshooting, not pre-release testing. Canary tests (D) are a deployment strategy, not a testing method to run *before* release.",
    "conditions": [
      "100% end-to-end test coverage exists",
      "Migrating to cloud",
      "Goal: Prevent new bugs and outages",
      "Need additional testing methods beyond existing end-to-end tests"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, ecommerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong>: For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL. One server for user data, inventory, static data (MySQL 5.7, 8 core CPUs, 128 GB of RAM, 2x 5 TB HDD (RAID 1)). Compute: 40 web application servers providing micro-services based APIs and static content (Tomcat - Java, Nginx, Four core CPUs, 32 GB of RAM). 20 Apache Hadoop/Spark servers (Data analysis, Real-time trending calculations, Eight core CPUs, 128 GB of RAM, 4x 5 TB HDD (RAID 1)). Three RabbitMQ servers for messaging, social notifications, and events (Eight core CPUs, 32GB of RAM). Miscellaneous servers (Jenkins, monitoring, bastion hosts, security scanners, Eight core CPUs, 32GB of RAM). Storage appliances: iSCSI for VM hosts. Fibre channel SAN - MySQL databases (1 PB total storage; 400 TB available). NAS - image storage, logs, backups (100 TB total storage; 35 TB available).\n<strong><strong>Business Requirements </strong>: </strong><br> Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and identity and access management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud.\n<strong>Technical requirements: </strong><br> Easily create non-production environments in the cloud. Implement an automation framework for provisioning resources in cloud. Implement a continuous deployment process for deploying applications to the on-premises data center or cloud. Support failover of the production environment to cloud during an emergency. Encrypt data on the wire and at rest. Support multiple private connections between the production data center and cloud environment.\n<strong>Executive statement: </strong><br> Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a competitor could use a public cloud platform to offset their up-front investment and free them to focus on developing better features. Our traffic patterns are highest in the mornings and weekend evenings; during other times, 80% of our capacity is sitting idle. Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years for a public cloud strategy achieves a cost reduction between 30% and 50% over our current model."
  },
  {
    "id": 14,
    "topic": "Operations",
    "question": "For this question, refer to the Dress4Win case study.\nAs part of Dress4Win's plans to migrate to the cloud, they want to be able to set up a managed logging and monitoring system so they can handle spikes in their traffic load.\nThey want to ensure that:\n\n* The infrastructure can be notified when it needs to scale up and down to handle the ebb and flow of usage throughout the day\n* Their administrators are notified automatically when their application reports errors.\n* They can filter their aggregated logs down in order to debug one piece of the application across many hosts\n\nWhich Google StackDriver features should they use?",
    "options": {
      "A": "Logging, Alerts, Insights, Debug",
      "B": "Monitoring, Trace, Debug, Logging",
      "C": "Monitoring, Logging, Alerts, Error Reporting",
      "D": "Monitoring, Logging, Debug, Error Reporting"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Mapping requirements: Scaling notifications rely on Cloud Monitoring metrics driving autoscalers or custom Alerts. Admin notifications for application errors are handled by Alerts (based on logs/metrics) and Error Reporting (for aggregated error data). Filtering aggregated logs for debugging is the core function of Cloud Logging (Log Explorer). Option C includes Monitoring, Logging, Alerts, and Error Reporting, addressing all requirements. Debugger and Trace are for different purposes (code-level debugging and latency analysis, respectively).",
    "conditions": [
      "Set up managed logging and monitoring",
      "Handle traffic spikes (implies scaling needs)",
      "Notify infrastructure for scaling",
      "Notify admins on application errors",
      "Filter aggregated logs for debugging"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, ecommerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong>: For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL. One server for user data, inventory, static data (MySQL 5.7, 8 core CPUs, 128 GB of RAM, 2x 5 TB HDD (RAID 1)). Compute: 40 web application servers providing micro-services based APIs and static content (Tomcat - Java, Nginx, Four core CPUs, 32 GB of RAM). 20 Apache Hadoop/Spark servers (Data analysis, Real-time trending calculations, Eight core CPUs, 128 GB of RAM, 4x 5 TB HDD (RAID 1)). Three RabbitMQ servers for messaging, social notifications, and events (Eight core CPUs, 32GB of RAM). Miscellaneous servers (Jenkins, monitoring, bastion hosts, security scanners, Eight core CPUs, 32GB of RAM). Storage appliances: iSCSI for VM hosts. Fibre channel SAN - MySQL databases (1 PB total storage; 400 TB available). NAS - image storage, logs, backups (100 TB total storage; 35 TB available).\n<strong><strong>Business Requirements </strong>: </strong><br> Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and identity and access management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud.\n<strong>Technical requirements: </strong><br> Easily create non-production environments in the cloud. Implement an automation framework for provisioning resources in cloud. Implement a continuous deployment process for deploying applications to the on-premises data center or cloud. Support failover of the production environment to cloud during an emergency. Encrypt data on the wire and at rest. Support multiple private connections between the production data center and cloud environment.\n<strong>Executive statement: </strong><br> Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a competitor could use a public cloud platform to offset their up-front investment and free them to focus on developing better features. Our traffic patterns are highest in the mornings and weekend evenings; during other times, 80% of our capacity is sitting idle. Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years for a public cloud strategy achieves a cost reduction between 30% and 50% over our current model."
  },
  {
    "id": 15,
    "topic": "Networking",
    "question": "For this question, refer to the Dress4Win case study.\nThe current Dress4Win system architecture has high latency to some customers because it is located in one data center.\nAs part of a future evaluation and optimizing for performance in the cloud, Dresss4Win wants to distribute its system architecture to multiple locations when using Google cloud platform.\nWhich approach should they use?",
    "options": {
      "A": "Use regional managed instance groups and a global load balancer to increase performance because the regional managed instance groups can grow instances in each region separately based on traffic.",
      "B": "Use a global load balancer with a set of virtual machines that forward the requests to a closer group of virtual machines managed by your operations team.",
      "C": "Use regional managed instance groups and a global load balancer to increase reliability by providing automatic failover between zones in different regions.",
      "D": "Use a global load balancer with a set of virtual machines that forward the requests to a closer group of virtual machines as part of a separate managed instance groups."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Distributing the architecture across multiple GCP regions minimizes latency for global users. Regional Managed Instance Groups (MIGs) allow deploying application instances close to users in different regions and scaling them independently based on regional traffic. A Global HTTP(S) Load Balancer provides a single global IP address and routes user requests to the nearest healthy regional MIG, optimizing performance (latency). Option A correctly describes this architecture.",
    "conditions": [
      "High latency due to single data center location",
      "Need to distribute architecture to multiple GCP locations",
      "Optimize for performance (reduce latency)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, ecommerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong>: For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL. One server for user data, inventory, static data (MySQL 5.7, 8 core CPUs, 128 GB of RAM, 2x 5 TB HDD (RAID 1)). Compute: 40 web application servers providing micro-services based APIs and static content (Tomcat - Java, Nginx, Four core CPUs, 32 GB of RAM). 20 Apache Hadoop/Spark servers (Data analysis, Real-time trending calculations, Eight core CPUs, 128 GB of RAM, 4x 5 TB HDD (RAID 1)). Three RabbitMQ servers for messaging, social notifications, and events (Eight core CPUs, 32GB of RAM). Miscellaneous servers (Jenkins, monitoring, bastion hosts, security scanners, Eight core CPUs, 32GB of RAM). Storage appliances: iSCSI for VM hosts. Fibre channel SAN - MySQL databases (1 PB total storage; 400 TB available). NAS - image storage, logs, backups (100 TB total storage; 35 TB available).\n<strong><strong>Business Requirements </strong>: </strong><br> Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and identity and access management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud.\n<strong>Technical requirements: </strong><br> Easily create non-production environments in the cloud. Implement an automation framework for provisioning resources in cloud. Implement a continuous deployment process for deploying applications to the on-premises data center or cloud. Support failover of the production environment to cloud during an emergency. Encrypt data on the wire and at rest. Support multiple private connections between the production data center and cloud environment.\n<strong>Executive statement: </strong><br> Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a competitor could use a public cloud platform to offset their up-front investment and free them to focus on developing better features. Our traffic patterns are highest in the mornings and weekend evenings; during other times, 80% of our capacity is sitting idle. Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years for a public cloud strategy achieves a cost reduction between 30% and 50% over our current model."
  },
  {
    "id": 16,
    "topic": "Databases",
    "question": "For this question, refer to the Dress4Win case study.\nDress4Win has asked you for advice on how to migrate their on-premises MySQL deployment to the cloud.\nThey want to minimize downtime and performance impact to their on-premises solution during the migration.\nWhich approach should you recommend?",
    "options": {
      "A": "Create a dump of the on-premises MySQL master server, and then shut it down, upload it to the cloud environment, and load into a new MySQL cluster.",
      "B": "Setup a MySQL replica server/slave in the cloud environment, and configure it for asynchronous replication from the MySQL master server on-premises until cutover.",
      "C": "Create a new MySQL cluster in the cloud, configure applications to begin writing to both on premises and cloud MySQL masters, and destroy the original cluster at cutover.",
      "D": "Create a dump of the MySQL replica server into the cloud environment, load it into: Google Cloud Datastore, and configure applications to read/write to Cloud Datastore at cutover."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Setting up a cloud-based replica (e.g., Cloud SQL) of the on-premises MySQL master allows continuous data synchronization with minimal impact on the source database. During the cutover, applications are briefly stopped, the replica is promoted to master, and applications are pointed to the new cloud database. This asynchronous replication method (B) minimizes downtime compared to a full dump and restore (A). Dual writing (C) is complex and risky for consistency. Migrating to Datastore (D) is a significant change, not a like-for-like migration.",
    "conditions": [
      "Migrate on-premises MySQL to cloud",
      "Minimize downtime",
      "Minimize performance impact on source during migration"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, ecommerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong>: For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL. One server for user data, inventory, static data (MySQL 5.7, 8 core CPUs, 128 GB of RAM, 2x 5 TB HDD (RAID 1)). Compute: 40 web application servers providing micro-services based APIs and static content (Tomcat - Java, Nginx, Four core CPUs, 32 GB of RAM). 20 Apache Hadoop/Spark servers (Data analysis, Real-time trending calculations, Eight core CPUs, 128 GB of RAM, 4x 5 TB HDD (RAID 1)). Three RabbitMQ servers for messaging, social notifications, and events (Eight core CPUs, 32GB of RAM). Miscellaneous servers (Jenkins, monitoring, bastion hosts, security scanners, Eight core CPUs, 32GB of RAM). Storage appliances: iSCSI for VM hosts. Fibre channel SAN - MySQL databases (1 PB total storage; 400 TB available). NAS - image storage, logs, backups (100 TB total storage; 35 TB available).\n<strong><strong>Business Requirements </strong>: </strong><br> Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and identity and access management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud.\n<strong>Technical requirements: </strong><br> Easily create non-production environments in the cloud. Implement an automation framework for provisioning resources in cloud. Implement a continuous deployment process for deploying applications to the on-premises data center or cloud. Support failover of the production environment to cloud during an emergency. Encrypt data on the wire and at rest. Support multiple private connections between the production data center and cloud environment.\n<strong>Executive statement: </strong><br> Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a competitor could use a public cloud platform to offset their up-front investment and free them to focus on developing better features. Our traffic patterns are highest in the mornings and weekend evenings; during other times, 80% of our capacity is sitting idle. Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years for a public cloud strategy achieves a cost reduction between 30% and 50% over our current model."
  },
  {
    "id": 17,
    "topic": "Data Analytics",
    "question": "Your company captures all web traffic data in Google Analytics 260 and stores it in BigQuery. Each country has its own dataset. Each dataset has multiple tables.\nYou want analysts from each country\nto be able to see and query only the data for their respective countries. How should you configure the access rights?",
    "options": {
      "A": "Create a group per country. Add analysts to their respective country-groups. Create a single group ‘all_analysts’, and add all country-groups as members. Grant the ‘all_analysis’ group the IAM role of BigQuery jobUser. Share the appropriate dataset with view access with each respective analyst country-group.",
      "B": "Create a group per country. Add analysts to their respective country-groups. Create a single group ‘all_analysts’, and add all country-groups as members. Grant the ‘all_analysis’ group the IAM role of BigQuery jobUser. Share the appropriate tables with view access with each respective analyst country-group.",
      "C": "Create a group per country. Add analysts to their respective country-groups. Create a single group ‘all_analysts’, and add all country-groups as members. Grant the ‘all_analysis’ group the IAM role of BigQuery dataViewer. Share the appropriate dataset with view access with each respective analyst country-group.",
      "D": "Create a group per country. Add analysts to their respective country-groups. Create a single group ‘all_analysts’, and add all country-groups as members. Grant the ‘all_analysis’ group the IAM role of BigQuery dataViewer. Share the appropriate table with view access with each respective analyst country-group."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To allow users to run queries (incurring cost) while restricting data access, grant the `roles/bigquery.jobUser` at the project level (to the 'all_analysts' group). This gives permission to execute jobs. Then, grant dataset-level access control: share each country-specific dataset with 'Viewer' access only to the corresponding country-specific group. This ensures analysts can run queries but only see the data within the datasets shared with their group.",
    "conditions": [
      "GA360 data in BigQuery",
      "Data separated by country dataset",
      "Analysts must only see/query their own country's data"
    ],
    "caseStudyContext": null
  },
  {
    "id": 18,
    "topic": "Cost Optimization",
    "question": "Your company is running its application workloads on Compute Engine. The applications have been deployed in production, acceptance, and development environments. The production environment is business-critical and is used 24/7, while the acceptance and development environments are only critical during office hours. Your CFO has asked you to optimize these environments to achieve cost savings during idle times. What should you do?",
    "options": {
      "A": "Create a shell script that uses the gcloud command to change the machine type of the development and acceptance instances to a smaller machine type outside of office hours.",
      "B": "Schedule the shell script on one of the production instances to automate the task.",
      "C": "Use Cloud Scheduler to trigger a Cloud Function that will stop the development and acceptance environments after office hours and start them just before office hours.",
      "D": "Deploy the development and acceptance applications on a managed instance group and enable autoscaling.",
      "E": "Use regular Compute Engine instances for the production environment, and use preemptible VMs for the acceptance and development environments."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To save costs during idle times (outside office hours) for non-production environments, stopping the instances entirely is the most effective method. Cloud Scheduler can trigger events on a defined schedule (e.g., stop at 7 PM, start at 7 AM). A Cloud Function can receive these triggers and use the Compute Engine API to stop/start the relevant instances in the development and acceptance environments. Option A resizes but still incurs disk costs. Option B runs the script from production (not ideal). Option D (autoscaling) might scale down but not necessarily to zero. Option E (preemptible) is unsuitable for environments needed consistently during office hours.",
    "conditions": [
      "Prod (24/7), Acceptance/Dev (office hours only) environments on GCE",
      "Optimize cost during idle times (outside office hours) for Acc/Dev"
    ],
    "caseStudyContext": null
  },
  {
    "id": 19,
    "topic": "Compute",
    "question": "Your company has an application running on Compute Engine mat allows users to play their favorite music. There are a fixed number of instances Files are stored in Cloud Storage and data is streamed directly to users. Users are reporting that they sometimes need to attempt to play popular songs multiple times before they are successful. You need to improve the performance of the application. What should you do?",
    "options": {
      "A": "1. Copy popular songs into CloudSQL as a blob\n2. Update application code to retrieve data from CloudSQL when Cloud Storage is overloaded",
      "B": "1. Create a managed instance group with Compute Engine instances\n2. Create a global toad balancer and configure ii with two backbends\n* Managed instance group\n* Cloud Storage bucket\n3. Enable Cloud CDN on the bucket backend",
      "C": "1. Mount the Cloud Storage bucket using gcsfuse on all backend Compute Engine instances\n2. Serve muse files directly from the backend Compute Engine instance",
      "D": "1. Create a Cloud Filestore NFS volume and attach it to the backend Compute Engine instances\n2. Download popular songs in Cloud Filestore\n3. Serve music Wes directly from the backend Compute Engine instance"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "The issue with popular songs suggests that either the fixed number of instances or direct GCS access is becoming a bottleneck under high demand. Option B addresses this by: 1) Using a Managed Instance Group (MIG) to allow the application servers to scale. 2) Using a Global Load Balancer to distribute traffic. 3) Configuring the GCS bucket as a backend *and* enabling Cloud CDN on it. Cloud CDN will cache popular songs at edge locations, drastically reducing latency and load on the GCS bucket for frequently requested files. This combination provides scalability for the app and efficient delivery for popular content.",
    "conditions": [
      "Music streaming app on fixed number of GCE instances",
      "Files in Cloud Storage, streamed directly",
      "Intermittent failures playing popular songs",
      "Need to improve performance"
    ],
    "caseStudyContext": null
  },
  {
    "id": 20,
    "topic": "API Management",
    "question": "Your company provides a recommendation engine for retail customers. You are providing retail customers with an API where they can submit a user ID and the API returns a list of recommendations for that user. You are responsible for the API lifecycle and want to ensure stability for your customers in case the API makes backward-incompatible changes. You want to follow Google-recommended practices. What should you do?",
    "options": {
      "A": "Create a distribution list of all customers to inform them of an upcoming backward-incompatible change at least one month before replacing the old API with the new API.",
      "B": "Create an automated process to generate API documentation, and update the public API documentation as part of the CI/CD process when deploying an update to the API.",
      "C": "Use a versioning strategy for the APIs that increases the version number on every backward-incompatible change.",
      "D": "Use a versioning strategy for the APIs that adds the suffix a€DEPRECATEDa€é to the current API version number on every backward-incompatible change. Use the current version number for the new API."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The standard and recommended practice for handling backward-incompatible API changes is semantic versioning, typically reflected in the API path (e.g., /v1/recommendations, /v2/recommendations). When an incompatible change is needed, a new version (v2) is released (C). The old version (v1) remains available for a defined deprecation period, giving clients time to migrate without breaking their existing integrations. Communication (A) and documentation (B) are important but don't technically prevent breakage like versioning does. Suffixes (D) are non-standard.",
    "conditions": [
      "Providing API to retail customers",
      "Responsible for API lifecycle",
      "Ensure stability during backward-incompatible changes",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 21,
    "topic": "Storage",
    "question": "Your company has been storing 100 TB of data in a multi-regional bucket for 2 years. Your CFO wants to reduce costs because the data is not being accessed frequently. You need to ensure that this data is archived and follows Google-recommended practices. What should you do?",
    "options": {
      "A": "Create a lifecycle rule to migrate the data to Coldline class storage.",
      "B": "Move the data to another bucket using the gsutil tool with the regional class specified.",
      "C": "Use Cloud Dataflow to migrate the data to BigQuery tables and configure the tables to use long-term storage.",
      "D": "Export the data to tape storage using the Google Transfer appliance and send it to an offsite location."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The data is 2 years old and accessed infrequently, making it ideal for archival storage. Cloud Storage Coldline offers the lowest storage cost for data accessed less than annually. The most efficient way to move existing data in a bucket to a different storage class is using Object Lifecycle Management rules. Creating a rule to transition objects older than a certain age (e.g., immediately, or after 30/90 days depending on access patterns) to Coldline storage class (A) directly addresses the cost reduction goal for infrequently accessed data. Moving to a regional bucket (B) doesn't guarantee lowest cost. BigQuery (C) is for analytics, not archival. Transfer Appliance (D) is for large ingress/egress, not changing storage class.",
    "conditions": [
      "100 TB data stored in Multi-Regional bucket for 2 years",
      "Data not accessed frequently",
      "Need to reduce costs",
      "Archive data following Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 22,
    "topic": "Migration",
    "question": "Your web application has several VM instances running within a VPC. You want to restrict communications between instances to only the paths and ports you authorize, but you don't want to rely on static IP addresses or subnets because the app can autoscale. How should you restrict communications?",
    "options": {
      "A": "Use separate VPCs to restrict traffic.",
      "B": "Use firewall rules based on network tags attached to the compute instances.",
      "C": "Use Cloud DNS and only allow connections from authorized hostnames.",
      "D": "Use service accounts and configure the web application to authorize particular service accounts to have access."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "GCP Firewall rules can target instances based on network tags or service accounts, rather than static IPs. By assigning specific tags to different tiers or groups of instances (e.g., 'frontend', 'backend-service-a'), you can create firewall rules that allow traffic only between specific tags on specific ports/protocols (B). This works seamlessly with autoscaling, as new instances automatically inherit the tags from their instance template. Service accounts can also be used similarly in firewall rules. Separate VPCs (A) introduce complexity. Cloud DNS (C) doesn't enforce network restrictions.",
    "conditions": [
      "Multiple VM instances in one VPC",
      "Restrict inter-instance communication (specific paths/ports)",
      "Cannot rely on static IPs/subnets (autoscaling)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 23,
    "topic": "Networking",
    "question": "You want to establish a Compute Engine application in a single VPC across two regions. The application must communicate over VPN to an on-premises network. How should you deploy the VPN?",
    "options": {
      "A": "Use VPC Network Peering between the VPC and the on-premises network.",
      "B": "Expose the VPC to the on-premises network using IAM and VPC Sharing.",
      "C": "Create a global Cloud VPN Gateway with VPN tunnels from each region to the on- premises peer gateway.",
      "D": "Deploy Cloud VPN Gateway in each region. Ensure that each region has at least one VPN tunnel to the on-premises peer gateway."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Cloud VPN gateways are regional resources. To provide resilient VPN connectivity for resources spanning multiple regions within a single VPC, you should deploy a Cloud VPN gateway in each relevant region (D). Each regional gateway should establish tunnel(s) to the on-premises peer gateway. Dynamic routing (using Cloud Router with BGP) should be configured to advertise routes correctly between on-premises and the different GCP regions via their respective VPN gateways. There is no 'global' Cloud VPN gateway (C). Peering (A) is for VPC-to-VPC. IAM/VPC Sharing (B) are irrelevant.",
    "conditions": [
      "GCE application in single VPC across two regions",
      "Requires VPN connectivity to on-premises",
      "Need VPN deployment strategy"
    ],
    "caseStudyContext": null
  },
  {
    "id": 24,
    "topic": "IAM & Security",
    "question": "Your company has stored sensitive data in a Cloud Storage bucket. For regulatory reasons, your company must be able to rotate the encryption key used to encrypt the data in the bucket. The data will be processed in Dataproc. You want to follow Google-recommended practices for security. What should you do?",
    "options": {
      "A": "Create a key with Cloud Key Management Service (KMS). Encrypt the data using the encrypt method of Cloud KMS.",
      "B": "Create a key with Cloud Key Management Service (KMS). Set the encryption key on the bucket to the Cloud KMS key.",
      "C": "Generate a GPG key pair. Encrypt the data using the GPG key. Upload the encrypted data to the bucket.",
      "D": "Generate an AES-256 encryption key. Encrypt the data in the bucket using the customer-supplied encryption keys feature."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Using Customer-Managed Encryption Keys (CMEK) with Cloud Storage allows Google to perform encryption/decryption using a key managed within Cloud KMS. This meets the requirement for key rotation (managed via KMS policies) and integrates seamlessly with other GCP services like Dataproc (which can be granted permission to use the key). Option B describes setting the bucket's default encryption key to a KMS key. Option A involves manual encryption before upload. Options C and D involve managing keys outside GCP (CSEK or manual GPG), adding complexity and potentially hindering integration with Dataproc.",
    "conditions": [
      "Sensitive data in Cloud Storage bucket",
      "Must be able to rotate encryption key (regulatory requirement)",
      "Data processed by Dataproc",
      "Follow Google recommended security practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 25,
    "topic": "Security",
    "question": "You need to establish a secure, high-throughput connection between your data center and your Google Cloud VPC. You need to encrypt the traffic in transit. The current VPN connection does not meet the throughput requirements. What should you do?",
    "options": {
      "A": "Set up Carrier Peering for the connection.",
      "B": "Set up Direct Peering for the connection.",
      "C": "Set up MACsec for Cloud Interconnect for the connection.",
      "D": "Set up HA VPN over Cloud Interconnect for the connection."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Cloud Interconnect (Dedicated or Partner) provides high-throughput, private connectivity. However, traffic over Interconnect is not encrypted by default. To achieve both high throughput and encryption in transit, the recommended solution is to configure HA VPN *over* the Cloud Interconnect connection. This tunnels encrypted VPN traffic across the private Interconnect link, meeting both requirements. MACsec (C) provides Layer 2 encryption but requires specific hardware and is configured directly on the Interconnect link itself, whereas VPN over Interconnect provides Layer 3 encryption. Peering (A, B) does not provide encryption or private RFC1918 connectivity.",
    "conditions": [
      "Need secure, high-throughput connection (Data center to GCP VPC)",
      "Encrypt traffic in transit",
      "Current VPN throughput insufficient"
    ],
    "caseStudyContext": null
  },
  {
    "id": 26,
    "topic": "Data Processing",
    "question": "You need to analyze and define the technical architecture for the data workloads for your company, TerramEarth.\nConsidering the TerramEarth business and technical requirements, what should you do?",
    "options": {
      "A": "Ingest the data using Cloud Dataflow. Use Cloud Pub/Sub to store the ingested data. Use BigQuery for data analytics.",
      "B": "Ingest the data using Cloud Pub/Sub. Use Cloud Dataflow to process the ingested data. Use BigQuery for data analytics.",
      "C": "Ingest the data using Cloud Pub/Sub. Use Cloud Dataflow to process the ingested data. Use Cloud Spanner for data analytics.",
      "D": "Ingest the data using Cloud Pub/Sub. Use Cloud Dataproc to process the ingested data. Use BigQuery for data analytics."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "This describes a standard GCP stream processing architecture suitable for TerramEarth's telemetry data. Cloud Pub/Sub acts as the scalable ingestion point. Cloud Dataflow provides stream (and batch) processing capabilities for transformation, enrichment, and real-time analysis. BigQuery serves as the scalable data warehouse for storing processed data and enabling large-scale analytics required by business/technical requirements. Option A reverses Dataflow and Pub/Sub roles. Option C incorrectly suggests Spanner (OLTP) for analytics. Option D suggests Dataproc (batch-oriented Hadoop/Spark) instead of Dataflow for stream processing.",
    "conditions": [
      "Define data workload architecture",
      "Handles large volume streaming telemetry data",
      "Requires processing and large-scale analytics",
      "Align with TerramEarth business/technical requirements"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong>: There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong><strong>Business Requirements </strong>: </strong><br> Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical requirements: </strong><br> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive statement: </strong><br> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 27,
    "topic": "Networking",
    "question": "Your company has an application running on Compute Engine that allows users to play their favorite music. There are a fixed number of instances Files are stored in Cloud Storage and data is streamed directly to users. Users are reporting that they sometimes need to attempt to play popular songs multiple times before they are successful. You need to improve the performance of the application. What should you do?",
    "options": {
      "A": "1. Copy popular songs into CloudSQL as a blob\n2. Update application code to retrieve data from CloudSQL when Cloud Storage is overloaded",
      "B": "1. Create a managed instance group with Compute Engine instances\n2. Create a global toad balancer and configure ii with two backbends\n* Managed instance group\n* Cloud Storage bucket\n3. Enable Cloud CDN on the bucket backend",
      "C": "1. Mount the Cloud Storage bucket using gcsfuse on all backend Compute Engine instances\n2. Serve muse files directly from the backend Compute Engine instance",
      "D": "1. Create a Cloud Filestore NFS volume and attach it to the backend Compute Engine instances\n2. Download popular songs in Cloud Filestore\n3. Serve music Wes directly from the backend Compute Engine instance"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Failures on popular songs indicate a bottleneck likely related to serving high-demand content from GCS or the fixed instances. Option B provides a robust solution: Use a Managed Instance Group (MIG) for scalability of the application instances. Use a Global Load Balancer to distribute requests. Configure the GCS bucket as a load balancer backend and enable Cloud CDN. The CDN will cache popular songs close to users, reducing latency and load on GCS, while the MIG allows the application itself to scale.",
    "conditions": [
      "Music streaming app on fixed GCE instances",
      "Files in GCS, streamed directly to users",
      "Intermittent failures for popular songs",
      "Need performance improvement"
    ],
    "caseStudyContext": null
  },
  {
    "id": 28,
    "topic": "IAM & Security",
    "question": "Your company is developing a new application that will allow globally distributed users to upload pictures and share them with other selected users. The application will support millions of concurrent users. You want to allow developers to focus on just building code without having to create and maintain the underlying infrastructure. Which service should you use to deploy the application?",
    "options": {
      "A": "App Engine",
      "B": "Cloud Endpoints",
      "C": "Compute Engine",
      "D": "Google Kubernetes Engine"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "App Engine (Standard or Flexible) is a fully managed, serverless platform designed for web applications and APIs that need to scale automatically to handle large numbers of users (millions) and variable traffic. It abstracts away infrastructure management, allowing developers to focus on code. Compute Engine (C) and GKE (D) require infrastructure management. Cloud Endpoints (B) is an API management layer, not the primary compute/deployment platform.",
    "conditions": [
      "New application: picture upload/sharing",
      "Globally distributed users",
      "Millions of concurrent users",
      "Developers focus only on code (no infra management)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 29,
    "topic": "Storage",
    "question": "Your company is planning to upload several important files to Cloud Storage. After the upload is completed, they want to verify that the uploaded content is identical to what they have on-premises. You want to minimize the cost and effort of performing this check. What should you do?",
    "options": {
      "A": "1. Use Linux shasum to compute a digest of files you want to upload. 2. Use gsutil -m to upload all the files to Cloud Storage. 3. Use gsutil cp to download the uploaded files. 4. Use Linux shasum to compute a digest of the downloaded files. 5. Compare the hashes.",
      "B": "1. Use gsutil -m to upload the files to Cloud Storage. 2. Develop a custom Java application that computes CRC32C hashes. 3. Use gsutil ls -L gs://[YOUR_BUCKET_NAME] to collect CRC32C hashes of the uploaded files. 4. Compare the hashes.",
      "C": "1. Use gsutil -m to upload all the files to Cloud Storage. 2. Use gsutil cp to download the uploaded files. 3. Use Linux diff to compare the content of the files.",
      "D": "1. Use gsutil -m to upload the files to Cloud Storage. 2. Use gsutil hash -c FILELNAME to generate CRC32C hashes of all on-premises files. 3. Use gsutil ls -L gs://[YOUR_BUCKET_NAME] to collect CRC32C hashes of the uploaded files. 4. Compare the hashes."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "To verify integrity efficiently: 1. Upload files using `gsutil -m`. 2. Calculate local CRC32C hashes using `gsutil hash -c`. 3. Retrieve the CRC32C hash stored by Cloud Storage using `gsutil ls -L`. 4. Compare the local hash with the Cloud Storage hash. This method (D) avoids re-downloading the files (A, C), saving time and bandwidth costs. It uses the standard `gsutil` tool, avoiding custom application development (B).",
    "conditions": [
      "Upload important files from on-prem to GCS",
      "Verify uploaded content matches original",
      "Minimize cost and effort"
    ],
    "caseStudyContext": null
  },
  {
    "id": 30,
    "topic": "IAM & Security",
    "question": "You are responsible for the Google Cloud environment in your company. Multiple departments need access to their own projects, and the members within each department will have the same project responsibilities. You want to structure your Google Cloud environment for minimal maintenance and maximum overview of IAM permissions as each department's projects start and end. You want to follow Google-recommended practices. What should you do?",
    "options": {
      "A": "Grant all department members the required IAM permissions for their respective projects.",
      "B": "Create a Google Group per department and add all department members to their respective groups. Create a folder per department and grant the respective group the required IAM permissions at the folder level. Add the projects under the respective folders.",
      "C": "Create a folder per department and grant the respective members of the department the required IAM permissions at the folder level. Structure all projects for each department under the respective folders.",
      "D": "Create a Google Group per department and add all department members to their respective groups. Grant each group the required IAM permissions for their respective projects."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Google recommended practice is to manage permissions using Google Groups and the resource hierarchy (Folders). Create a Group for each department. Create a Folder for each department. Grant the required IAM roles to the department's Group at the Folder level. Place all department projects within their respective Folder. This way, permissions are inherited by all projects in the folder, and managing access only requires updating Group membership, minimizing maintenance (B). Options A, C, and D involve managing permissions individually or at the project level, which is less efficient and scalable.",
    "conditions": [
      "Manage GCP environment for multiple departments",
      "Members within a department have same responsibilities",
      "Minimize maintenance, maximize IAM overview",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 31,
    "topic": "Storage",
    "question": "You need to deploy a stateful workload on Google Cloud. The workload can scale horizontally, but each instance needs to read and write to the same POSIX filesystem. At high load, the stateful workload needs to support up to 100 MB/s of writes. What should you do?",
    "options": {
      "A": "Use a persistent disk for each instance.",
      "B": "Use a regional persistent disk for each instance.",
      "C": "Create a Cloud Filestore instance and mount it in each instance.",
      "D": "Create a Cloud Storage bucket and mount it in each instance using gcsfuse."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The requirement for multiple instances to read/write concurrently to the same POSIX filesystem points to a shared file system. Cloud Filestore provides managed NFS file shares that offer POSIX compliance and can be mounted by multiple instances. Filestore performance tiers can meet the 100 MB/s write requirement. Persistent disks (A, B) cannot be mounted read-write by multiple instances simultaneously. GCSfuse (D) provides object storage access via a filesystem interface but lacks full POSIX compliance and performance guarantees for write-heavy stateful workloads.",
    "conditions": [
      "Deploy stateful workload",
      "Horizontally scalable",
      "All instances need read/write access to the *same* POSIX filesystem",
      "Support up to 100 MB/s writes"
    ],
    "caseStudyContext": null
  },
  {
    "id": 32,
    "topic": "Networking",
    "question": "You need to implement a network ingress for a new game that meets the defined business and technical requirements. Mountkirk Games wants each regional game instance to be located in multiple Google Cloud regions. What should you do?",
    "options": {
      "A": "Configure a global load balancer connected to a managed instance group running Compute Engine instances.",
      "B": "Configure kubemci with a global load balancer and Google Kubernetes Engine.",
      "C": "Configure a global load balancer with Google Kubernetes Engine.",
      "D": "Configure Ingress for Anthos with a global load balancer and Google Kubernetes Engine."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Mountkirk's <strong>Solution Concept </strong><br> uses GKE deployed across multiple regions, fronted by a global load balancer. Ingress for Anthos (formerly Multi Cluster Ingress) is the Google-recommended way to manage a single Ingress resource that configures a global HTTP(S) load balancer to intelligently route traffic to GKE clusters in multiple regions, based on proximity and health. This meets all requirements. `kubemci` (B) is older tooling. Option C lacks the multi-cluster coordination component. Option A uses GCE, not GKE.",
    "conditions": [
      "Implement network ingress for new game",
      "Use GKE",
      "Deploy instances in multiple GCP regions",
      "Use a global load balancer",
      "Minimize latency"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong>: Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong><strong>Business Requirements </strong>: </strong><br> Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical requirements: </strong><br> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive statement: </strong><br> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 33,
    "topic": "Operations",
    "question": "Your development teams release new versions of games running on Google Kubernetes Engine (GKE) daily. You want to create service level indicators (SLIs) to evaluate the quality of the new versions from the user's perspective. What should you do?",
    "options": {
      "A": "Create CPU Utilization and Request Latency as service level indicators.",
      "B": "Create GKE CPU Utilization and Memory Utilization as service level indicators.",
      "C": "Create Request Latency and Error Rate as service level indicators.",
      "D": "Create Server Uptime and Error Rate as service level indicators."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "SLIs should measure aspects of the service directly experienced by users. For an online game or application, Request Latency (how fast it responds) and Error Rate (how often it fails) are key indicators of user-perceived quality and reliability. CPU and Memory utilization (A, B) are resource metrics, important for capacity planning and cost but not direct user experience measures. Server Uptime (D) is a basic availability metric but doesn't capture performance degradation.",
    "conditions": [
      "GKE-based games with daily releases",
      "Need SLIs to evaluate user-perceived quality"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong>: Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong><strong>Business Requirements </strong>: </strong><br> Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical requirements: </strong><br> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive statement: </strong><br> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 34,
    "topic": "IAM & Security",
    "question": "Mountkirk Games wants you to secure the connectivity from the new gaming application platform to Google Cloud. You want to streamline the process and follow Google-recommended practices. What should you do?",
    "options": {
      "A": "Configure Workload Identity and service accounts to be used by the application platform.",
      "B": "Use Kubernetes Secrets, which are obfuscated by default. Configure these Secrets to be used by the application platform.",
      "C": "Configure Kubernetes Secrets to store the secret, enable Application-Layer Secrets Encryption, and use Cloud Key Management Service (Cloud KMS) to manage the encryption keys. Configure these Secrets to be used by the application platform.",
      "D": "Configure HashiCorp Vault on Compute Engine, and use customer managed encryption keys and Cloud Key Management Service (Cloud KMS) to manage the encryption keys. Configure these Secrets to be used by the application platform."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Workload Identity is the Google-recommended method for GKE workloads (the application platform) to securely authenticate to Google Cloud APIs. It allows binding Kubernetes service accounts to Google service accounts, enabling pods to automatically authenticate as the Google service account without needing to manage or mount service account keys. This streamlines the process and follows best practices. Kubernetes Secrets (B, C) are for application-level secrets, not GCP authentication. Vault (D) is a third-party solution that adds complexity compared to the native Workload Identity.",
    "conditions": [
      "Secure connectivity from GKE application platform to GCP services",
      "Streamline process",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong>: Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong><strong>Business Requirements </strong>: </strong><br> Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical requirements: </strong><br> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive statement: </strong><br> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 35,
    "topic": "DevOps",
    "question": "Your development team has created a mobile game app. You want to test the new mobile app on Android and iOS devices with a variety of configurations. You need to ensure that testing is efficient and cost-effective. What should you do?",
    "options": {
      "A": "Upload your mobile app to the Firebase Test Lab, and test the mobile app on Android and iOS devices.",
      "B": "Create Android and iOS VMs on Google Cloud, install the mobile app on the VMs, and test the mobile app.",
      "C": "Create Android and iOS containers on Google Kubernetes Engine (GKE), install the mobile app on the containers, and test the mobile app.",
      "D": "Upload your mobile app with different configurations to Firebase Hosting and test each configuration."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Firebase Test Lab provides a cloud-based infrastructure for testing mobile apps on a wide variety of real and virtual devices and configurations for both Android and iOS. It automates testing execution and provides comprehensive results, making it an efficient and cost-effective solution compared to maintaining a physical device lab or managing emulators/simulators manually. GCE/GKE (B, C) do not natively support Android/iOS environments for app testing. Firebase Hosting (D) is for web content, not native mobile app testing.",
    "conditions": [
      "Test new mobile game app (Android & iOS)",
      "Test on various device configurations",
      "Need efficient and cost-effective solution"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong>: Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong><strong>Business Requirements </strong>: </strong><br> Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical requirements: </strong><br> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive statement: </strong><br> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 36,
    "topic": "Case Study Analysis",
    "question": "For this question, refer to the EHR Healthcare case study.\nYou are responsible for ensuring that EHR's use of Google Cloud will pass an upcoming privacy compliance audit. What should you do? (Choose two.)",
    "options": {
      "A": "Verify EHR's product usage against the list of compliant products on the Google Cloud compliance page.",
      "B": "Advise EHR to execute a Business Associate Agreement (BAA) with Google Cloud.",
      "C": "Use Firebase Authentication for EHR’s user facing applications.",
      "D": "Implement Prometheus to detect and prevent security breaches on EHR's web-based applications.",
      "E": "Use GKE private clusters for all Kubernetes workloads."
    },
    "correctAnswer": [
      "A",
      "B"
    ],
    "explanation": "Passing a privacy compliance audit (likely HIPAA given the healthcare context) requires several actions. A: Verify that all GCP services used to store or process protected health information (PHI) are covered under Google's relevant compliance program (e.g., HIPAA). Google maintains lists of such services. B: Execute a Business Associate Agreement (BAA) with Google Cloud, which is legally required under HIPAA to ensure responsibilities for protecting PHI are understood. Firebase Auth (C), Prometheus (D), and private clusters (E) are security measures but don't directly address the core compliance documentation and service eligibility requirements.",
    "conditions": [
      "Ensure GCP usage passes privacy compliance audit",
      "Healthcare context implies HIPAA or similar regulations"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>EHR Healthcare is a leading provider of electronic health record software to the medical industry. EHR Healthcare provides their software as a service to multi- national medical offices, hospitals, and insurance providers.\n<strong>Solution Concept </strong>: Due to rapid changes in the healthcare and insurance industry, EHR Healthcare's business has been growing exponentially year over year. They need to be able to scale their environment, adapt their disaster recovery plan, and roll out new continuous deployment capabilities to update their software at a fast pace. Google Cloud has been chosen to replace their current colocation facilities.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> EHR's software is currently hosted in multiple colocation facilities. The lease on one of the data centers is about to expire. Customer-facing applications are web-based, and many have recently been containerized to run on a group of Kubernetes clusters. Data is stored in a mixture of relational and NoSQL databases (MySQL, MS SQL Server, Redis, and MongoDB). EHR is hosting several legacy file- and API-based integrations with insurance providers on-premises. These systems are scheduled to be replaced over the next several years. There is no plan to upgrade or move these systems at the current time. Users are managed via Microsoft Active Directory. Monitoring is currently being done via various open source tools. Alerts are sent via email and are often ignored.\n<strong><strong>Business Requirements </strong>: </strong><br> On-board new insurance providers as quickly as possible. Provide a minimum 99.9% availability for all customer-facing systems. Provide centralized visibility and proactive action on system performance and usage. Increase ability to provide insights into healthcare trends. Reduce latency to all customers. Maintain regulatory compliance. Decrease infrastructure administration costs. Make predictions and generate reports on industry trends based on provider data.\n<strong>Technical requirements: </strong><br> Maintain legacy interfaces to insurance providers with connectivity to both on-premises systems and cloud providers. Provide a consistent way to manage customer-facing applications that are container-based. Provide a secure and high-performance connection between on-premises systems and Google Cloud. Provide consistent logging, log retention, monitoring, and alerting capabilities. Maintain and manage multiple container-based environments. Dynamically scale and provision new environments. Create interfaces to ingest and process data from new providers.\n<strong>Executive statement: </strong><br> Our on-premises strategy has worked for years but has required a major investment of time and money in training our team on distinctly different systems, managing similar but separate environments, and responding to outages. Many of these outages have been a result of misconfigured systems, inadequate capacity to manage spikes in traffic, and inconsistent monitoring practices. We want to use Google Cloud to leverage a scalable, resilient platform that can span multiple environments seamlessly and provide a consistent and stable user experience that positions us for future growth."
  },
  {
    "id": 37,
    "topic": "IAM & Security",
    "question": "For this question, refer to the EHR Healthcare case study.\nYou need to define the technical architecture for securely deploying workloads to Google Cloud. You also need to ensure that only verified containers are deployed using Google Cloud services.\nWhat should you do? (Choose two.)",
    "options": {
      "A": "Enable Binary Authorization on GKE, and sign containers as part of a CI/CD pipeline.",
      "B": "Configure Jenkins to utilize Kritis to cryptographically sign a container as part of a CI/CD pipeline.",
      "C": "Configure Container Registry to only allow trusted service accounts to create and deploy containers from the registry.",
      "D": "Configure Container Registry to use vulnerability scanning to confirm that there are no vulnerabilities before deploying the workload."
    },
    "correctAnswer": [
      "A",
      "D"
    ],
    "explanation": "To ensure only verified containers are deployed: A) Enable Binary Authorization, which enforces that only containers signed (attested) by trusted authorities during the CI/CD process can be deployed to GKE. D) Configure vulnerability scanning in Container Registry (or Artifact Registry) to automatically check images for known vulnerabilities. While scanning doesn't block deployment itself, its results are crucial input for the attestation process used by Binary Authorization. Kritis (B) is related but Binary Authorization is the managed GCP service. IAM controls (C) restrict access but don't verify container content.",
    "conditions": [
      "Secure workload deployment architecture",
      "Ensure only verified containers are deployed",
      "Use GCP services"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>EHR Healthcare is a leading provider of electronic health record software to the medical industry. EHR Healthcare provides their software as a service to multi- national medical offices, hospitals, and insurance providers.\n<strong>Solution Concept </strong>: Due to rapid changes in the healthcare and insurance industry, EHR Healthcare's business has been growing exponentially year over year. They need to be able to scale their environment, adapt their disaster recovery plan, and roll out new continuous deployment capabilities to update their software at a fast pace. Google Cloud has been chosen to replace their current colocation facilities.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> EHR's software is currently hosted in multiple colocation facilities. The lease on one of the data centers is about to expire. Customer-facing applications are web-based, and many have recently been containerized to run on a group of Kubernetes clusters. Data is stored in a mixture of relational and NoSQL databases (MySQL, MS SQL Server, Redis, and MongoDB). EHR is hosting several legacy file- and API-based integrations with insurance providers on-premises. These systems are scheduled to be replaced over the next several years. There is no plan to upgrade or move these systems at the current time. Users are managed via Microsoft Active Directory. Monitoring is currently being done via various open source tools. Alerts are sent via email and are often ignored.\n<strong><strong>Business Requirements </strong>: </strong><br> On-board new insurance providers as quickly as possible. Provide a minimum 99.9% availability for all customer-facing systems. Provide centralized visibility and proactive action on system performance and usage. Increase ability to provide insights into healthcare trends. Reduce latency to all customers. Maintain regulatory compliance. Decrease infrastructure administration costs. Make predictions and generate reports on industry trends based on provider data.\n<strong>Technical requirements: </strong><br> Maintain legacy interfaces to insurance providers with connectivity to both on-premises systems and cloud providers. Provide a consistent way to manage customer-facing applications that are container-based. Provide a secure and high-performance connection between on-premises systems and Google Cloud. Provide consistent logging, log retention, monitoring, and alerting capabilities. Maintain and manage multiple container-based environments. Dynamically scale and provision new environments. Create interfaces to ingest and process data from new providers.\n<strong>Executive statement: </strong><br> Our on-premises strategy has worked for years but has required a major investment of time and money in training our team on distinctly different systems, managing similar but separate environments, and responding to outages. Many of these outages have been a result of misconfigured systems, inadequate capacity to manage spikes in traffic, and inconsistent monitoring practices. We want to use Google Cloud to leverage a scalable, resilient platform that can span multiple environments seamlessly and provide a consistent and stable user experience that positions us for future growth."
  },
  {
    "id": 38,
    "topic": "Networking",
    "question": "For this question, refer to the EHR Healthcare case study.\nYou need to upgrade the EHR connection to comply with their requirements. The new connection design must support business-critical needs and meet the same network and security policy requirements.\nWhat should you do?",
    "options": {
      "A": "Add a new Dedicated Interconnect connection.",
      "B": "Upgrade the bandwidth on the Dedicated Interconnect connection to 100 G.",
      "C": "Add three new Cloud VPN connections.",
      "D": "Add a new Carrier Peering connection."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The technical requirements call for a secure, high-performance connection and support for multiple private connections. <strong>Business Requirements </strong><br> include 99.9% availability. Assuming they have an existing connection (likely VPN or a single Interconnect), adding a *second* Dedicated Interconnect connection (A) provides redundancy for high availability and maintains high performance. Upgrading bandwidth (B) doesn't add redundancy. VPN (C) is less performant and reliable than Interconnect. Carrier Peering (D) is typically for reaching Google's public IPs, not private VPC connectivity.",
    "conditions": [
      "Upgrade hybrid connectivity",
      "Support business-critical needs",
      "Meet network/security policies",
      "Requirements: High performance, secure, multiple private connections, 99.9% availability"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>EHR Healthcare is a leading provider of electronic health record software to the medical industry. EHR Healthcare provides their software as a service to multi- national medical offices, hospitals, and insurance providers.\n<strong>Solution Concept </strong>: Due to rapid changes in the healthcare and insurance industry, EHR Healthcare's business has been growing exponentially year over year. They need to be able to scale their environment, adapt their disaster recovery plan, and roll out new continuous deployment capabilities to update their software at a fast pace. Google Cloud has been chosen to replace their current colocation facilities.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> EHR's software is currently hosted in multiple colocation facilities. The lease on one of the data centers is about to expire. Customer-facing applications are web-based, and many have recently been containerized to run on a group of Kubernetes clusters. Data is stored in a mixture of relational and NoSQL databases (MySQL, MS SQL Server, Redis, and MongoDB). EHR is hosting several legacy file- and API-based integrations with insurance providers on-premises. These systems are scheduled to be replaced over the next several years. There is no plan to upgrade or move these systems at the current time. Users are managed via Microsoft Active Directory. Monitoring is currently being done via various open source tools. Alerts are sent via email and are often ignored.\n<strong><strong>Business Requirements </strong>: </strong><br> On-board new insurance providers as quickly as possible. Provide a minimum 99.9% availability for all customer-facing systems. Provide centralized visibility and proactive action on system performance and usage. Increase ability to provide insights into healthcare trends. Reduce latency to all customers. Maintain regulatory compliance. Decrease infrastructure administration costs. Make predictions and generate reports on industry trends based on provider data.\n<strong>Technical requirements: </strong><br> Maintain legacy interfaces to insurance providers with connectivity to both on-premises systems and cloud providers. Provide a consistent way to manage customer-facing applications that are container-based. Provide a secure and high-performance connection between on-premises systems and Google Cloud. Provide consistent logging, log retention, monitoring, and alerting capabilities. Maintain and manage multiple container-based environments. Dynamically scale and provision new environments. Create interfaces to ingest and process data from new providers.\n<strong>Executive statement: </strong><br> Our on-premises strategy has worked for years but has required a major investment of time and money in training our team on distinctly different systems, managing similar but separate environments, and responding to outages. Many of these outages have been a result of misconfigured systems, inadequate capacity to manage spikes in traffic, and inconsistent monitoring practices. We want to use Google Cloud to leverage a scalable, resilient platform that can span multiple environments seamlessly and provide a consistent and stable user experience that positions us for future growth."
  },
  {
    "id": 39,
    "topic": "Networking",
    "question": "For this question, refer to the EHR Healthcare case study.\nYou need to define the technical architecture for hybrid connectivity between EHR's on-premises systems and Google Cloud. You want to follow Google's recommended practices for production-level applications.\nConsidering the EHR Healthcare business and technical requirements, what should you do?",
    "options": {
      "A": "Configure two Partner Interconnect connections in one metro (City), and make sure the Interconnect connections are placed in different metro zones.",
      "B": "Configure two VPN connections from on-premises to Google Cloud, and make sure the VPN devices on-premises are in separate racks.",
      "C": "Configure Direct Peering between EHR Healthcare and Google Cloud, and make sure you are peering at least two Google locations.",
      "D": "Configure two Dedicated Interconnect connections in one metro (City) and two connections in another metro, and make sure the Interconnect connections are placed in different metro zones."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "For production-level applications requiring high availability (99.99% SLA target often desired, aligning with the 99.9% requirement), Google's recommended practice for hybrid connectivity is maximum redundancy. This involves using Dedicated Interconnect with connections in at least two different metros (cities), and within each metro, connections terminating in two different edge availability domains (metro zones). This configuration (D) provides resilience against link failure, zone failure, and even complete metro failure.",
    "conditions": [
      "Define hybrid connectivity architecture (on-prem to GCP)",
      "Follow Google recommended practices for production",
      "Requirements: High availability (99.9%), secure, high-performance"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>EHR Healthcare is a leading provider of electronic health record software to the medical industry. EHR Healthcare provides their software as a service to multi- national medical offices, hospitals, and insurance providers.\n<strong>Solution Concept </strong>: Due to rapid changes in the healthcare and insurance industry, EHR Healthcare's business has been growing exponentially year over year. They need to be able to scale their environment, adapt their disaster recovery plan, and roll out new continuous deployment capabilities to update their software at a fast pace. Google Cloud has been chosen to replace their current colocation facilities.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> EHR's software is currently hosted in multiple colocation facilities. The lease on one of the data centers is about to expire. Customer-facing applications are web-based, and many have recently been containerized to run on a group of Kubernetes clusters. Data is stored in a mixture of relational and NoSQL databases (MySQL, MS SQL Server, Redis, and MongoDB). EHR is hosting several legacy file- and API-based integrations with insurance providers on-premises. These systems are scheduled to be replaced over the next several years. There is no plan to upgrade or move these systems at the current time. Users are managed via Microsoft Active Directory. Monitoring is currently being done via various open source tools. Alerts are sent via email and are often ignored.\n<strong><strong>Business Requirements </strong>: </strong><br> On-board new insurance providers as quickly as possible. Provide a minimum 99.9% availability for all customer-facing systems. Provide centralized visibility and proactive action on system performance and usage. Increase ability to provide insights into healthcare trends. Reduce latency to all customers. Maintain regulatory compliance. Decrease infrastructure administration costs. Make predictions and generate reports on industry trends based on provider data.\n<strong>Technical requirements: </strong><br> Maintain legacy interfaces to insurance providers with connectivity to both on-premises systems and cloud providers. Provide a consistent way to manage customer-facing applications that are container-based. Provide a secure and high-performance connection between on-premises systems and Google Cloud. Provide consistent logging, log retention, monitoring, and alerting capabilities. Maintain and manage multiple container-based environments. Dynamically scale and provision new environments. Create interfaces to ingest and process data from new providers.\n<strong>Executive statement: </strong><br> Our on-premises strategy has worked for years but has required a major investment of time and money in training our team on distinctly different systems, managing similar but separate environments, and responding to outages. Many of these outages have been a result of misconfigured systems, inadequate capacity to manage spikes in traffic, and inconsistent monitoring practices. We want to use Google Cloud to leverage a scalable, resilient platform that can span multiple environments seamlessly and provide a consistent and stable user experience that positions us for future growth."
  },
  {
    "id": 40,
    "topic": "Storage",
    "question": "You want to store critical business information in Cloud Storage buckets. The information is regularly changed but previous versions need to be referenced on a regular basis. You want to ensure that there is a record of all changes to any information in these buckets. You want to ensure that accidental edits or deletions can be easily rolled back. Which feature should you enable?",
    "options": {
      "A": "Bucket Lock",
      "B": "Object Versioning",
      "C": "Object change notification",
      "D": "Object Lifecycle Management"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Object Versioning keeps historical versions of objects when they are overwritten or deleted. This provides a record of changes and allows easy rollback to previous states by restoring a noncurrent version, fulfilling the requirements. Bucket Lock prevents deletion/overwrites. Change Notification sends alerts on changes. Lifecycle Management automates actions based on object age/conditions.",
    "conditions": [
      "Store critical info in GCS",
      "Regularly changed, previous versions referenced",
      "Record of changes needed",
      "Easy rollback needed"
    ],
    "caseStudyContext": null
  },
  {
    "id": 41,
    "topic": "Compute",
    "question": "Your company has a Compute Engine managed instance group that adds and removes Compute Engine instances from the group in response to the load of your application. The instances have a shutdown script that removes REDIS database entries associated with the instance. You see that many database entries have not been removed, and you suspect that the shutdown script is the problem. You need to ensure that the commands in the shutdown script are run reliably every time an instance is shut down. You create a Cloud Function to remove the database entries. What should you do next?",
    "options": {
      "A": "Modify the shutdown script to wait for 30 seconds before triggering the Cloud Function.",
      "B": "Do not use the Cloud Function. Modify the shutdown script to restart if it has not completed in 30 seconds.",
      "C": "Set up a Cloud Monitoring sink that triggers the Cloud Function after an instance removal log message arrives in Cloud Logging.",
      "D": "Modify the shutdown script to wait for 30 seconds and then publish a message to a Pub/Sub queue."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Shutdown scripts can be unreliable, especially under forced termination (e.g., scaling down, preemption). A more robust approach is to react to the instance deletion event itself. Cloud Logging captures these events. Creating a log sink to filter for instance deletion logs and trigger the Cloud Function (possibly via Pub/Sub) ensures the cleanup logic runs reliably *after* the instance is confirmed to be shutting down, decoupled from the potentially interrupted shutdown script. Options A, B, D still rely on the unreliable shutdown script.",
    "conditions": [
      "Autoscaled MIG with shutdown script for Redis cleanup",
      "Shutdown script appears unreliable",
      "Need reliable cleanup execution",
      "Cloud Function created for cleanup task"
    ],
    "caseStudyContext": null
  },
  {
    "id": 42,
    "topic": "Compute",
    "question": "You are managing several projects on Google Cloud and need to interact on a daily basis with BigQuery, Bigtable, and Kubernetes Engine using the gcloud CLI tool. You are travelling a lot and work on different workstations during the week. You want to avoid having to manage the gcloud CLI manually. What should you do?",
    "options": {
      "A": "Use Google Cloud Shell in the Google Cloud Console to interact with Google Cloud.",
      "B": "Create a Compute Engine instance and install gcloud on the instance. Connect to this instance via SSH to always use the same gcloud installation when interacting with Google Cloud.",
      "C": "Install gcloud on all of your workstations. Run the command gcloud components auto-update on each workstation",
      "D": "Use a package manager to install gcloud on your workstations instead of installing it manually."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Cloud Shell provides a persistent, browser-based command line environment with `gcloud`, `kubectl`, `bq`, `cbt`, and other necessary tools pre-installed and automatically updated. It's accessible from any machine with a browser and uses your Cloud Console authentication, eliminating the need to install or manage `gcloud` on multiple workstations.",
    "conditions": [
      "Manage multiple GCP projects",
      "Daily interaction with BQ, BT, GKE via gcloud",
      "Use different workstations frequently",
      "Avoid manual gcloud CLI management"
    ],
    "caseStudyContext": null
  },
  {
    "id": 43,
    "topic": "Networking",
    "question": "Your company recently acquired a company that has infrastructure in Google Cloud. Each company has its own Google Cloud organization. Each company is using a Shared Virtual Private Cloud (VPC) to provide network connectivity tor its applications Some of the subnets used by both companies overlap In order for both businesses to integrate, the applications need to have private network connectivity. These applications are not on overlapping subnets. You want to provide connectivity with minimal re-engineering. What should you do?",
    "options": {
      "A": "Set up VPC peering and peer each Shared VPC together",
      "B": "Configure SSH port forwarding on each application to provide connectivity between applications i the different Shared VPCs",
      "C": "Migrate the protects from the acquired company into your company's Google Cloud organization Re launch the instances in your companies Shared VPC",
      "D": "Set up a Cloud VPN gateway in each Shared VPC and peer Cloud VPNs"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "VPC Peering requires non-overlapping subnets and cannot directly connect networks across different organizations. Migrating projects (C) is significant re-engineering. SSH forwarding (B) is not a scalable network solution. Cloud VPN (D) can connect VPCs across organizations and can handle overlapping subnets (although it requires careful routing configuration if overlaps affect communicating resources). Since the specific applications needing connectivity are *not* on overlapping subnets, setting up Cloud VPN tunnels between the two Shared VPCs provides the required private connectivity with minimal disruption compared to migration or peering limitations.",
    "conditions": [
      "Two companies, separate Orgs, separate Shared VPCs",
      "Some subnet overlaps exist between VPCs",
      "Need private connectivity between specific applications",
      "Applications needing connectivity are *not* on overlapping subnets",
      "Minimize re-engineering"
    ],
    "caseStudyContext": null
  },
  {
    "id": 44,
    "topic": "Operations",
    "question": "You are managing several internal applications that are deployed on Compute Engine. Business users inform you that an application has become very slow over the past few days. You want to find the underlying cause in order to solve the problem. What should you do first?",
    "options": {
      "A": "Inspect the logs and metrics from the instances in Cloud Logging and Cloud Monitoring.",
      "B": "Change the Compute Engine Instances behind the application to a machine type with more CPU and memory.",
      "C": "Restore a backup of the application database from a time before the application became slow.",
      "D": "Deploy the applications on a managed instance group with autoscaling enabled. Add a load balancer in front of the managed instance group, and have the users connect to the IP of the load balancer."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The first step in troubleshooting performance issues is to gather data. Examining application logs (for errors, slow operations) and system metrics (CPU, memory, I/O, network latency, request count) in Cloud Logging and Cloud Monitoring provides visibility into the application's behavior and potential bottlenecks. Actions like resizing instances (B), restoring backups (C), or re-architecting (D) should only be taken after diagnosing the root cause based on observed data.",
    "conditions": [
      "Internal applications on GCE",
      "One application became slow recently",
      "Need to find the cause"
    ],
    "caseStudyContext": null
  },
  {
    "id": 45,
    "topic": "Compute",
    "question": "Your company has an application running as a Deployment in a Google Kubernetes Engine (GKE) cluster. When releasing new versions of the application via a rolling deployment, the team has been causing outages. The root cause of the outages is misconfigurations with parameters that are only used in production. You want to put preventive measures for this in the platform to prevent outages. What should you do?",
    "options": {
      "A": "Configure liveness and readiness probes in the Pod specification.",
      "B": "Configure health checks on the managed instance group.",
      "C": "Create a Scheduled Task to check whether the application is available.",
      "D": "Configure an uptime alert in Cloud Monitoring."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Liveness and Readiness probes are Kubernetes mechanisms to check pod health. A Readiness probe determines if a pod is ready to serve traffic. During a rolling update, Kubernetes won't direct traffic to a new pod until its readiness probe passes. A Liveness probe determines if a pod is still functioning; if it fails, Kubernetes restarts the pod. Configuring effective probes (A) ensures that misconfigured pods that fail to start correctly (failing readiness probe) won't receive traffic during rollout, preventing outages. Health checks on MIGs (B) are irrelevant to GKE pods. Scheduled tasks (C) and uptime alerts (D) are external monitoring, not preventative measures within the deployment process.",
    "conditions": [
      "Application as Deployment on GKE",
      "Rolling deployments cause outages due to prod-only misconfigurations",
      "Need preventative measures"
    ],
    "caseStudyContext": null
  },
  {
    "id": 46,
    "topic": "Compute",
    "question": "Your company uses Google Kubernetes Engine (GKE) as a platform for all workloads. Your company has a single large GKE cluster that contains batch, stateful, and stateless workloads. The GKE cluster is configured with a single node pool with 200 nodes. Your company needs to reduce the cost of this cluster but does not want to compromise availability. What should you do?",
    "options": {
      "A": "Create a second GKE cluster for the batch workloads only. Allocate the 200 original nodes across both clusters.",
      "B": "Configure CPU and memory limits on the namespaces in the cluster. Configure all Pods to have a CPU and memory limits.",
      "C": "Configure a HorizontalPodAutoscaler for all stateless workloads and for all compatible stateful workloads. Configure the cluster to use node auto scaling.",
      "D": "Change the node pool to use preemptible VMs."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To reduce costs without compromising availability in a mixed-workload cluster, enabling autoscaling at both the pod and node level is key. Horizontal Pod Autoscaler (HPA) adjusts the number of pods for stateless/compatible stateful workloads based on metrics (CPU/memory/custom). Cluster Autoscaler (node auto scaling) adjusts the number of nodes in the pool based on pending pods. This combination (C) ensures resources match demand, scaling down during low load to save costs and scaling up during high load to maintain availability. Splitting clusters (A) doesn't guarantee savings. Limits (B) manage resources but don't scale down costs. Preemptible VMs (D) compromise availability.",
    "conditions": [
      "Single large GKE cluster (200 nodes)",
      "Mixed workloads (batch, stateful, stateless)",
      "Need cost reduction without compromising availability"
    ],
    "caseStudyContext": null
  },
  {
    "id": 47,
    "topic": "Data Analytics",
    "question": "Your company has a Google Cloud project that uses BigQuery for data warehousing on a pay-per-use basis. You want to monitor queries in real time to discover the most costly queries and which users spend the most. What should you do?",
    "options": {
      "A": "1. In the BigQuery dataset that contains all the tables to be queried, add a label for each user that can launch a query. 2. Open the Billing page of the project. 3. Select Reports. 4. Select BigQuery as the product and filter by the user you want to check.",
      "B": "1. Create a Cloud Logging sink to export BigQuery data access logs to BigQuery. 2. Perform a BigQuery query on the generated table to extract the information you need.",
      "C": "1. Create a Cloud Logging sink to export BigQuery data access logs to Cloud Storage. 2. Develop a Dataflow pipeline to compute the cost of queries split by users.",
      "D": "1. Activate billing export into BigQuery. 2. Perform a BigQuery query on the billing table to extract the information you need."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "BigQuery Audit Logs (specifically Data Access logs) contain detailed metadata about each query job, including the user who ran it (`protoPayload.authenticationInfo.principalEmail`), the bytes billed (`protoPayload.serviceData.jobCompletedEvent.job.jobStatistics.totalBilledBytes`), and the query text. Exporting these logs to BigQuery via a Cloud Logging sink allows near real-time querying of this metadata to identify high-cost queries and aggregate costs per user. Billing export (D) provides cost data but with more delay and less granular query detail. Billing reports (A) are even more aggregated/delayed. Using Cloud Storage/Dataflow (C) is overly complex.",
    "conditions": [
      "BigQuery DWH (pay-per-use)",
      "Monitor queries in real time",
      "Identify most costly queries",
      "Identify users spending the most"
    ],
    "caseStudyContext": null
  },
  {
    "id": 48,
    "topic": "Networking",
    "question": "Your company and one of its partners each have a Google Cloud project in separate organizations. Your company's project (prj-a) runs in Virtual Private Cloud (vpc-a). The partner's project (prj-b) runs in vpc-b. There are two instances running on vpc-a and one instance running on vpc-b. Subnets defined in both VPCs are not overlapping. You need to ensure that all instances communicate with each other via internal IPs, minimizing latency and maximizing throughput. What should you do?",
    "options": {
      "A": "Set up a network peering between vpc-a and vpc-b.",
      "B": "Set up a VPN between vpc-a and vpc-b using Cloud VPN.",
      "C": "Configure [AP TCP forwarding on the instance in vpc-b, and then launch the following gcloud command from one of the instances in vpc-a gcloud: gcloud compute start-iap-tunnel INSTANCE_NAME_IN_VPC_8 22 \\ --local-host-port=localhost:22",
      "D": "1. Create an additional instance in vpc-a. 2. Create an additional instance in vpc-b. 3. Install OpenVPN in newly created instances. 4. Configure a VPN tunnel between vpc-a and vpc-b with the help of OpenVPN."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "VPC Network Peering allows two VPC networks to connect privately using internal IP addresses, regardless of whether they belong to the same project or organization. Since the subnets do not overlap, peering is possible. Peering uses Google's internal network, providing lower latency and higher throughput compared to VPN options (B, D). IAP (C) is for secure access *to* instances, not general network connectivity *between* instances.",
    "conditions": [
      "Two projects in separate Orgs (prj-a/vpc-a, prj-b/vpc-b)",
      "Instances in both VPCs",
      "Subnets do not overlap",
      "Need communication via internal IPs",
      "Minimize latency, maximize throughput"
    ],
    "caseStudyContext": null
  },
  {
    "id": 49,
    "topic": "Compute",
    "question": "You have a Compute Engine application that you want to autoscale when total memory usage exceeds 80%. You have installed the Cloud Monitoring agent and configured the autoscaling policy as follows:\n\n* Metric identifier: agent.googleapis.com/memory/percent_used\n* Filter: metric.label.state = 'used'\n* Target utilization level: 80\n* Target type: GAUGE\n\nYou observe that the application does not scale under high load. You want to resolve this. What should you do?",
    "options": {
      "A": "Change the Target type to DELTA_PER_MINUTE.",
      "B": "Change the Metric identifier to agent.googleapis.com/memory/bytes_used.",
      "C": "Change the filter to metric.label.state = ‘used’ AND metric.label.state = ‘buffered’ AND metric.label.state = ‘cached’ AND metric.label.state ‘slab’.",
      "D": "Change the filter to metric.label.state = ‘free’ and the Target utilization to 20."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The `agent.googleapis.com/memory/percent_used` metric breaks down memory by state. On Linux, memory reported simply as 'used' doesn't account for memory used by buffers and cache, which is often reclaimable. To get an accurate measure of memory pressure for scaling decisions, you typically need to consider the non-free memory, which includes 'used', 'buffered', 'cached', and 'slab'. Option C correctly identifies the need to adjust the filter to include these relevant states (though the specific syntax might need refinement, e.g., summing these percentages or targeting free memory as in D). Relying only on `state='used'` underestimates memory pressure, preventing scaling. D achieves a similar outcome by targeting free memory.",
    "conditions": [
      "Autoscale GCE app when memory usage > 80%",
      "Monitoring agent installed",
      "Autoscaler configured with `percent_used` metric, filter `state='used'`, target 80%",
      "App fails to scale under high load"
    ],
    "caseStudyContext": null
  },
  {
    "id": 50,
    "topic": "Networking",
    "question": "You are deploying an application to Google Cloud. The application is part of a system. The application in Google Cloud must communicate over a private network with applications in a non-Google Cloud environment. The expected average throughput is 200 kbps. The business requires:\n\n* as Close to 100% system availability as possible\n* cost optimization\n\nYou need to design the connectivity between the locations to meet the Business Requirements. What should you provision?",
    "options": {
      "A": "An HA Cloud VPN gateway connected with two tunnels to an on-premises VPN gateway",
      "B": "Two Classic Cloud VPN gateways connected to two on-premises VPN gateways Configure each Classic Cloud VPN gateway to have two tunnels, each connected to different on-premises VPN gateways",
      "C": "Two HA Cloud VPN gateways connected to two on-premises VPN gateways Configure each HA Cloud VPN gateway to have two tunnels, each connected to different on-premises VPN gateways",
      "D": "A single Cloud VPN gateway connected to an on-premises VPN gateway"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The requirement is near 100% availability (best met by 99.99% SLA) and cost optimization with low throughput needs (200 kbps). HA VPN provides a 99.99% SLA using redundant tunnels and gateways on the GCP side. Connecting a single HA VPN gateway to the single non-GCP environment's gateway (A) provides the required availability SLA at a lower cost than deploying two HA VPN gateways (C). Classic VPN (B, D) only offers 99.9% SLA.",
    "conditions": [
      "GCP app needs private communication with non-GCP app",
      "Throughput: 200 kbps (low)",
      "Requirement: Near 100% availability",
      "Requirement: Cost optimization"
    ],
    "caseStudyContext": null
  },
  {
    "id": 51,
    "topic": "IAM & Security",
    "question": "Your company has a Google Workspace account and Google Cloud Organization. Some developers in the company have created Google Cloud projects outside of the Google Cloud Organization.\nYou want to create an Organization structure that allows developers to create projects, but prevents them from modifying production projects. You want to manage policies for all projects centrally and be able to set more restrictive policies for production projects.\nYou want to minimize disruption to users and developers when business needs change in the future. You want to follow Google-recommended practices. How should you design the Organization structure?",
    "options": {
      "A": "1, Create a second Google Workspace account and Organization. 2. Grant all developers the Project Creator IAM role on the new Organization. 3. Move the developer projects into the new Organization. 4. Set the policies for all projects on both Organizations. 5. Additionally, set the production policies on the original Organization.",
      "B": "1. Create a folder under the Organization resource named Production. 2. Grant all developers the Project Creator IAM role on the new Organization. 3. Move the developer projects into the new Organization. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the Production folder.",
      "C": "1. Create folders under the Organization resource named Development and Production. a. Grant all developers the Project Creator IAM role on the Development folder. 3. Move the developer projects into the Development folder. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the Production folder.",
      "D": "1. Designate the Organization for production projects only. 2. Ensure that developers do not have the Project Creator IAM role on the Organization. 3. Create development projects outside of the Organization using the developer Google Workspace accounts. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the individual production projects."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The recommended approach involves a single Organization. Use Folders to segregate environments (e.g., 'Development', 'Production'). Migrate existing projects into the appropriate folders. Grant developers the `roles/resourcemanager.projectCreator` role specifically on the 'Development' folder, limiting their creation scope. Apply baseline policies at the Organization level and stricter policies specifically on the 'Production' folder. This structure (C) facilitates central management, clear separation, least privilege, and aligns with Google best practices.",
    "conditions": [
      "Existing Google Workspace and Org",
      "Some developer projects outside Org",
      "Allow developers project creation, but prevent Prod modification",
      "Central policy management",
      "Restrictive policies for Prod",
      "Minimize future disruption",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 52,
    "topic": "DevOps",
    "question": "Your company is developing a web-based application. You need to make sure that production deployments are linked to source code commits and are fully auditable. What should you do?",
    "options": {
      "A": "Make sure a developer is tagging the code commit with the date and time of commit",
      "B": "Make sure a developer is adding a comment to the commit that links to the deployment.",
      "C": "Make the container tag match the source code commit hash.",
      "D": "Make sure the developer is tagging the commits with :latest"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Using the unique Git commit hash as the tag for the built container image creates an immutable link between the deployed artifact and the exact version of the source code it was built from. This ensures traceability and auditability. Relying on manual tagging (A) or comments (B) is error-prone. Using the `:latest` tag (D) is highly discouraged as it's mutable and obscures which commit is actually deployed.",
    "conditions": [
      "Web application development",
      "Link production deployments to source commits",
      "Ensure deployments are fully auditable"
    ],
    "caseStudyContext": null
  },
  {
    "id": 53,
    "topic": "IAM & Security",
    "question": "Your company has just recently activated Cloud Identity to manage users. The Google Cloud Organization has been configured as well. The security team needs to secure projects that will be part of the Organization. They want to prohibit IAM users outside the domain from gaining permissions from now on. What should they do?",
    "options": {
      "A": "Configure an organization policy to restrict identities by domain",
      "B": "Configure an organization policy to block creation of service accounts",
      "C": "Configure Cloud Scheduler o trigger a Cloud Function every hour that removes all users that don't belong to the Cloud identity domain from all projects.",
      "D": "Create a technical user (e g . crawler@yourdomain com), and give it the protect owner rote at root organization level Write a bash script that• Lists all me IAM rules of all projects within the organization• Deletes all users that do not belong to the company domainCreate a Compute Engine instance m a project within the Organization and configure gcloud to be executed with technical user credentials Configure a cron job that executes the bash script every hour."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The Organization Policy constraint `constraints/iam.allowedPolicyMemberDomains` allows you to specify which Google Workspace or Cloud Identity domain IDs are permitted in IAM policies within the organization (or folder/project). By setting this policy at the Organization level and specifying only the company's domain, you prevent any IAM permissions from being granted to users outside that domain, meeting the requirement proactively.",
    "conditions": [
      "Cloud Identity and Org configured",
      "Secure projects within Org",
      "Prohibit granting IAM permissions to users outside the company domain"
    ],
    "caseStudyContext": null
  },
  {
    "id": 54,
    "topic": "Compute",
    "question": "You are developing an application using different microservices that should remain internal to the cluster. You want to be able to configure each microservice with a specific number of replicas. You also want to be able to address a specific microservice from any other microservice in a uniform way, regardless of the number of replicas the microservice scales to. You need to implement this solution on Google Kubernetes Engine. What should you do?",
    "options": {
      "A": "Deploy each microservice as a Deployment. Expose the Deployment in the cluster using a Service, and use the Service DNS name to address it from other microservices within the cluster.",
      "B": "Deploy each microservice as a Deployment. Expose the Deployment in the cluster using an Ingress, and use the Ingress IP address to address the Deployment from other microservices within the cluster.",
      "C": "Deploy each microservice as a Pod. Expose the Pod in the cluster using a Service, and use the Service DNS name to address the microservice from other microservices within the cluster.",
      "D": "Deploy each microservice as a Pod. Expose the Pod in the cluster using an Ingress, and use the Ingress IP address name to address the Pod from other microservices within the cluster."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Kubernetes Deployments manage ReplicaSets, allowing configuration of replica counts and handling scaling/updates. A Kubernetes Service (type ClusterIP for internal communication) provides a stable internal DNS name and IP address that load balances requests across the pods managed by a Deployment. Microservices within the cluster can use this stable Service DNS name to communicate reliably, irrespective of pod scaling or replacements. Ingress (B, D) is for external access. Using bare Pods (C, D) lacks scaling and lifecycle management.",
    "conditions": [
      "Microservices application on GKE",
      "Services internal to cluster",
      "Configure replica count per microservice",
      "Uniform addressing between microservices regardless of scaling"
    ],
    "caseStudyContext": null
  },
  {
    "id": 55,
    "topic": "Databases",
    "question": "You have found an error in your App Engine application caused by missing Cloud Datastore indexes. You have created a YAML file with the required indexes and want to deploy these new indexes to Cloud Datastore. What should you do?",
    "options": {
      "A": "Point gcloud datastore create-indexes to your configuration file",
      "B": "Upload the configuration file to App Engine's default Cloud Storage bucket, and have App Engine detect the new indexes",
      "C": "In the GCP Console, use Datastore Admin to delete the current indexes and upload the new configuration file",
      "D": "Create an HTTP request to the built-in python module to send the index configuration file to your application"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The standard command-line method to deploy Datastore indexes defined in a configuration file (typically `index.yaml`) is `gcloud datastore indexes create PATH_TO_INDEX_FILE`. This command uploads the index definitions to Datastore and initiates the building process.",
    "conditions": [
      "App Engine app error due to missing Datastore indexes",
      "YAML file with required indexes created",
      "Need to deploy new indexes"
    ],
    "caseStudyContext": null
  },
  {
    "id": 56,
    "topic": "Networking",
    "question": "You are migrating your on-premises solution to Google Cloud in several phases. You will use Cloud VPN to maintain a connection between your on-premises systems and Google Cloud until the migration is completed. You want to make sure all your on-premise systems remain reachable during this period. How should you organize your networking in Google Cloud?",
    "options": {
      "A": "Use the same IP range on Google Cloud as you use on-premises",
      "B": "Use the same IP range on Google Cloud as you use on-premises for your primary IP range and use a secondary range that does not overlap with the range you use on-premises",
      "C": "Use an IP range on Google Cloud that does not overlap with the range you use on-premises",
      "D": "Use an IP range on Google Cloud that does not overlap with the range you use on-premises for your primary IP range and use a secondary range with the same IP range as you use on-premises"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To establish network connectivity (VPN or Interconnect) between two distinct networks (on-premises and GCP VPC), their IP address ranges *must not overlap*. Overlapping ranges create ambiguity and prevent proper routing between the networks. Therefore, the GCP VPC must be configured with IP ranges that are different from those used in the on-premises network.",
    "conditions": [
      "Phased migration from on-prem to GCP",
      "Using Cloud VPN during migration",
      "Ensure on-prem systems remain reachable"
    ],
    "caseStudyContext": null
  },
  {
    "id": 57,
    "topic": "IAM & Security",
    "question": "Google Cloud Platform resources are managed hierarchically using organization, folders, and projects. When Cloud Identity and Access Management (IAM) policies exist at these different levels, what is the effective policy at a particular node of the hierarchy?",
    "options": {
      "A": "The effective policy is determined only by the policy set at the node",
      "B": "The effective policy is the policy set at the node and restricted by the policies of its ancestors",
      "C": "The effective policy is the union of the policy set at the node and policies inherited from its ancestors",
      "D": "The effective policy is the intersection of the policy set at the node and policies inherited from its ancestors"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "GCP IAM policies follow an inheritance model. The effective policy for a resource is the *union* of the policy set directly on that resource and the policies inherited from its ancestors (project, folder(s), organization). This means permissions granted at a higher level automatically apply to resources lower in the hierarchy, unless specifically overridden by a DENY policy (which are less common than ALLOW policies). Option B incorrectly states restriction; inherited policies add permissions. Option D (intersection) would be overly restrictive.",
    "conditions": [
      "GCP Resource Hierarchy (Org, Folder, Project)",
      "IAM policies applied at different levels"
    ],
    "caseStudyContext": null
  },
  {
    "id": 58,
    "topic": "Data Analytics",
    "question": "Your company is using BigQuery as its enterprise data warehouse. Data is distributed over several Google Cloud projects. All queries on BigQuery need to be billed on a single project. You want to make sure that no query costs are incurred on the projects that contain the data. Users should be able to query the datasets, but not edit them.\nHow should you configure users’ access roles?",
    "options": {
      "A": "Add all users to a group. Grant the group the role of BigQuery user on the billing project and BigQuery dataViewer on the projects that contain the data.",
      "B": "Add all users to a group. Grant the group the roles of BigQuery dataViewer on the billing project and BigQuery user on the projects that contain the data.",
      "C": "Add all users to a group. Grant the group the roles of BigQuery jobUser on the billing project and BigQuery dataViewer on the projects that contain the data.",
      "D": "Add all users to a group. Grant the group the roles of BigQuery dataViewer on the billing project and BigQuery jobUser on the projects that contain the data."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To run queries billed to a central project, users need permission to create jobs in that project (provided by `roles/bigquery.jobUser` or `roles/bigquery.user`). To only read data from other projects without incurring query costs there, users need read access to the datasets in those projects (provided by `roles/bigquery.dataViewer`). Therefore, granting `jobUser` on the billing project and `dataViewer` on the data projects (C) achieves the desired separation of billing and read-only data access.",
    "conditions": [
      "BigQuery DWH across multiple projects",
      "Centralized billing on one 'billing project'",
      "No query costs on 'data projects'",
      "Users need query ability, not edit ability"
    ],
    "caseStudyContext": null
  },
  {
    "id": 59,
    "topic": "Storage",
    "question": "You have developed an application using Cloud ML Engine that recognizes famous paintings from uploaded images. You want to test the application and allow specific people to upload images for the next 24 hours. Not all users have a Google Account. How should you have users upload images?",
    "options": {
      "A": "Have users upload the images to Cloud Storage. Protect the bucket with a password that expires after 24 hours.",
      "B": "Have users upload the images to Cloud Storage using a signed URL that expires after 24 hours.",
      "C": "Create an App Engine web application where users can upload images. Configure App Engine to disable the application after 24 hours. Authenticate users via Cloud Identity.",
      "D": "Create an App Engine web application where users can upload images for the next 24 hours. Authenticate users via Cloud Identity."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Cloud Storage Signed URLs provide temporary, secure access for specific actions (like uploading) without requiring the user to have a Google Account. Generating signed URLs with a 24-hour expiration allows the designated testers to upload images directly to the bucket during the test window. Bucket passwords (A) don't exist. Building a web app (C, D) is unnecessary complexity, and Cloud Identity requires Google accounts.",
    "conditions": [
      "ML Engine application",
      "Allow specific testers to upload images",
      "Upload window: 24 hours",
      "Not all testers have Google Accounts"
    ],
    "caseStudyContext": null
  },
  {
    "id": 60,
    "topic": "IAM & Security",
    "question": "Your web application must comply with the requirements of the European Union’s General Data Protection Regulation (GDPR). You are responsible for the technical architecture of your web application. What should you do?",
    "options": {
      "A": "Ensure that your web application only uses native features and services of Google Cloud Platform, because Google already has various certifications and provides “pass-on” compliance when you use native features.",
      "B": "Enable the relevant GDPR compliance setting within the GCP Console for each of the services in use within your application.",
      "C": "Ensure that Cloud Security Scanner is part of your test planning strategy in order to pick up any compliance gaps.",
      "D": "Define a design for the security of data in your web application that meets GDPR requirements."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "GDPR compliance is a shared responsibility. While GCP provides compliant infrastructure and features, the application owner must design and implement their application's data handling processes (collection, storage, access, user rights management, security measures) in a way that meets GDPR requirements. Option D correctly identifies the need to design the application architecture with GDPR principles in mind. There is no automatic 'pass-on' compliance (A) or single GDPR setting (B). Security Scanner (C) helps find vulnerabilities but doesn't guarantee GDPR compliance.",
    "conditions": [
      "Web application must comply with GDPR",
      "Responsible for technical architecture"
    ],
    "caseStudyContext": null
  },
  {
    "id": 61,
    "topic": "Databases",
    "question": "You need to set up Microsoft SQL Server on GCP. Management requires that there's no downtime in case of a data center outage in any of the zones within a GCP region. What should you do?",
    "options": {
      "A": "Configure a Cloud SQL instance with high availability enabled.",
      "B": "Configure a Cloud Spanner instance with a regional instance configuration.",
      "C": "Set up SQL Server on Compute Engine, using Always On Availability Groups using Windows Failover Clustering. Place nodes in different subnets.",
      "D": "Set up SQL Server Always On Availability Groups using Windows Failover Clustering. Place nodes in different zones."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "To protect against a zonal outage for SQL Server within a region, you need a high availability setup spanning multiple zones. Option D describes the standard approach for SQL Server on Compute Engine: use SQL Server Always On Availability Groups built on Windows Server Failover Clustering, ensuring the cluster nodes are placed in *different zones* within the same region. Cloud SQL for SQL Server HA (A) also achieves this using managed replicas across zones but running on GCE provides more control. Spanner (B) is a different database. Placing nodes in different subnets within the same zone (C) doesn't protect against zone failure.",
    "conditions": [
      "Set up Microsoft SQL Server on GCP",
      "Requirement: No downtime for zonal outage within a region"
    ],
    "caseStudyContext": null
  },
  {
    "id": 62,
    "topic": "Compute",
    "question": "The development team has provided you with a Kubernetes Deployment file. You have no infrastructure yet and need to deploy the application. What should you do?",
    "options": {
      "A": "Use gcloud to create a Kubernetes cluster. Use Deployment Manager to create the deployment.",
      "B": "Use gcloud to create a Kubernetes cluster. Use kubectl to create the deployment.",
      "C": "Use kubectl to create a Kubernetes cluster. Use Deployment Manager to create the deployment.",
      "D": "Use kubectl to create a Kubernetes cluster. Use kubectl to create the deployment."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "The standard workflow involves two steps: 1. Provision the Kubernetes cluster infrastructure using `gcloud container clusters create`. 2. Apply the Kubernetes resource definitions (like the Deployment file) to the cluster using `kubectl apply -f <deployment-file.yaml>`. Option B follows this correct sequence. `kubectl` (C, D) cannot create GKE clusters. Deployment Manager (A, C) *can* create clusters and basic resources, but `kubectl` is the standard tool for applying Kubernetes manifests.",
    "conditions": [
      "Have Kubernetes Deployment file",
      "No existing infrastructure",
      "Need to deploy the application"
    ],
    "caseStudyContext": null
  },
  {
    "id": 63,
    "topic": "Migration",
    "question": "You need to evaluate your team readiness for a new GCP project. You must perform the evaluation and create a skills gap plan incorporates the business goal of cost optimization. Your team has deployed two GCP projects successfully to date. What should you do?",
    "options": {
      "A": "Allocate budget for team training. Set a deadline for the new GCP project.",
      "B": "Allocate budget for team training. Create a roadmap for your team to achieve Google Cloud certification based on job role.",
      "C": "Allocate budget to hire skilled external consultant Set a deadline for the new GCP project.",
      "D": "Allocate budget to hire skilled external consultant Create a roadmap for your team to achieve Google Cloud certification based on job role."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Evaluating readiness involves assessing current skills against project needs. Since the team has prior experience, a structured plan to upskill them is appropriate. Allocating budget for training and creating a certification roadmap (B) provides clear goals, addresses potential skill gaps (including cost optimization knowledge), and leverages internal talent. Simply setting a deadline (A) doesn't address skills. Hiring consultants (C, D) can fill immediate gaps but doesn't build long-term internal capability as effectively as training.",
    "conditions": [
      "Evaluate team readiness for new GCP project",
      "Create skills gap plan incorporating cost optimization",
      "Team has prior GCP experience"
    ],
    "caseStudyContext": null
  },
  {
    "id": 64,
    "topic": "Compute",
    "question": "You are designing an application for use only during business hours. For the minimum viable product release, you’d like to use a managed product that automatically “scales to zero” so you don’t incur costs when there is no activity.\nWhich primary compute resource should you choose?",
    "options": {
      "A": "Cloud Functions",
      "B": "Compute Engine",
      "C": "Google Kubernetes Engine",
      "D": "AppEngine flexible environment"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Cloud Functions and Cloud Run are serverless compute platforms that automatically scale down to zero instances when not receiving traffic, eliminating costs during idle periods (like outside business hours). This perfectly matches the 'scale to zero' requirement for cost saving. Compute Engine (B), GKE (C), and App Engine Flexible (D) generally require at least one instance running, incurring costs even when idle.",
    "conditions": [
      "Application used only during business hours",
      "MVP release",
      "Need managed product",
      "Requirement: Automatic scale to zero for cost saving"
    ],
    "caseStudyContext": null
  },
  {
    "id": 65,
    "topic": "Storage",
    "question": "You need to upload files from your on-premises environment to Cloud Storage. You want the files to be encrypted on Cloud Storage using customer-supplied encryption keys. What should you do?",
    "options": {
      "A": "Supply the encryption key in a .boto configuration file. Use gsutil to upload the files.",
      "B": "Supply the encryption key using gcloud config. Use gsutil to upload the files to that bucket.",
      "C": "Use gsutil to upload the files, and use the flag --encryption-key to supply the encryption key.",
      "D": "Use gsutil to create a bucket, and use the flag --encryption-key to supply the encryption key. Use gsutil to upload the files to that bucket."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To use Customer-Supplied Encryption Keys (CSEK) with `gsutil`, the base64-encoded AES-256 key must be specified in the `.boto` configuration file using the `encryption_key` setting under the `[GSUtil]` section. `gsutil` will then use this key automatically for encrypting uploads and decrypting downloads. Options B, C, and D describe incorrect methods for supplying the key to `gsutil`.",
    "conditions": [
      "Upload files from on-prem to Cloud Storage",
      "Encrypt using Customer-Supplied Encryption Keys (CSEK)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 66,
    "topic": "Operations",
    "question": "Your customer wants to capture multiple GBs of aggregate real-time key performance indicators (KPIs) from their game servers running on Google Cloud Platform and monitor the KPIs with low latency. How should they capture the KPIs?",
    "options": {
      "A": "Store time-series data from the game servers in Google Bigtable, and view it using Google Data Studio.",
      "B": "Output custom metrics to Stackdriver from the game servers, and create a Dashboard in Stackdriver Monitoring Console to view them.",
      "C": "Schedule BigQuery load jobs to ingest analytics files uploaded to Cloud Storage every ten minutes, and visualize the results in Google Data Studio.",
      "D": "Insert the KPIs into Cloud Datastore entities, and run ad hoc analysis and visualizations of them in Cloud Datalab."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Cloud Monitoring (formerly Stackdriver) is designed for ingesting and visualizing time-series metrics with low latency. Sending KPIs as custom metrics from the game servers allows for real-time dashboarding and alerting directly within the Monitoring console. Bigtable (A) can store time-series data but requires Data Studio for visualization. BigQuery (C) is batch-oriented, not real-time. Datastore/Datalab (D) are not optimized for low-latency monitoring dashboards.",
    "conditions": [
      "Capture aggregate real-time KPIs from game servers",
      "Volume: Multiple GBs",
      "Monitor KPIs with low latency"
    ],
    "caseStudyContext": null
  },
  {
    "id": 67,
    "topic": "Compute",
    "question": "You have a Python web application with many dependencies that requires 0.1 CPU cores and 128 MB of memory to operate in production. You want to monitor and maximize machine utilization. You also want to reliably deploy new versions of the application. Which set of steps should you take?",
    "options": {
      "A": "Perform the following: 1. Create a managed instance group with f1-micro type machines. 2. Use a startup script to clone the repository, check out the production branch, install the dependencies, and start the Python app. 3. Restart the instances to automatically deploy new production releases.",
      "B": "Perform the following: 1. Create a managed instance group with n1-standard-1 type machines. 2. Build a Compute Engine image from the production branch that contains all of the dependencies and automatically starts the Python app. 3. Rebuild the Compute Engine image, and update the instance template to deploy new production releases.",
      "C": "Perform the following: 1. Create a Google Kubernetes Engine (GKE) cluster with n1-standard-1 type machines. 2. Build a Docker image from the production branch with all of the dependencies, and tag it with the version number. 3. Create a Kubernetes Deployment with the imagePullPolicy set to 'IfNotPresent' in the staging namespace, and then promote it to the production namespace after testing.",
      "D": "Perform the following: 1. Create a GKE cluster with n1-standard-4 type machines. 2. Build a Docker image from the master branch with all of the dependencies, and tag it with ‘latest’. 3. Create a Kubernetes Deployment in the default namespace with the imagePullPolicy set to ‘Always’. Restart the pods to automatically deploy new production releases."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "GKE allows fine-grained resource requests (0.1 CPU, 128MB RAM) and efficiently packs multiple small containers onto larger nodes (like n1-standard-1), maximizing utilization. Building versioned Docker images and using Kubernetes Deployments enables reliable, automated rolling updates. Option C describes this standard GKE CI/CD flow (Build image -> Deploy to Staging -> Promote to Production). Option A uses slow startup scripts and tiny instances. Option B uses less efficient GCE MIGs for packing small workloads. Option D uses oversized nodes and bad practices ('latest' tag, manual pod restarts).",
    "conditions": [
      "Python web app with many dependencies",
      "Resource needs: 0.1 CPU, 128 MB RAM",
      "Maximize machine utilization",
      "Reliable deployment needed"
    ],
    "caseStudyContext": null
  },
  {
    "id": 68,
    "topic": "Identity",
    "question": "Your company wants to start using Google Cloud resources but wants to retain their on-premises Active Directory domain controller for identity management. What should you do?",
    "options": {
      "A": "Use the Admin Directory API to authenticate against the Active Directory domain controller.",
      "B": "Use Google Cloud Directory Sync to synchronize Active Directory usernames with cloud identities and configure SAML SSO.",
      "C": "Use Cloud Identity-Aware Proxy configured to use the on-premises Active Directory domain controller as an identity provider.",
      "D": "Use Compute Engine to create an Active Directory (AD) domain controller that is a replica of the on-premises AD domain controller using Google Cloud Directory Sync."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "The standard solution for integrating on-premises AD with GCP is federation using SAML 2.0 Single Sign-On (SSO) and provisioning identities using Google Cloud Directory Sync (GCDS). GCDS syncs users/groups from AD to Cloud Identity/Workspace. SAML allows users to authenticate against the on-premises AD (or ADFS), which then asserts their identity to GCP. This avoids storing passwords in the cloud and uses the existing AD as the source of truth for authentication. Option B combines both necessary components.",
    "conditions": [
      "Start using GCP resources",
      "Retain on-prem AD for identity management"
    ],
    "caseStudyContext": null
  },
  {
    "id": 69,
    "topic": "Operations",
    "question": "You are running a cluster on Kubernetes Engine (GKE) to serve a web application. Users are reporting that a specific part of the application is not responding anymore. You notice that all pods of your deployment keep restarting after 2 seconds. The application writes logs to standard output. You want to inspect the logs to find the cause of the issue. Which approach can you take?",
    "options": {
      "A": "Review the Stackdriver logs for each Compute Engine instance that is serving as a node in the cluster.",
      "B": "Review the Stackdriver logs for the specific GKE container that is serving the unresponsive part of the application.",
      "C": "Connect to the cluster using gcloud credentials and connect to a container in one of the pods to read the logs.",
      "D": "Review the Serial Port logs for each Compute Engine instance that is serving as a node in the cluster."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "When Cloud Operations for GKE is enabled, logs written to stdout/stderr by containers are automatically collected and sent to Cloud Logging, tagged with pod and container information. Since the pods are crash-looping quickly, using `kubectl logs` (implied by C) might miss the critical error messages from previous failed instances. Reviewing the container's logs in Cloud Logging (B) provides access to historical logs from all pod instances, making it the most reliable way to find the startup error causing the crash loop. Node logs (A) or serial logs (D) are less relevant for application-level errors.",
    "conditions": [
      "GKE application",
      "Part of app unresponsive",
      "Pods restarting every 2 seconds (crash loop)",
      "App logs to stdout",
      "Need to inspect logs for cause"
    ],
    "caseStudyContext": null
  },
  {
    "id": 70,
    "topic": "Databases",
    "question": "You are using a single Cloud SQL instance to serve your application from a specific zone. You want to introduce high availability. What should you do?",
    "options": {
      "A": "Create a read replica instance in a different region",
      "B": "Create a failover replica instance in a different region",
      "C": "Create a read replica instance in the same region, but in a different zone",
      "D": "Create a failover replica instance in the same region, but in a different zone"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Cloud SQL High Availability (HA) configuration provides redundancy against zonal failures. It involves creating a *failover replica* instance in a *different zone within the same region* as the primary instance. Data is synchronously replicated. If the primary's zone fails, Cloud SQL automatically fails over to the replica in the other zone. Read replicas (A, C) are for read scaling, not HA. Regional replicas (B) are for cross-region DR.",
    "conditions": [
      "Single Cloud SQL instance in one zone",
      "Need to introduce high availability"
    ],
    "caseStudyContext": null
  },
  {
    "id": 71,
    "topic": "Compute",
    "question": "Your company is running a stateless application on a Compute Engine instance. The application is used heavily during regular business hours and lightly outside of business hours. Users are reporting that the application is slow during peak hours. You need to optimize the application's performance, What should you do?",
    "options": {
      "A": "Create a snapshot of the existing disk. Create an instance template from the snapshot. Create an autoscaled managed instance group from the instance template.",
      "B": "Create a snapshot of the existing disk. Create a custom image from the snapshot. Create an autoscaled managed instance group from this custom image.",
      "C": "Create a custom image from the existing disk. Create an instance template from the custom image. Create an autoscaled managed instance group from the instance template.",
      "D": "Create an instance template from the existing disk. Create a custom image from the instance template. Create an autoscaled managed instance group from the custom image."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The application is stateless and experiences performance issues during peak hours, indicating a need for horizontal scaling. The correct sequence to set up an autoscaled Managed Instance Group (MIG) is: 1. Create a custom image from the existing instance's disk (captures the application). 2. Create an instance template based on this custom image. 3. Create an autoscaled MIG using the instance template. The autoscaler will then add/remove instances based on load, addressing the peak hour slowness. Option C follows this sequence. A/B/D have incorrect dependencies or order.",
    "conditions": [
      "Stateless application on single GCE instance",
      "Heavy use during business hours, light otherwise",
      "Slow performance during peak hours",
      "Need performance optimization"
    ],
    "caseStudyContext": null
  },
  {
    "id": 72,
    "topic": "Operations",
    "question": "You have deployed an application on Anthos clusters (formerly Anthos GKE). According to the SRE practices at your company you need to be alerted if the request latency is above a certain threshold for a specified amount of time. What should you do?",
    "options": {
      "A": "Enable the Cloud Trace API on your project and use Cloud Monitoring Alerts to send an alert based on the Cloud Trace metrics",
      "B": "Configure Anthos Config Management on your cluster and create a yaml file that defines the SLO and alerting policy you want to deploy in your cluster",
      "C": "Use Cloud Profiler to follow up the request latenc Create a custom metric in Cloud Monitoring based on the results of Cloud Profiler, and create an Alerting Policy in case this metric exceeds the threshold",
      "D": "Install Anthos Service Mesh on your cluste Use the Google Cloud Console to define a Service Level Objective (SLO)"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Anthos Service Mesh (based on Istio) provides rich telemetry, including latency metrics. Defining Service Level Objectives (SLOs) based on these metrics (like request latency) is a core SRE practice. Cloud Monitoring allows defining SLOs and then creating Alerting Policies that trigger when the SLO is breached (e.g., latency exceeds threshold for a specified duration). Option D describes this standard SRE approach using Anthos Service Mesh and Cloud Monitoring SLOs/Alerting. Trace (A) provides details but SLOs are better for alerting. Profiler (C) analyzes code performance. Config Management (B) deploys configs, not monitoring rules.",
    "conditions": [
      "Application on Anthos clusters",
      "SRE practice: Alert on sustained high request latency"
    ],
    "caseStudyContext": null
  },
  {
    "id": 73,
    "topic": "Databases",
    "question": "You are using Cloud SQL as the database backend for a large CRM deployment. You want to scale as usage increases and ensure that you don’t run out of storage, maintain 75% CPU usage cores, and keep replication lag below 60 seconds. What are the correct steps to meet your requirements?",
    "options": {
      "A": "1) Enable automatic storage increase for the instance. 2) Create a Stackdriver alert when CPU usage exceeds 75%, and change the instance type to reduce CPU usage. 3) Create a Stackdriver alert for replication lag, and shard the database to reduce replication time.",
      "B": "1) Enable automatic storage increase for the instance. 2) Change the instance type to a 32-core machine type to keep CPU usage below 75%. 3) Create a Stackdriver alert for replication lag, and shard the database to reduce replication time.",
      "C": "1) Create a Stackdriver alert when storage exceeds 75%, and increase the available storage on the instance to create more space. 2) Deploy memcached to reduce CPU load. 3) Change the instance type to a 32-core machine type to reduce replication lag.",
      "D": "1) Create a Stackdriver alert when storage exceeds 75%, and increase the available storage on the instance to create more space. 2) Deploy memcached to reduce CPU load. 3) Create a Stackdriver alert for replication lag, and change the instance type to a 32-core machine type to reduce replication lag."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "1. Storage: Enable automatic storage increase in Cloud SQL settings. 2. CPU: Create a Cloud Monitoring alert for CPU utilization > 75%. When alerted, manually (or via automation) resize the instance (change machine type) to handle the load. 3. Replication Lag: Create a Cloud Monitoring alert for replication lag > 60 seconds. When alerted, investigate the cause; sharding is a possible (though complex) remediation strategy to reduce load and lag. Option A combines these reactive monitoring and scaling steps. B preemptively scales CPU. C/D use manual storage alerts and incorrectly link memcached/instance type directly to lag reduction.",
    "conditions": [
      "Cloud SQL backend for large CRM",
      "Scale with usage",
      "Prevent running out of storage",
      "Maintain <= 75% CPU usage",
      "Keep replication lag <= 60 seconds"
    ],
    "caseStudyContext": null
  },
  {
    "id": 74,
    "topic": "Data Analytics",
    "question": "You are tasked with building an online analytical processing (OLAP) marketing analytics and reporting tool.\nThis requires a relational database that can operate on hundreds of terabytes of data. What is the Google recommended tool for such applications?",
    "options": {
      "A": "Cloud Spanner, because it is globally distributed",
      "B": "Cloud SQL, because it is a fully managed relational database",
      "C": "Cloud Firestore, because it offers real-time synchronization across devices",
      "D": "BigQuery, because it is designed for large-scale processing of tabular data"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "BigQuery is Google Cloud's fully managed, petabyte-scale data warehouse optimized for OLAP workloads like analytics and reporting on massive datasets (hundreds of TBs). It uses a SQL interface, meeting the 'relational' aspect in terms of query language, and scales seamlessly. Spanner (A) is relational but OLTP-focused. Cloud SQL (B) doesn't scale to hundreds of TBs. Firestore (C) is NoSQL.",
    "conditions": [
      "Build OLAP analytics/reporting tool",
      "Relational database capabilities (SQL interface)",
      "Operate on hundreds of TBs of data"
    ],
    "caseStudyContext": null
  },
  {
    "id": 75,
    "topic": "DevOps",
    "question": "You are building a continuous deployment pipeline for a project stored in a Git source repository and want to ensure that code changes can be verified deploying to production. What should you do?",
    "options": {
      "A": "Use Spinnaker to deploy builds to production using the red/black deployment strategy so that changes can easily be rolled back.",
      "B": "Use Spinnaker to deploy builds to production and run tests on production deployments.",
      "C": "Use Jenkins to build the staging branches and the master branc Build and deploy changes to production for 10% of users before doing a complete rollout.",
      "D": "Use Jenkins to monitor tags in the repositor Deploy staging tags to a staging environment for testing.After testing, tag the repository for production and deploy that to the production environment."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "This describes a common GitOps/CI/CD pattern for ensuring pre-production verification. Jenkins (or another CI tool) monitors the Git repository. Deployments to a staging environment are triggered by specific tags (e.g., `staging-v1.1`). After successful testing/verification in staging, a production tag (e.g., `prod-v1.1`) is applied. Jenkins detects this tag and deploys the verified version to production. This ensures code is vetted in a dedicated environment before release.",
    "conditions": [
      "CI/CD pipeline",
      "Source in Git repo",
      "Verify changes before production deployment"
    ],
    "caseStudyContext": null
  },
  {
    "id": 76,
    "topic": "IAM & Security",
    "question": "Your company pushes batches of sensitive transaction data from its application server VMs to Cloud Pub/Sub for processing and storage, What is the Google-recommended way for your application to authenticate to the required Google Cloud services?",
    "options": {
      "A": "Ensure that VM service accounts are granted the appropriate Cloud Pub/Sub IAM roles.",
      "B": "Ensure that VM service accounts do not have access to Cloud Pub/Sub, and use VM access scopes to grant the appropriate Cloud Pub/Sub IAM roles.",
      "C": "Generate an OAuth2 access token for accessing Cloud Pub/Sub, encrypt it, and store it in Cloud Storage for access from each VM.",
      "D": "Create a gateway to Cloud Pub/Sub using a Cloud Function, and grant the Cloud Function service account the appropriate Cloud Pub/Sub IAM roles."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The recommended method for GCE VMs to authenticate to other GCP services is via their attached service account. Grant the necessary IAM roles (e.g., `roles/pubsub.publisher`) to the VM's service account (A). The application running on the VM can then automatically obtain credentials from the metadata server without needing to manage service account keys. Access scopes (B) are legacy; IAM roles are preferred. Manual token/key management (C) is less secure. A gateway (D) adds unnecessary complexity.",
    "conditions": [
      "App server VMs push data to Pub/Sub",
      "Need recommended authentication method"
    ],
    "caseStudyContext": null
  },
  {
    "id": 77,
    "topic": "Databases",
    "question": "You have deployed an application to Kubernetes Engine, and are using the Cloud SQL proxy container to make the Cloud SQL database available to the services running on Kubernetes. You are notified that the application is reporting database connection issues. Your company policies require a post- mortem. What should you do?",
    "options": {
      "A": "Use gcloud sql instances restart.",
      "B": "Validate that the Service Account used by the Cloud SQL proxy container still has the Cloud Build Editor role.",
      "C": "In the GCP Console, navigate to Stackdriver Loggin Consult logs for Kubernetes Engine and Cloud SQL.",
      "D": "In the GCP Console, navigate to Cloud SQ Restore the latest backu Use kubect1 to restart all pods."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "A post-mortem requires understanding the root cause. Connection issues could originate from the application pods, the Cloud SQL proxy, the network, or the Cloud SQL instance itself. Cloud Logging aggregates logs from GKE (application pods, proxy container) and the Cloud SQL instance. Consulting these logs (C) is the essential first step to diagnose the connection problem. Restarting (A) or restoring (D) doesn't help diagnosis. Checking permissions (B) is one specific check, but logs provide broader context; also Cloud Build Editor role is incorrect (Cloud SQL Client is needed).",
    "conditions": [
      "GKE app using Cloud SQL Proxy",
      "App reporting DB connection issues",
      "Post-mortem required"
    ],
    "caseStudyContext": null
  },
  {
    "id": 78,
    "topic": "Data Analytics",
    "question": "Your applications will be writing their logs to BigQuery for analysis. Each application should have its own table. Any logs older than 45 days should be removed. You want to optimize storage and follow Google recommended practices. What should you do?",
    "options": {
      "A": "Configure the expiration time for your tables at 45 days",
      "B": "Make the tables time-partitioned, and configure the partition expiration at 45 days",
      "C": "Rely on BigQuery’s default behavior to prune application logs older than 45 days",
      "D": "Create a script that uses the BigQuery command line tool (bq) to remove records older than 45 days"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Using time-partitioned tables in BigQuery is the recommended practice for managing time-series data like logs. Setting a partition expiration of 45 days (B) automatically and efficiently deletes entire partitions older than that duration, optimizing storage costs and simplifying data retention management. Table expiration (A) deletes the whole table. BigQuery has no default pruning (C). Manual scripting (D) is less efficient and reliable than built-in partition expiration.",
    "conditions": [
      "Writing app logs to BigQuery (separate table per app)",
      "Remove logs older than 45 days",
      "Optimize storage, follow Google practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 79,
    "topic": "Compute",
    "question": "You want your Google Kubernetes Engine cluster to automatically add or remove nodes based on CPU load. What should you do?",
    "options": {
      "A": "Configure a HorizontalPodAutoscaler with a target CPU usage. Enable the Cluster Autoscaler from the GCP Console.",
      "B": "Configure a HorizontalPodAutoscaler with a target CPU usage. Enable autoscaling on the managed instance group for the cluster using the gcloud command.",
      "C": "Create a deployment and set the maxUnavailable and maxSurge properties. Enable the Cluster Autoscaler using the gcloud command.",
      "D": "Create a deployment and set the maxUnavailable and maxSurge properties. Enable autoscaling on the cluster managed instance group from the GCP Console."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Scaling nodes based on overall cluster load (driven by pod resource requests/usage) requires the GKE Cluster Autoscaler. Scaling the number of pods based on CPU load requires the Horizontal Pod Autoscaler (HPA). The Cluster Autoscaler adds nodes when pods (potentially scaled up by HPA due to high CPU) cannot be scheduled, and removes underutilized nodes. Therefore, you need both HPA configured for your deployments (targeting CPU) and the Cluster Autoscaler enabled for the cluster (A). B incorrectly targets the underlying MIG. C/D relate to deployment strategies, not load-based node scaling.",
    "conditions": [
      "GKE cluster",
      "Automatically add/remove *nodes* based on CPU load"
    ],
    "caseStudyContext": null
  },
  {
    "id": 80,
    "topic": "Networking",
    "question": "You need to develop procedures to verify resilience of disaster recovery for remote recovery using GCP. Your production environment is hosted on-premises. You need to establish a secure, redundant connection between your on premises network and the GCP network. What should you do?",
    "options": {
      "A": "Verify that Dedicated Interconnect can replicate files to GC Verify that direct peering can establish a secure connection between your networks if Dedicated Interconnect fails.",
      "B": "Verify that Dedicated Interconnect can replicate files to GC Verify that Cloud VPN can establish a secure connection between your networks if Dedicated Interconnect fails.",
      "C": "Verify that the Transfer Appliance can replicate files to GC Verify that direct peering can establish a secure connection between your networks if the Transfer Appliance fails.",
      "D": "Verify that the Transfer Appliance can replicate files to GC Verify that Cloud VPN can establish a secure connection between your networks if the Transfer Appliance fails."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "For secure, redundant connectivity supporting DR failover from on-premises to GCP, the common pattern is Dedicated Interconnect for primary, high-performance connectivity, backed up by Cloud VPN for redundancy. DR testing procedures should verify that data replication/failover works over the primary Interconnect link, and also verify that connectivity is maintained via the backup Cloud VPN link if the Interconnect fails (B). Direct Peering (A, C) doesn't provide encryption or private connectivity. Transfer Appliance (C, D) is for bulk data transfer, not ongoing connectivity.",
    "conditions": [
      "Verify DR resilience (on-prem to GCP)",
      "Production is on-premises",
      "Need secure, redundant connection"
    ],
    "caseStudyContext": null
  },
  {
    "id": 81,
    "topic": "Compute",
    "question": "Your company operates nationally and plans to use GCP for multiple batch workloads, including some that are not time-critical. You also need to use GCP services that are HIPAA-certified and manage service costs. How should you design to meet Google best practices?",
    "options": {
      "A": "Provision preemptible VMs to reduce cost. Discontinue use of all GCP services and APIs that are not HIPAA-compliant.",
      "B": "Provision preemptible VMs to reduce cost. Disable and then discontinue use of all GCP services and APIs that are not HIPAA-compliant.",
      "C": "Provision standard VMs in the same region to reduce cost. Discontinue use of all GCP services and APIs that are not HIPAA-compliant.",
      "D": "Provision standard VMs to the same region to reduce cost. Disable and then discontinue use of all GCP services and APIs that are not HIPAA-compliant."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "For non-time-critical, fault-tolerant batch workloads, Preemptible VMs offer significant cost savings. For HIPAA compliance, only use services covered by Google's BAA. Best practice involves not just avoiding non-compliant services, but actively disabling them using Organization Policies (e.g., `constraints/gcp.restrictNonBAAServices`) to prevent accidental usage. Option B combines cost saving with Preemptible VMs and proactive disabling of non-compliant services.",
    "conditions": [
      "Multiple batch workloads (some not time-critical)",
      "Need HIPAA compliance",
      "Manage service costs",
      "Follow Google best practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 82,
    "topic": "DevOps",
    "question": "Your customer wants to do resilience testing of their authentication layer. This consists of a regional managed instance group serving a public REST API that reads from and writes to a Cloud SQL instance. What should you do?",
    "options": {
      "A": "Engage with a security company to run web scrapers that look your for users’ authentication data om malicious websites and notify you if any is found.",
      "B": "Deploy intrusion detection software to your virtual machines to detect and log unauthorized access.",
      "C": "Schedule a disaster simulation exercise during which you can shut off all VMs in a zone to see how your application behaves.",
      "D": "Configure a read replica for your Cloud SQL instance in a different zone than the master, and then manually trigger a failover while monitoring KPIs for our REST API."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Resilience testing involves simulating failures. The authentication layer uses a regional MIG (implying multi-zone deployment) and Cloud SQL (potentially with HA). Shutting down VMs in one zone (C) simulates a zonal failure and tests whether the MIG automatically recovers/redirects traffic and if the application (including its connection to Cloud SQL) remains functional. This directly tests the resilience of the system to a common failure scenario. A/B are security testing. D tests DB failover specifically, not the full application layer's resilience to a zone outage.",
    "conditions": [
      "Resilience testing of authentication layer",
      "Architecture: Regional MIG (API) -> Cloud SQL"
    ],
    "caseStudyContext": null
  },
  {
    "id": 83,
    "topic": "Data Analytics",
    "question": "Your BigQuery project has several users. For audit purposes, you need to see how many queries each user ran in the last month. What should you do?",
    "options": {
      "A": "Connect Google Data Studio to BigQuery. Create a dimension for the users and a metric for the amount of queries per user.",
      "B": "In the BigQuery interface, execute a query on the JOBS table to get the required information.",
      "C": "Use 'bq show ' to list all jobs. Per job, use ‘bq ls’ to list job information and get the required information.",
      "D": "Use Cloud Audit Logging to view Cloud Audit Logs, and create a filter on the query operation to get the required information."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "BigQuery provides `INFORMATION_SCHEMA` views containing metadata about jobs. Querying `INFORMATION_SCHEMA.JOBS_BY_USER` or `JOBS_BY_PROJECT` allows you to filter by user (`user_email`) and time range (`creation_time`) to count the number of query jobs executed by each user within the last month. This is the most direct and standard way to retrieve this audit information via SQL.",
    "conditions": [
      "BigQuery project, multiple users",
      "Audit: Count queries per user in last month"
    ],
    "caseStudyContext": null
  },
  {
    "id": 84,
    "topic": "DevOps",
    "question": "You want to automate the creation of a managed instance group and a startup script to install the OS package dependencies. You want to minimize the startup time for VMs in the instance group. What should you do?",
    "options": {
      "A": "Use Terraform to create the managed instance group and a startup script to install the OS package dependencies.",
      "B": "Create a custom VM image with all OS package dependencies. Use Deployment Manager to create the managed instance group with the VM image.",
      "C": "Use Puppet to create the managed instance group and install the OS package dependencies.",
      "D": "Use Deployment Manager to create the managed instance group and Ansible to install the OS package dependencies."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "To minimize VM startup time, dependencies should be pre-installed rather than installed via startup scripts or configuration management tools after boot. Creating a custom VM image with all necessary OS packages and application code baked in ensures instances start quickly. Using an Infrastructure as Code tool like Deployment Manager (or Terraform) to define and create the MIG based on this custom image provides automation. Options A, C, D all involve installing dependencies at startup, increasing boot time.",
    "conditions": [
      "Automate MIG creation",
      "VMs have many OS package dependencies",
      "Minimize VM startup time"
    ],
    "caseStudyContext": null
  },
  {
    "id": 85,
    "topic": "IAM & Security",
    "question": "Your company captures all web traffic data in Google Analytics 360 and stores it in BigQuery. Each country has its own dataset. Each dataset has multiple tables. You want analysts from each country to be able to see and query only the data for their respective countries. How should you configure the access rights?",
    "options": {
      "A": "Create a group per country. Add analysts to their respective country-groups. Create a single group ‘all_analysts’, and add all country-groups as members. Grant the ‘all_analysis’ group the IAM role of BigQuery jobUser. Share the appropriate dataset with view access with each respective analyst country-group.",
      "B": "Create a group per country. Add analysts to their respective country-groups. Create a single group ‘all_analysts’, and add all country-groups as members. Grant the ‘all_analysis’ group the IAM role of BigQuery jobUser. Share the appropriate tables with view access with each respective analyst country-group.",
      "C": "Create a group per country. Add analysts to their respective country-groups. Create a single group ‘all_analysts', and add all country-groups as members. Grant the ‘all_analysis’ group the IAM role of BigQuery dataViewer. Share the appropriate dataset with view access with each respective analyst country- group.",
      "D": "Create a group per country. Add analysts to their respective country-groups. Create a single group ‘all_analysts', and add all country-groups as members. Grant the ‘all_analysis’ group the IAM role of BigQuery dataViewer. Share the appropriate table with view access with each respective analyst country-group."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "This requires separating the permission to run queries from the permission to access specific data. Granting `roles/bigquery.jobUser` at the project level (to a common group) allows users to execute query jobs. Then, using dataset-level access controls, share each country-specific dataset granting only 'Viewer' access to the corresponding country-specific group. This restricts data visibility while allowing query execution billed to the project.",
    "conditions": [
      "GA360 data in BQ, separated by country dataset",
      "Analysts view/query only their country's data"
    ],
    "caseStudyContext": null
  },
  {
    "id": 86,
    "topic": "Storage",
    "question": "You have been engaged by your client to lead the migration of their application infrastructure to GCP. One of their current problems is that the on-premises high performance SAN is requiring frequent and expensive upgrades to keep up with the variety of workloads that are identified as follows: 20TB of log archives retained for legal reasons; 500 GB of VM boot/data volumes and templates; 500 GB of image thumbnails; 200 GB customer session state data that allows customers to restart sessions even if off-line for several days.\nWhich of the following best reflects your recommendations for a cost-effective storage allocation?",
    "options": {
      "A": "Local SSD for customer session state dat Lifecycle-managed Cloud Storage for log archives, thumbnails, and VM boot/data volumes.",
      "B": "Memcache backed by Cloud Datastore for the customer session state dat Lifecycle-managed Cloud Storage for log archives, thumbnails and VM boot/data volumes.",
      "C": "Memcache backed by Cloud SQL for customer session state dat Assorted local SSD- backed instances for VM boot/data volume Cloud Storage for log archives and thumbnails.",
      "D": "Memcache backed by Persistent Disk SSD storage for customer session state dat Assorted local SSD-backed instances for VM boot/data volume Cloud Storage for log archives and thumbnails."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Mapping workloads: Log archives (20TB) & Thumbnails (500GB) -> Cloud Storage (cost-effective, use lifecycle for logs). VM boot/data (500GB) -> Persistent Disk (Standard/SSD). Persistent Session State (200GB, multi-day) -> Needs persistence; Memcache backed by Datastore (B) offers low latency cache with durable NoSQL backend suitable for session data. Local SSD (A, C, D) is ephemeral. Cloud SQL (C) is possible but Datastore often simpler for sessions. Using GCS for VM boot/data (A, B) is incorrect.",
    "conditions": [
      "Migrate various workloads from on-prem SAN",
      "Workloads: Log archives (20TB), VM boot/data (500GB), Thumbnails (500GB), Persistent session state (200GB, multi-day)",
      "Need cost-effective storage allocation"
    ],
    "caseStudyContext": null
  },
  {
    "id": 87,
    "topic": "Compute",
    "question": "Your web application uses Google Kubernetes Engine to manage several workloads. One workload requires a consistent set of hostnames even after pod scaling and relaunches.\nWhich feature of Kubernetes should you use to accomplish this?",
    "options": {
      "A": "StatefulSets",
      "B": "Role-based access control",
      "C": "Container environment variables",
      "D": "Persistent Volumes"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "StatefulSets are Kubernetes controllers specifically designed for stateful applications that require stable, unique network identifiers (like hostnames) and stable persistent storage. StatefulSet pods get predictable names (e.g., web-0, web-1) that persist across restarts and rescheduling, unlike pods managed by Deployments.",
    "conditions": [
      "GKE application",
      "Workload requires consistent hostnames across scaling/relaunches"
    ],
    "caseStudyContext": null
  },
  {
    "id": 88,
    "topic": "Networking",
    "question": "You are using Cloud CDN to deliver static HTTP(S) website content hosted on a Compute Engine instance group. You want to improve the cache hit ratio. What should you do?",
    "options": {
      "A": "Customize the cache keys to omit the protocol from the key.",
      "B": "Shorten the expiration time of the cached objects.",
      "C": "Make sure the HTTP(S) header “Cache-Region” points to the closest region of your users.",
      "D": "Replicate the static content in a Cloud Storage bucke Point CloudCDN toward a load balancer on that bucket."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "By default, Cloud CDN includes the request protocol (HTTP/HTTPS) in the cache key. If the same content is served over both protocols, this results in separate cache entries. Customizing the cache key to omit the protocol allows requests via HTTP and HTTPS for the same resource to share a single cache entry, improving the cache hit ratio.",
    "conditions": [
      "Using Cloud CDN with GCE MIG origin",
      "Serving static HTTP(S) content",
      "Want to improve cache hit ratio"
    ],
    "caseStudyContext": null
  },
  {
    "id": 89,
    "topic": "Operations",
    "question": "Your architecture calls for the centralized collection of all admin activity and VM system logs within your project. How should you collect these logs from both VMs and services?",
    "options": {
      "A": "All admin and VM system logs are automatically collected by Stackdriver.",
      "B": "Stackdriver automatically collects admin activity logs for most services. The Stackdriver Logging agent must be installed on each instance to collect system logs.",
      "C": "Launch a custom syslogd compute instance and configure your GCP project and VMs to forward all logs to it.",
      "D": "Install the Stackdriver Logging agent on a single compute instance and let it collect all audit and access logs for your environment."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Cloud Logging automatically collects Admin Activity audit logs from most GCP services. However, to collect logs generated *within* Compute Engine VMs (e.g., syslog, application logs), the Cloud Logging agent must be installed and configured on each VM instance. Option B accurately describes this distinction.",
    "conditions": [
      "Centralized collection of admin activity logs",
      "Centralized collection of VM system logs"
    ],
    "caseStudyContext": null
  },
  {
    "id": 90,
    "topic": "Compute",
    "question": "You have an App Engine application that needs to be updated. You want to test the update with production traffic before replacing the current application version. What should you do?",
    "options": {
      "A": "Deploy the update using the Instance Group Updater to create a partial rollout, which allows for canary testing.",
      "B": "Deploy the update as a new version in the App Engine application, and split traffic between the new and current versions.",
      "C": "Deploy the update in a new VPC, and use Google’s global HTTP load balancing to split traffic between the update and current applications.",
      "D": "Deploy the update as a new App Engine application, and use Google’s global HTTP load balancing to split traffic between the new and current applications."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "App Engine natively supports deploying code as different versions within the same application. It also provides built-in traffic splitting capabilities, allowing you to direct a percentage of live production traffic to the new version for canary testing or gradual rollout before making it the default version.",
    "conditions": [
      "App Engine application update",
      "Test update with production traffic before full rollout"
    ],
    "caseStudyContext": null
  },
  {
    "id": 91,
    "topic": "Networking",
    "question": "All Compute Engine instances in your VPC should be able to connect to an Active Directory server on specific ports. Any other traffic emerging from your instances is not allowed. You want to enforce this using VPC firewall rules. How should you configure the firewall rules?",
    "options": {
      "A": "Create an egress rule with priority 1000 to deny all traffic for all instances. Create another egress rule with priority 100 to allow the Active Directory traffic for all instances.",
      "B": "Create an egress rule with priority 100 to deny all traffic for all instances. Create another egress rule with priority 1000 to allow the Active Directory traffic for all instances.",
      "C": "Create an egress rule with priority 1000 to allow the Active Directory traffic. Rely on the implied deny egress rule with priority 100 to block all traffic for all instances.",
      "D": "Create an egress rule with priority 100 to allow the Active Directory traffic. Rely on the implied deny egress rule with priority 1000 to block all traffic for all instances."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "GCP firewall rules use priorities (lower number = higher priority). To implement a default-deny egress policy with specific exceptions: 1. Create a high-priority rule (e.g., priority 100) to *allow* the specific egress traffic needed (to AD server IPs/ports). 2. Create a lower-priority rule (e.g., priority 1000) to *deny* all other egress traffic (`0.0.0.0/0` on all protocols/ports). This deny rule must have a numerically lower priority than the implied allow-all egress rule (65535) to be effective. Option A implements this correctly.",
    "conditions": [
      "All GCE instances need egress to AD server (specific ports)",
      "Deny all other egress traffic",
      "Use VPC firewall rules"
    ],
    "caseStudyContext": null
  },
  {
    "id": 92,
    "topic": "AI & ML",
    "question": "Your customer runs a web service used by e-commerce sites to offer product recommendations to users. The company has begun experimenting with a machine learning model on Google Cloud Platform to improve the quality of results. What should the customer do to improve their model's results over time?",
    "options": {
      "A": "Export Cloud Machine Learning Engine performance metrics from Stackdriver to BigQuery, to be used to analyze the efficiency of the model",
      "B": "Build a roadmap to move the machine learning model training from Cloud GPUs to Cloud TPUs, which offer better results.",
      "C": "Monitor Compute Engine announcements for availability of newer CPU architectures, and deploy the model to them as soon as they are available for additional performance.",
      "D": "Save a history of recommendations and results of the recommendations in BigQuery, to be used as training data."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Improving ML models over time requires continuous learning from new data and feedback. Saving the recommendations made and their outcomes (e.g., clicks, purchases, user feedback) creates a valuable dataset. This historical data (D) can be used to retrain the model, allowing it to learn from past performance and adapt to changing user behavior and product catalogs, thus improving future recommendations. A focuses on operational efficiency. B/C focus on hardware, which affects speed but not inherently model quality.",
    "conditions": [
      "Product recommendation service using ML model on GCP",
      "Goal: Improve model results over time"
    ],
    "caseStudyContext": null
  },
  {
    "id": 93,
    "topic": "Compute",
    "question": "A development team at your company has created a dockerized HTTPS web application. You need to deploy the application on Google Kubernetes Engine (GKE) and make sure that the application scales automatically. How should you deploy to GKE?",
    "options": {
      "A": "Use the Horizontal Pod Autoscaler and enable cluster autoscaling. Use an Ingress resource to load-balance the HTTPS traffic.",
      "B": "Use the Horizontal Pod Autoscaler and enable cluster autoscaling on the Kubernetes cluster. Use a Service resource of type LoadBalancer to load-balance the HTTPS traffic.",
      "C": "Enable autoscaling on the Compute Engine instance group. Use an Ingress resource to load-balance the HTTPS traffic.",
      "D": "Enable autoscaling on the Compute Engine instance group. Use a Service resource of type LoadBalancer to load-balance the HTTPS traffic."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "For automatic scaling in GKE, you need both pod-level and node-level scaling. Horizontal Pod Autoscaler (HPA) scales the number of application pods based on metrics. Cluster Autoscaler scales the number of nodes in the cluster. For exposing an HTTPS application, a GKE Ingress resource configures an HTTP(S) Load Balancer (Layer 7), which is suitable for managing HTTPS traffic, TLS certificates, and routing. Option A correctly combines HPA, Cluster Autoscaler, and Ingress. Service type LoadBalancer (B, D) creates a Network Load Balancer (Layer 4). Managing the underlying MIG (C, D) directly bypasses Kubernetes scaling mechanisms.",
    "conditions": [
      "Deploy dockerized HTTPS web app on GKE",
      "Ensure automatic scaling"
    ],
    "caseStudyContext": null
  },
  {
    "id": 94,
    "topic": "Networking",
    "question": "You need to design a solution for global load balancing based on the URL path being requested. You need to ensure operations reliability and end-to-end in- transit encryption based on Google best practices. What should you do?",
    "options": {
      "A": "Create a cross-region load balancer with URL Maps.",
      "B": "Create an HTTPS load balancer with URL Maps.",
      "C": "Create appropriate instance groups and instances. Configure SSL proxy load balancing.",
      "D": "Create a global forwarding rule. Configure SSL proxy load balancing."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Google's External HTTP(S) Load Balancer is a global service that supports path-based routing using URL Maps. Configuring it for HTTPS (B) ensures client-to-load balancer encryption and allows for optional load balancer-to-backend encryption, providing end-to-end encryption capabilities. It's highly reliable and globally distributed. SSL Proxy Load Balancer (C, D) is for non-HTTP(S) TCP traffic with SSL offload, and doesn't support URL path routing. 'Cross-region load balancer' (A) isn't a specific product name; the HTTP(S) LB is inherently global.",
    "conditions": [
      "Global load balancing solution",
      "Route based on URL path",
      "Operational reliability",
      "End-to-end in-transit encryption",
      "Follow Google best practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 95,
    "topic": "Storage",
    "question": "You have an application that makes HTTP requests to Cloud Storage. Occasionally the requests fail with HTTP status codes of 5xx and 429. How should you handle these types of errors?",
    "options": {
      "A": "Use gRPC instead of HTTP for better performance.",
      "B": "Implement retry logic using a truncated exponential backoff strategy.",
      "C": "Make sure the Cloud Storage bucket is multi-regional for geo-redundancy.",
      "D": "Monitor https://status.cloud.google.com/feed.atom and only make requests if Cloud Storage is not reporting an incident."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "HTTP 5xx errors (server errors) and 429 errors (Too Many Requests/rate limiting) are often transient. The recommended practice for handling these when calling cloud APIs is to implement retries with exponential backoff. This involves waiting increasingly longer intervals between retries, adding jitter (randomness) to avoid synchronized retries, and usually capping the maximum delay (truncation). Option B describes this strategy.",
    "conditions": [
      "App makes HTTP requests to GCS",
      "Occasional 5xx and 429 errors"
    ],
    "caseStudyContext": null
  },
  {
    "id": 96,
    "topic": "DevOps",
    "question": "You need to develop procedures to test a disaster plan for a mission-critical application. You want to use Google-recommended practices and native capabilities within GCP. What should you do?",
    "options": {
      "A": "Use Deployment Manager to automate service provisioning. Use Activity Logs to monitor and debug your tests.",
      "B": "Use Deployment Manager to automate service provisioning. Use Stackdriver to monitor and debug your tests.",
      "C": "Use gcloud scripts to automate service provisioning. Use Activity Logs to monitor and debug your tests.",
      "D": "Use gcloud scripts to automate service provisioning. Use Stackdriver to monitor and debug your tests."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "For reliable and repeatable DR testing, automating infrastructure provisioning using an IaC tool like Cloud Deployment Manager (or Terraform) is recommended. To monitor the system's behavior during the test and debug any issues, the Cloud Operations suite (formerly Stackdriver) provides essential tools: Monitoring (metrics), Logging (events, errors), Trace (latency), and Debugger. Option B combines automated provisioning with comprehensive monitoring/debugging capabilities. Activity Logs (A, C) only show API calls, not system/application health.",
    "conditions": [
      "Develop DR test procedures",
      "Use Google recommended practices",
      "Use native GCP capabilities"
    ],
    "caseStudyContext": null
  },
  {
    "id": 97,
    "topic": "Storage",
    "question": "Your company creates rendering software which users can download from the company website. Your company has customers all over the world. You want to minimize latency for all your customers. You want to follow Google-recommended practices. How should you store the files?",
    "options": {
      "A": "Save the files in a Multi-Regional Cloud Storage bucket.",
      "B": "Save the files in a Regional Cloud Storage bucket, one bucket per zone of the region.",
      "C": "Save the files in multiple Regional Cloud Storage buckets, one bucket per zone per region.",
      "D": "Save the files in multiple Multi-Regional Cloud Storage buckets, one bucket per multi-region."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To minimize latency for global users downloading files, storing the files in a Multi-Regional Cloud Storage bucket combined with enabling Cloud CDN is the recommended practice. Multi-Regional buckets serve content from locations within a large geographic area (e.g., US, EU, Asia), providing lower latency within that area. Cloud CDN then caches the content at Google's edge locations worldwide, further reducing latency for all users. Using a single Multi-Regional bucket (A) simplifies management compared to multiple regional (C) or multi-regional (D) buckets.",
    "conditions": [
      "Store downloadable software files",
      "Global customer base",
      "Minimize latency for all customers",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 98,
    "topic": "Storage",
    "question": "Your company acquired a healthcare startup and must retain its customers’ medical information for up to 4 more years, depending on when it was created. Your corporate policy is to securely retain this data, and then delete it as soon as regulations allow. Which approach should you take?",
    "options": {
      "A": "Store the data in Google Drive and manually delete records as they expire.",
      "B": "Anonymize the data using the Cloud Data Loss Prevention API and store it indefinitely.",
      "C": "Store the data in Cloud Storage and use lifecycle management to delete files when they expire.",
      "D": "Store the data in Cloud Storage and run a nightly batch script that deletes all expired data."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Cloud Storage is suitable for archival. Object Lifecycle Management allows defining rules to automatically delete objects after a specified age or on a certain date. This automated deletion (C) ensures compliance with the retention policy (up to 4 years) and secure deletion afterwards, minimizing manual effort and risk compared to manual deletion (A) or scripting (D). Anonymization (B) changes the data and isn't appropriate for retaining original records for compliance.",
    "conditions": [
      "Retain medical information (up to 4 years)",
      "Secure retention",
      "Delete data after retention period"
    ],
    "caseStudyContext": null
  },
  {
    "id": 99,
    "topic": "Compute",
    "question": "You are deploying a PHP App Engine Standard service with Cloud SQL as the backend. You want to minimize the number of queries to the database. What should you do?",
    "options": {
      "A": "Set the memcache service level to dedicated. Create a key from the hash of the query, and return database values from memcache before issuing a query to Cloud SQL.",
      "B": "Set the memcache service level to dedicated. Create a cron task that runs every minute to populate the cache with keys containing query results.",
      "C": "Set the memcache service level to shared. Create a cron task that runs every minute to save all expected queries to a key called cached_queries.",
      "D": "Set the memcache service level to shared. Create a key called cached_queries, and return database values from the key before using a query to Cloud SQL."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To minimize database queries, caching frequently accessed data is essential. App Engine provides a managed Memcache service. The common caching pattern (cache-aside) involves: 1. Before querying the database, check if the result for that query (identified by a unique key, e.g., a hash of the query) exists in Memcache. 2. If found, return the cached result. 3. If not found, query the database, store the result in Memcache with the key, and then return the result. Option A describes this pattern using dedicated Memcache (which offers more predictable performance than shared).",
    "conditions": [
      "PHP App Engine Standard service",
      "Cloud SQL backend",
      "Minimize database queries"
    ],
    "caseStudyContext": null
  },
  {
    "id": 100,
    "topic": "DevOps",
    "question": "You need to ensure reliability for your application and operations by supporting reliable task a scheduling for compute on GCP. Leveraging Google best practices, what should you do?",
    "options": {
      "A": "Using the Cron service provided by App Engine, publishing messages directly to a message-processing utility service running on Compute Engine instances.",
      "B": "Using the Cron service provided by App Engine, publish messages to a Cloud Pub/Sub topic. Subscribe to that topic using a message-processing utility service running on Compute Engine instances.",
      "C": "Using the Cron service provided by Google Kubernetes Engine (GKE), publish messages directly to a message-processing utility service running on Compute Engine instances.",
      "D": "Using the Cron service provided by GKE, publish messages to a Cloud Pub/Sub topic. Subscribe to that topic using a message-processing utility service running on Compute Engine instances."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "For reliable, decoupled task scheduling, the recommended pattern uses a scheduler (like App Engine Cron or Cloud Scheduler) to trigger tasks by publishing messages to Cloud Pub/Sub. Worker services (on GCE, GKE, Cloud Functions, etc.) subscribe to the Pub/Sub topic and process messages asynchronously. This decouples the scheduler from the workers, provides durability and retries via Pub/Sub, and allows independent scaling. Option B implements this pattern using App Engine Cron (a reliable scheduler). Direct invocation (A, C) is less reliable. GKE uses CronJobs, not a distinct 'Cron service'.",
    "conditions": [
      "Reliable task scheduling for compute on GCP",
      "Leverage Google best practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 101,
    "topic": "Storage",
    "question": "Your company is building a new architecture to support its data-centric business focus. You are responsible for setting up the network. Your company’s mobile and web-facing applications will be deployed on-premises, and all data analysis will be conducted in GCP. The plan is to process and load 7 years of archived .csv files totaling 900 TB of data and then continue loading 10 TB of data daily. You currently have an existing 100-MB internet connection. What actions will meet your company’s needs?",
    "options": {
      "A": "Compress and upload both achieved files and files uploaded daily using the qsutil –m option.",
      "B": "Lease a Transfer Appliance, upload archived files to it, and send it, and send it to Google to transfer archived data to Cloud Storage. Establish a connection with Google using a Dedicated Interconnect or Direct Peering connection and use it to upload files daily.",
      "C": "Lease a Transfer Appliance, upload archived files to it, and send it, and send it to Google to transfer archived data to Cloud Storage. Establish one Cloud VPN Tunnel to VPC networks over the public internet, and compares and upload files daily using the gsutil –m option.",
      "D": "Lease a Transfer Appliance, upload archived files to it, and send it to Google to transfer archived data to Cloud Storage. Establish a Cloud VPN Tunnel to VPC networks over the public internet, and compress and upload files daily."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Initial Load (900 TB): Uploading 900 TB over a 100 Mbps connection is impractical (would take years). Transfer Appliance is designed for such large offline transfers. Ongoing Load (10 TB/day): A 100 Mbps connection is also insufficient for 10 TB daily (would take ~9 days per 10 TB). A high-bandwidth, reliable connection like Dedicated Interconnect or Direct Peering is necessary for these daily transfers. Option B correctly identifies Transfer Appliance for the initial load and Interconnect/Peering for the ongoing daily load.",
    "conditions": [
      "Apps on-prem, analysis on GCP",
      "Initial load: 900 TB archived CSVs",
      "Ongoing load: 10 TB CSVs daily",
      "Existing connection: 100 Mbps internet"
    ],
    "caseStudyContext": null
  },
  {
    "id": 102,
    "topic": "Data Processing",
    "question": "You are developing a globally scaled frontend for a legacy streaming backend data API. This API expects events in strict chronological order with no repeat data for proper processing. Which products should you deploy to ensure guaranteed-once FIFO (first-in, first-out) delivery of data?",
    "options": {
      "A": "Cloud Pub/Sub alone",
      "B": "Cloud Pub/Sub to Cloud Dataflow",
      "C": "Cloud Pub/Sub to Stackdriver",
      "D": "Cloud Pub/Sub to Cloud SQL"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Pub/Sub provides ordering *within a region* using ordering keys, but achieving strict global FIFO and exactly-once processing often requires more. Cloud Dataflow provides stateful processing, windowing, and exactly-once semantics. A Dataflow pipeline can receive messages from Pub/Sub (potentially from multiple regions), buffer and reorder them based on timestamps within defined windows, deduplicate, and ensure exactly-once delivery to the downstream legacy API, fulfilling the strict ordering and no-repeat requirements.",
    "conditions": [
      "Globally scaled frontend",
      "Legacy streaming backend API",
      "Requires strict chronological order (FIFO)",
      "Requires no repeat data (exactly-once)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 103,
    "topic": "Migration",
    "question": "Your company is planning to perform a lift and shift migration of their Linux RHEL 6.5+ virtual machines. The virtual machines are running in an on-premises VMware environment. You want to migrate them to Compute Engine following Google-recommended practices. What should you do?",
    "options": {
      "A": "1. Define a migration plan based on the list of the applications and their dependencies. 2. Migrate all virtual machines into Compute Engine individually with Migrate for Compute Engine.",
      "B": "1. Perform an assessment of virtual machines running in the current VMware environment. 2. Create images of all disks. Import disks on Compute Engine. 3. Create standard virtual machines where the boot disks are the ones you have imported.",
      "C": "1. Perform an assessment of virtual machines running in the current VMware environment. 2. Define a migration plan, prepare a Migrate for Compute Engine migration RunBook, and execute the migration.",
      "D": "1. Perform an assessment of virtual machines running in the current VMware environment. 2. Install a third-party agent on all selected virtual machines. 3. Migrate all virtual machines into Compute Engine."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The Google-recommended tool for migrating VMs from VMware to Compute Engine is Migrate for Compute Engine (now part of Google Cloud Migrate). The recommended process involves assessment (discovery, analysis), planning (grouping VMs into waves, creating Runbooks), deployment/migration (using Migrate for Compute Engine to move the waves), and optimization. Option C accurately reflects these phases using the recommended tool and methodology.",
    "conditions": [
      "Lift-and-shift migration of Linux RHEL 6.5+ VMs",
      "Source: On-prem VMware",
      "Target: Compute Engine",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 104,
    "topic": "Compute",
    "question": "You need to deploy an application on Google Cloud that must run on a Debian Linux environment. The application requires extensive configuration in order to operate correctly. You want to ensure that you can install Debian distribution updates with minimal manual intervention whenever they become available. What should you do?",
    "options": {
      "A": "Create a Compute Engine instance template using the most recent Debian image. Create an instance from this template, and install and configure the application as part of the startup script. Repeat this process whenever a new Google-managed Debian image becomes available.",
      "B": "Create a Debian-based Compute Engine instance, install and configure the application, and use OS patch management to install available updates.",
      "C": "Create an instance with the latest available Debian image. Connect to the instance via SSH, and install and configure the application on the instance. Repeat this process whenever a new Google-managed Debian image becomes available.",
      "D": "Create a Docker container with Debian as the base image. Install and configure the application as part of the Docker image creation process. Host the container on Google Kubernetes Engine and restart the container whenever a new update is available."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "OS Patch management is a Compute Engine feature designed to automate the application of OS updates (including Debian distribution updates) to VMs according to a defined schedule and policy. This allows updates to be installed with minimal manual intervention. Option B combines creating the initial instance with the required configuration and then leveraging OS Patch Management for ongoing updates.",
    "conditions": [
      "Deploy application on GCP",
      "Requires Debian Linux",
      "Requires extensive configuration",
      "Install Debian updates with minimal manual intervention"
    ],
    "caseStudyContext": null
  },
  {
    "id": 105,
    "topic": "Operations",
    "question": "You have an application that runs in Google Kubernetes Engine (GKE). Over the last 2 weeks, customers have reported that a specific part of the application returns errors very frequently. You currently have no logging or monitoring solution enabled on your GKE cluster. You want to diagnose the problem, but you have not been able to replicate the issue. You want to cause minimal disruption to the application. What should you do?",
    "options": {
      "A": "1. Update your GKE cluster to use Cloud Operations for GKE. 2. Use the GKE Monitoring dashboard to investigate logs from affected Pods",
      "B": "1. Create a new GKE cluster with Cloud Operations for GKE enabled. 2. Migrate the affected Pods to the new cluster, and redirect traffic for those Pods to the new cluster. 3. Use the GKE Monitoring dashboard to investigate logs from affected Pods.",
      "C": "1. Update your GKE cluster to use Cloud Operations for GKE, and deploy Prometheus. 2. Set an alert to trigger whenever the application returns an error.",
      "D": "1. Create a new GKE cluster with Cloud Operations for GKE enabled, and deploy Prometheus. 2. Migrate the affected Pods to the new cluster, and redirect traffic for those Pods to the new cluster. 3. Set an alert to trigger whenever the application returns an error."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The least disruptive way to gain observability is to enable Cloud Operations for GKE (integrated logging and monitoring) on the *existing* cluster. This can usually be done via a cluster update command (`gcloud container clusters update ... --enable-stackdriver-kubernetes` or similar flags based on version/channel). Once enabled, logs and metrics from the running pods will be collected, allowing investigation using Cloud Logging and Monitoring dashboards without migrating workloads or creating new clusters (B, D).",
    "conditions": [
      "Application on GKE",
      "Frequent errors recently",
      "No logging/monitoring currently enabled",
      "Diagnose problem",
      "Cannot replicate",
      "Minimal disruption"
    ],
    "caseStudyContext": null
  },
  {
    "id": 106,
    "topic": "Networking",
    "question": "You are deploying an application to Google Cloud. The application receives traffic via TCP and reads and writes data to the filesystem. The application does not support horizontal scaling. The application process requires full control over the data on the file system because concurrent access causes corruption. The business is willing to accept a downtime when an incident occurs, but the application must be available 24/7 to support their business operations. You need to design the architecture of this application on Google Cloud. What should you do?",
    "options": {
      "A": "Use a managed instance group with instances in multiple zones, use Cloud Filestore, and use an HTTP load balancer in front of the instances.",
      "B": "Use a managed instance group with instances in multiple zones, use Cloud Filestore, and use a network load balancer in front of the instances.",
      "C": "Use an unmanaged instance group with an active and standby instance in different zones, use a regional persistent disk, and use an HTTP load balancer in front of the instances.",
      "D": "Use an unmanaged instance group with an active and standby instance in different zones, use a regional persistent disk, and use a network load balancer in front of the instances."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "The application cannot scale horizontally and requires exclusive filesystem access, ruling out MIGs and shared filesystems like Filestore (A, B). An active/standby setup is needed for availability. Placing the active and standby instances in different zones provides resilience against zone failure. A Regional Persistent Disk ensures data is replicated synchronously across zones, allowing the standby instance to quickly attach the disk and take over after a failure. A Network Load Balancer (TCP) is suitable for distributing TCP traffic and can use health checks to fail over traffic from the active to the standby instance. Option D combines these elements for an active/standby setup with regional data persistence and TCP load balancing.",
    "conditions": [
      "Application receives TCP traffic",
      "Reads/writes to filesystem",
      "Does not support horizontal scaling",
      "Requires exclusive filesystem access (no concurrent access)",
      "Accepts downtime during incidents",
      "Must be available 24/7 (implies quick recovery)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 107,
    "topic": "Compute",
    "question": "Your company has an application deployed on Anthos clusters (formerly Anthos GKE) that is running multiple microservices. The cluster has both Anthos Service Mesh and Anthos Config Management configured. End users inform you that the application is responding very slowly. You want to identify the microservice that is causing the delay. What should you do?",
    "options": {
      "A": "Use the Service Mesh visualization in the Cloud Console to inspect the telemetry between the microservices.",
      "B": "Use Anthos Config Management to create a ClusterSelector selecting the relevant cluster. On the Google Cloud Console page for Google Kubernetes Engine, view the Workloads and filter on the cluster. Inspect the configurations of the filtered workloads.",
      "C": "Use Anthos Config Management to create a namespaceSelector selecting the relevant cluster namespace. On the Google Cloud Console page for Google Kubernetes Engine, visit the workloads and filter on the namespace. Inspect the configurations of the filtered workloads.",
      "D": "Reinstall istio using the default istio profile in order to collect request latency. Evaluate the telemetry between the microservices in the Cloud Console."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Anthos Service Mesh automatically collects telemetry (latency, traffic, error rates) for traffic between microservices in the mesh. The Google Cloud Console provides visualizations based on this data, including topology graphs showing dependencies and latency metrics for each service call. Inspecting these Service Mesh visualizations (A) is the most direct way to identify which microservice or specific call path is introducing high latency. Config Management (B, C) is for configuration, not performance monitoring. Reinstalling Istio (D) is unnecessary.",
    "conditions": [
      "App on Anthos clusters with multiple microservices",
      "Anthos Service Mesh & Config Management enabled",
      "Application is slow",
      "Need to identify microservice causing delay"
    ],
    "caseStudyContext": null
  }, {
    "id": 108,
    "topic": "Storage",
    "question": "You are working at a financial institution that stores mortgage loan approval documents on Cloud Storage. Any change to these approval documents must be uploaded as a separate approval file, so you want to ensure that these documents cannot be deleted or overwritten for the next 5 years. What should you do?",
    "options": {
      "A": "Create a retention policy on the bucket for the duration of 5 years. Create a lock on the retention policy.",
      "B": "Create the bucket with uniform bucket-level access, and grant a service account the role of Object Writer. Use the service account to upload new files.",
      "C": "Use a customer-managed key for the encryption of the bucket. Rotate the key after 5 years.",
      "D": "Create the bucket with fine-grained access control, and grant a service account the role of Object Writer. Use the service account to upload new files."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Cloud Storage Bucket Lock with a retention policy enforces Write-Once-Read-Many (WORM) compliance. Setting a retention policy for 5 years prevents objects from being deleted or overwritten during that period. Locking the policy makes it irreversible, ensuring the data cannot be modified or deleted even by privileged users, meeting the strict requirement. Access controls (B, D) or encryption keys (C) do not prevent deletion or overwriting by authorized entities.",
    "conditions": [
      "Store mortgage loan documents in Cloud Storage",
      "Original documents must be immutable (changes are new files)",
      "Documents cannot be deleted or overwritten for 5 years"
    ],
    "caseStudyContext": null
  },
  {
    "id": 109,
    "topic": "DevOps",
    "question": "Your team will start developing a new application using microservices architecture on Kubernetes Engine. As part of the development lifecycle, any code change that has been pushed to the remote develop branch on your GitHub repository should be built and tested automatically. When the build and test are successful, the relevant microservice will be deployed automatically in the development environment. You want to ensure that all code deployed in the development environment follows this process. What should you do?",
    "options": {
      "A": "Have each developer install a pre-commit hook on their workstation that tests the code and builds the container when committing on the development branch. After a successful commit, have the developer deploy the newly built container image on the development cluster.",
      "B": "Install a post-commit hook on the remote git repository that tests the code and builds the container when code is pushed to the development branch. After a successful commit, have the developer deploy the newly built container image on the development cluster.",
      "C": "Create a Cloud Build trigger based on the development branch that tests the code, builds the container, and stores it in Container Registry. Create a deployment pipeline that watches for new images and deploys the new image on the development cluster. Ensure only the deployment tool has access to deploy new versions.",
      "D": "Create a Cloud Build trigger based on the development branch to build a new container image and store it in Container Registry. Rely on Vulnerability Scanning to ensure the code tests succeed. As the final step of the Cloud Build process, deploy the new container image on the development cluster. Ensure only Cloud Build has access to deploy new versions."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "This describes a standard CI/CD workflow using managed GCP services. A Cloud Build trigger automatically starts a build on push to the 'develop' branch. The build process tests the code, builds the container image, and pushes it to Artifact Registry (formerly Container Registry). A separate deployment pipeline tool (like Cloud Deploy, Spinnaker, or even a subsequent Cloud Build step) detects the new image and deploys it to the GKE development cluster. Restricting deployment permissions ensures only the automated pipeline can deploy, enforcing the process.",
    "conditions": [
      "New microservices app on GKE",
      "CI/CD process needed",
      "Trigger on push to 'develop' branch (GitHub)",
      "Automatic build, test, and deploy to Dev environment",
      "Enforce adherence to this process"
    ],
    "caseStudyContext": null
  },
  {
    "id": 110,
    "topic": "Operations",
    "question": "Your operations team has asked you to help diagnose a performance issue in a production application that runs on Compute Engine. The application is dropping requests that reach it when under heavy load. The process list for affected instances shows a single application process that is consuming all available CPU, and autoscaling has reached the upper limit of instances. There is no abnormal load on any other related systems, including the database. You want to allow production traffic to be served again as quickly as possible. Which action should you recommend?",
    "options": {
      "A": "Change the autoscaling metric to agent.googleapis.com/memory/percent_used.",
      "B": "Restart the affected instances on a staggered schedule.",
      "C": "SSH to each instance and restart the application process.",
      "D": "Increase the maximum number of instances in the autoscaling group."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "The symptoms point to insufficient capacity: high CPU on all instances and the autoscaler hitting its maximum limit while requests are being dropped. The quickest way to alleviate the immediate problem and restore service is to increase the maximum number of instances the autoscaler is allowed to create (D). This allows the group to scale out further, distributing the load across more instances. Changing metrics (A) or restarting instances/processes (B, C) won't solve the fundamental capacity shortage under sustained high load.",
    "conditions": [
      "Production app on GCE",
      "Dropping requests under heavy load",
      "High CPU usage on instances",
      "Autoscaler at maximum instance limit",
      "No issues on related systems (DB)",
      "Need quickest way to restore service"
    ],
    "caseStudyContext": null
  },
  {
    "id": 111,
    "topic": "Compute",
    "question": "You are implementing the infrastructure for a web service on Google Cloud. The web service needs to receive and store the data from 500,000 requests per second. The data will be queried later in real time, based on exact matches of a known set of attributes. There will be periods when the web service will not receive any requests. The business wants to keep costs low. Which web service platform and database should you use for the application?",
    "options": {
      "A": "Cloud Run and BigQuery",
      "B": "Cloud Run and Cloud Bigtable",
      "C": "A Compute Engine autoscaling managed instance group and BigQuery",
      "D": "A Compute Engine autoscaling managed instance group and Cloud Bigtable"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Web Platform: Cloud Run scales automatically, including down to zero, which is cost-effective for periods with no requests. Database: Cloud Bigtable is designed for very high ingestion rates (500k req/sec is feasible) and low-latency key-based lookups (matching the 'exact matches' query requirement). BigQuery (A, C) is not suitable for high-frequency writes or low-latency point lookups. Compute Engine MIGs (C, D) do not scale to zero automatically, incurring costs during idle periods.",
    "conditions": [
      "Web service infrastructure",
      "Ingestion rate: 500,000 requests/sec",
      "Query pattern: Real-time, exact attribute matches",
      "Idle periods with no requests",
      "Keep costs low"
    ],
    "caseStudyContext": null
  },
  {
    "id": 112,
    "topic": "Compute",
    "question": "You are developing an application using different microservices that should remain internal to the cluster. You want to be able to configure each microservice with a specific number of replicas. You also want to be able to address a specific microservice from any other microservice in a uniform way, regardless of the number of replicas the microservice scales to. You need to implement this solution on Google Kubernetes Engine. What should you do?",
    "options": {
      "A": "Deploy each microservice as a Deployment. Expose the Deployment in the cluster using a Service, and use the Service DNS name to address it from other microservices within the cluster.",
      "B": "Deploy each microservice as a Deployment. Expose the Deployment in the cluster using an Ingress, and use the Ingress IP address to address the Deployment from other microservices within the cluster.",
      "C": "Deploy each microservice as a Pod. Expose the Pod in the cluster using a Service, and use the Service DNS name to address the microservice from other microservices within the cluster.",
      "D": "Deploy each microservice as a Pod. Expose the Pod in the cluster using an Ingress, and use the Ingress IP address name to address the Pod from other microservices within the cluster."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Kubernetes Deployments are used to manage stateless applications, allowing configuration of replica counts and handling updates/scaling. To provide stable, internal access to the pods managed by a Deployment, a Kubernetes Service (typically type ClusterIP for internal access) is used. The Service gets a stable DNS name within the cluster that resolves to a virtual IP, load balancing requests across the healthy pods of the Deployment. Other microservices use this Service DNS name for reliable communication.",
    "conditions": [
      "Microservices application on GKE",
      "Services internal to the cluster",
      "Configure specific replica count per service",
      "Uniform addressing between services regardless of scaling"
    ],
    "caseStudyContext": null
  },
  {
    "id": 113,
    "topic": "IAM & Security",
    "question": "Your company has a networking team and a development team. The development team runs applications on Compute Engine instances that contain sensitive data. The development team requires administrative permissions for Compute Engine. Your company requires all network resources to be managed by the networking team. The development team does not want the networking team to have access to the sensitive data on the instances. What should you do?",
    "options": {
      "A": "1, Create a project with a standalone VPC and assign the Network Admin role to the networking team. 2. Create a second project with a standalone VPC and assign the Compute Admin role to the development team. 3. Use Cloud VPN to join the two VPCs.",
      "B": "1. Create a project with a standalone Virtual Private Cloud (VPC), assign the Network Admin role to the networking team, and assign the Compute Admin role to the development team.",
      "C": "1. Create a project with a Shared VPC and assign the Network Admin role to the networking team. 2. Create a second project without a VPC configure it as a Shared VPC service project, and assign the Compute Admin role to the development team.",
      "D": "1. Create a project with a standalone VPC and assign the Network Admin role to the networking team. 2. Create a second project with a standalone VPC and assign the Compute Admin role to the development team. 3. Use VPC Peering to join the two VPCs."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Shared VPC allows central management of network resources (subnets, firewalls, routes) in a 'host project' by the networking team, while application resources (like Compute Engine instances) reside in separate 'service projects' managed by development teams. Developers in service projects get permissions to use the shared network but not modify it. Networking admins manage the host project network but don't automatically get access to instances in service projects. This achieves the required separation of duties and least privilege.",
    "conditions": [
      "Separate networking and development teams",
      "Dev team needs Compute Admin on instances with sensitive data",
      "Network team manages all network resources",
      "Dev team should not manage network",
      "Network team should not access instance data"
    ],
    "caseStudyContext": null
  },
  {
    "id": 114,
    "topic": "Compute",
    "question": "Your company wants you to build a highly reliable web application with a few public APIs as the backend. You don't expect a lot of user traffic, but traffic could spike occasionally. You want to leverage Cloud Load Balancing, and the solution must be cost-effective for users. What should you do?",
    "options": {
      "A": "Store static content such as HTML and images in Cloud CDN. Host the APIs on App Engine and store the user data in Cloud SQL.",
      "B": "Store static content such as HTML and images in a Cloud Storage bucket. Host the APIs on a zonal Google Kubernetes Engine cluster with worker nodes in multiple zones, and save the user data in Cloud Spanner.",
      "C": "Store static content such as HTML and images in Cloud CDN. Use Cloud Run to host the APIs and save the user data in Cloud SQL.",
      "D": "Store static content such as HTML and images in a Cloud Storage bucket. Use Cloud Functions to host the APIs and save the user data in Firestore."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "For low, spiky traffic and cost-effectiveness, serverless options are ideal. Cloud Functions are well-suited for hosting a few simple APIs, scale to zero (cost-effective), and handle spikes. Firestore is a scalable, serverless NoSQL database suitable for user data. Static content is best served from Cloud Storage (potentially with CDN). A Global HTTP(S) Load Balancer can front both Cloud Storage (via backend bucket) and Cloud Functions (via serverless NEG). Cloud Run (C) is also serverless but might be slightly more than needed for 'a few APIs'. App Engine (A) and GKE (B) are less cost-effective at very low traffic levels.",
    "conditions": [
      "Highly reliable web application",
      "Backend: Few public APIs",
      "Traffic: Low expected, occasional spikes",
      "Leverage Cloud Load Balancing",
      "Cost-effective"
    ],
    "caseStudyContext": null
  },
  {
    "id": 115,
    "topic": "Operations",
    "question": "Your company sends all Google Cloud logs to Cloud Logging. Your security team wants to monitor the logs. You want to ensure that the security team can react quickly if an anomaly such as an unwanted firewall change or server breach is detected. You want to follow Google-recommended practices. What should you do?",
    "options": {
      "A": "Schedule a cron job with Cloud Scheduler. The scheduled job queries the logs every minute for the relevant events.",
      "B": "Export logs to BigQuery, and trigger a query in BigQuery to process the log data for the relevant events.",
      "C": "Export logs to a Pub/Sub topic, and trigger Cloud Function with the relevant log events.",
      "D": "Export logs to a Cloud Storage bucket, and trigger Cloud Run with the relevant log events."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "For near real-time alerting and response to specific log events, the recommended pattern is to create a Cloud Logging sink. Configure the sink to filter for the relevant security events (e.g., firewall modifications, specific audit log entries) and export matching logs to a Pub/Sub topic. A Cloud Function (or Cloud Run service) can then be triggered by messages arriving on this topic, allowing immediate automated analysis, notification (to the security team), or remediation actions.",
    "conditions": [
      "All GCP logs in Cloud Logging",
      "Security team needs monitoring",
      "Need quick reaction to security anomalies (e.g., firewall changes, breaches)",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 116,
    "topic": "Networking",
    "question": "You have deployed several instances on Compute Engine. As a security requirement, instances cannot have a public IP address. There is no VPN connection between Google Cloud and your office, and you need to connect via SSH into a specific machine without violating the security requirements. What should you do?",
    "options": {
      "A": "Configure Cloud NAT on the subnet where the instance is hosted. Create an SSH connection to the Cloud NAT IP address to reach the instance.",
      "B": "Add all instances to an unmanaged instance group. Configure TCP Proxy Load Balancing with the instance group as a backend. Connect to the instance using the TCP Proxy IP.",
      "C": "Configure Identity-Aware Proxy (IAP) for the instance and ensure that you have the role of IAP-secured Tunnel User. Use the gcloud command line tool to ssh into the instance.",
      "D": "Create a bastion host in the network to SSH into the bastion host from your office location. From the bastion host, SSH into the desired instance."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Identity-Aware Proxy (IAP) TCP forwarding provides a secure way to connect to Compute Engine instances that have no public IP addresses, without requiring a VPN or bastion host. By enabling IAP for SSH on the instances and granting the user the `roles/iap.tunnelResourceAccessor` role, the user can use `gcloud compute ssh --tunnel-through-iap INSTANCE_NAME` to establish a secure, authenticated, and authorized connection.",
    "conditions": [
      "GCE instances have no public IPs",
      "No VPN from office",
      "Need SSH access to specific instance",
      "Maintain security requirements"
    ],
    "caseStudyContext": null
  },
  {
    "id": 117,
    "topic": "IAM & Security",
    "question": "Your company is using Google Cloud. You have two folders under the Organization: Finance and Shopping. The members of the development team are in a Google Group. The development team group has been assigned the Project Owner role on the Organization. You want to prevent the development team from creating resources in projects in the Finance folder. What should you do?",
    "options": {
      "A": "Assign the development team group the Project Viewer role on the Finance folder, and assign the development team group the Project Owner role on the Shopping folder.",
      "B": "Assign the development team group only the Project Viewer role on the Finance folder.",
      "C": "Assign the development team group the Project Owner role on the Shopping folder, and remove the development team group Project Owner role from the Organization.",
      "D": "Assign the development team group only the Project Owner role on the Shopping folder."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Granting Project Owner at the Organization level gives ownership over *all* folders and projects underneath it. To restrict access to the Finance folder, this broad Org-level Owner role must be removed from the development group. Then, grant the necessary permissions (like Project Owner) specifically on the folders/projects where they *are* needed (e.g., the Shopping folder). Simply adding a restrictive role at the Finance folder (A, B) won't override the inherited Owner role.",
    "conditions": [
      "Org with folders: Finance, Shopping",
      "Dev team group has Org Owner role",
      "Prevent Dev team access/creation in Finance folder projects"
    ],
    "caseStudyContext": null
  },
  {
    "id": 118,
    "topic": "DevOps",
    "question": "You are developing your microservices application on Google Kubernetes Engine. During testing, you want to validate the behavior of your application in case a specific microservice should suddenly crash. What should you do?",
    "options": {
      "A": "Add a taint to one of the nodes of the Kubernetes cluster. For the specific microservice, configure a pod anti-affinity label that has the name of the tainted node as a value.",
      "B": "Use Istio's fault injection on the particular microservice whose faulty behavior you want to simulate.",
      "C": "Destroy one of the nodes of the Kubernetes cluster to observe the behavior.",
      "D": "Configure Istio's traffic management features to steer the traffic away from a crashing microservice."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Istio (or Anthos Service Mesh) provides fault injection capabilities that allow you to simulate failures like service crashes (e.g., by returning HTTP 5xx errors) or delays for specific microservices without actually terminating pods or nodes. This enables controlled testing of how the application handles dependency failures.",
    "conditions": [
      "Microservices app on GKE",
      "Testing phase",
      "Validate behavior when a specific microservice crashes"
    ],
    "caseStudyContext": null
  },
  {
    "id": 119,
    "topic": "Compute",
    "question": "Your company is developing a new application that will allow globally distributed users to upload pictures and share them with other selected users. The application will support millions of concurrent users. You want to allow developers to focus on just building code without having to create and maintain the underlying infrastructure. Which service should you use to deploy the application?",
    "options": {
      "A": "App Engine",
      "B": "Cloud Endpoints",
      "C": "Compute Engine",
      "D": "Google Kubernetes Engine"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "App Engine is a fully managed, serverless platform specifically designed for web applications and APIs that need to scale automatically and handle large numbers of users without requiring infrastructure management from developers. It fits the requirements of scalability (millions of users) and developer focus on code.",
    "conditions": [
      "New app: picture upload/sharing",
      "Global users",
      "Millions of concurrent users",
      "Minimize infrastructure management (developer focus on code)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 120,
    "topic": "API Management",
    "question": "Your company provides a recommendation engine for retail customers. You are providing retail customers with an API where they can submit a user ID and the API returns a list of recommendations for that user. You are responsible for the API lifecycle and want to ensure stability for your customers in case the API makes backward-incompatible changes. You want to follow Google-recommended practices. What should you do?",
    "options": {
      "A": "Create a distribution list of all customers to inform them of an upcoming backward-incompatible change at least one month before replacing the old API with the new API.",
      "B": "Create an automated process to generate API documentation, and update the public API documentation as part of the CI/CD process when deploying an update to the API.",
      "C": "Use a versioning strategy for the APIs that increases the version number on every backward-incompatible change.",
      "D": "Use a versioning strategy for the APIs that adds the suffix a€DEPRECATEDa€é to the current API version number on every backward-incompatible change. Use the current version number for the new API."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Handling backward-incompatible API changes requires versioning. The standard practice is to introduce a new API version (e.g., /v2/) when making breaking changes, while keeping the old version (/v1/) available for a deprecation period. This allows existing clients to continue functioning while migrating to the new version.",
    "conditions": [
      "Provide API to customers",
      "Ensure stability during backward-incompatible changes",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 121,
    "topic": "Application Modernization",
    "question": "Your company has developed a monolithic, 3-tier application to allow external users to upload and share files. The solution cannot be easily enhanced and lacks reliability. The development team would like to re-architect the application to adopt microservices and a fully managed service approach, but they need to convince their leadership that the effort is worthwhile. Which advantage(s) should they highlight to leadership?",
    "options": {
      "A": "The new approach will be significantly less costly, make it easier to manage the underlying infrastructure, and automatically manage the CI/CD pipelines.",
      "B": "The monolithic solution can be converted to a container with Docker. The generated container can then be deployed into a Kubernetes cluster.",
      "C": "The new approach will make it easier to decouple infrastructure from application, develop and release new features, manage the underlying infrastructure, manage CI/CD pipelines and perform A/B testing, and scale the solution if necessary.",
      "D": "The process can be automated with Migrate for Compute Engine."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Migrating from a monolith to microservices and managed services offers key business benefits: improved agility (faster feature development/release), better scalability (scale individual services), enhanced reliability (failure isolation), potential operational cost savings (managed services), easier infrastructure management, and enablement of modern practices like CI/CD and A/B testing. Option C encapsulates these advantages effectively for leadership.",
    "conditions": [
      "Existing monolithic app (file upload/share)",
      "Difficult to enhance, lacks reliability",
      "Plan: Re-architect to microservices & managed services",
      "Need to justify effort to leadership"
    ],
    "caseStudyContext": null
  },
  {
    "id": 122,
    "topic": "DevOps",
    "question": "Your team is developing a web application that will be deployed on Google Kubernetes Engine (GKE). Your CTO expects a successful launch and you need to ensure your application can handle the expected load of tens of thousands of users. You want to test the current deployment to ensure the latency of your application stays below a certain threshold. What should you do?",
    "options": {
      "A": "Use a load testing tool to simulate the expected number of concurrent users and total requests to your application, and inspect the results.",
      "B": "Enable autoscaling on the GKE cluster and enable horizontal pod autoscaling on your application deployments. Send curl requests to your application, and validate if the auto scaling works.",
      "C": "Replicate the application over multiple GKE clusters in every Google Cloud region. Configure a global HTTP(S) load balancer to expose the different clusters over a single global IP address.",
      "D": "Use Cloud Debugger in the development environment to understand the latency between the different microservices."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To validate performance (latency) under a specific expected load (tens of thousands of users), load testing is required. Using a load testing tool (A) allows simulating realistic traffic patterns and volume against the GKE deployment to measure response times and error rates, confirming if latency stays below the threshold under anticipated production load. B tests autoscaling function, not latency under load. C describes global deployment, not testing. D is for debugging, not load testing.",
    "conditions": [
      "Web app deployed on GKE",
      "Expected load: tens of thousands of users",
      "Test latency under expected load",
      "Ensure latency < threshold"
    ],
    "caseStudyContext": null
  },
  {
    "id": 123,
    "topic": "Compute",
    "question": "Your company has a Kubernetes application that pulls messages from Pub/Sub and stores them in Filestore. Because the application is simple, it was deployed as a single pod. The infrastructure team has analyzed Pub/Sub metrics and discovered that the application cannot process the messages in real time. Most of them wait for minutes before being processed. You need to scale the elaboration process that is I/O-intensive. What should you do?",
    "options": {
      "A": "Use kubectl autoscale deployment APP_NAME --max 6 -min 2 --cpu-percent 50 to configure Kubernetes autoscaling deployment.",
      "B": "Configure a Kubernetes autoscaling deployment based on the subscription/push_request_latencies metric.",
      "C": "Use the --enable-autoscaling flag when you create the Kubernetes cluster.",
      "D": "Configure a Kubernetes autoscaling deployment based on the subscription/num_undelivered_messages metric."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "The bottleneck is message processing backlog, as messages wait minutes. Scaling should be based on this backlog size. The Pub/Sub metric `subscription/num_undelivered_messages` directly reflects the backlog. Configuring a Horizontal Pod Autoscaler (HPA) using a custom metric based on `num_undelivered_messages` (D) will automatically increase the number of processing pods when the backlog grows, directly addressing the processing delay. Scaling on CPU (A) is incorrect as the bottleneck is I/O. Push latency (B) is less relevant than backlog size. Cluster autoscaling (C) scales nodes, not pods based on backlog.",
    "conditions": [
      "Kubernetes app (single pod) processing Pub/Sub messages",
      "Stores data in Filestore (I/O intensive)",
      "Processing delayed (minutes backlog)",
      "Need to scale the processing"
    ],
    "caseStudyContext": null
  },
  {
    "id": 124,
    "topic": "IAM & Security",
    "question": "Your company is developing a new application that will allow globally distributed users to upload pictures and share them with other selected users. The application will support millions of concurrent users. You want to allow developers to focus on just building code without having to create and maintain the underlying infrastructure. Which service should you use to deploy the application?",
    "options": {
      "A": "App Engine",
      "B": "Cloud Endpoints",
      "C": "Compute Engine",
      "D": "Google Kubernetes Engine"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "App Engine is Google Cloud's fully managed Platform-as-a-Service (PaaS) offering. It handles scaling, infrastructure management, patching, and load balancing automatically, allowing developers to focus solely on writing application code. It's designed to scale seamlessly to handle millions of users and global traffic, fitting the requirements perfectly.",
    "conditions": [
      "New application for picture upload/sharing",
      "Globally distributed users",
      "Support millions of concurrent users",
      "Minimize infrastructure management for developers"
    ],
    "caseStudyContext": null
  },
  {
    "id": 125,
    "topic": "Serverless",
    "question": "An application development team has come to you for advice. They are planning to write and deploy an HTTP(S) API using Go 1.12. The API will have a very unpredictable workload and must remain reliable during peaks in traffic. They want to minimize operational overhead for this application. Which approach should you recommend?",
    "options": {
      "A": "Develop the application with containers, and deploy to Google Kubernetes Engine.",
      "B": "Develop the application for App Engine standard environment.",
      "C": "Use a Managed Instance Group when deploying to Compute Engine.",
      "D": "Develop the application for App Engine flexible environment, using a custom runtime."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "App Engine Standard Environment is a fully managed, serverless platform that excels at handling unpredictable HTTP(S) workloads with rapid, automatic scaling (including scale-to-zero). It requires minimal operational overhead as Google manages the infrastructure. Go 1.12 is a supported runtime. GKE (A) and Compute Engine MIGs (C) require more operational effort. App Engine Flexible (D) offers more customization but typically has slower scaling and doesn't scale to zero compared to Standard.",
    "conditions": [
      "Deploy HTTP(S) API (Go 1.12)",
      "Very unpredictable workload",
      "Reliable during peaks",
      "Minimize operational overhead"
    ],
    "caseStudyContext": null
  },
  {
    "id": 126,
    "topic": "Storage",
    "question": "Your company is designing its data lake on Google Cloud and wants to develop different ingestion pipelines to collect unstructured data from different sources.\nAfter the data is stored in Google Cloud, it will be processed in several data pipelines to build a recommendation engine for end users on the website. The structure of the data retrieved from the source systems can change at any time. The data must be stored exactly as it was retrieved for reprocessing purposes in case the data structure is incompatible with the current processing pipelines. You need to design an architecture to support the use case after you retrieve the data. What should you do?",
    "options": {
      "A": "Send the data through the processing pipeline, and then store the processed data in a BigQuery table for reprocessing.",
      "B": "Store the data in a BigQuery table. Design the processing pipelines to retrieve the data from the table.",
      "C": "Send the data through the processing pipeline, and then store the processed data in a Cloud Storage bucket for reprocessing.",
      "D": "Store the data in a Cloud Storage bucket. Design the processing pipelines to retrieve the data from the bucket."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "The requirement to store unstructured data 'exactly as retrieved' and handle changing structures points to using Cloud Storage as the landing zone (data lake). Cloud Storage can hold any file format without enforcing a schema. Processing pipelines can then read this raw data from the bucket (D). If processing fails due to schema changes, the original, untouched data remains in Cloud Storage for later reprocessing with updated pipelines. Storing only processed data (A, C) loses the original raw form. Storing directly in BigQuery (B) requires a schema upfront, problematic for changing, unstructured source data.",
    "conditions": [
      "Design data lake architecture",
      "Ingest unstructured data",
      "Source data structure can change",
      "Data processed later (recommendation engine)",
      "Must store data exactly as retrieved for reprocessing"
    ],
    "caseStudyContext": null
  },
  {
    "id": 127,
    "topic": "IAM & Security",
    "question": "You are responsible for the Google Cloud environment in your company. Multiple departments need access to their own projects, and the members within each department will have the same project responsibilities. You want to structure your Google Cloud environment for minimal maintenance and maximum overview of IAM permissions as each department's projects start and end. You want to follow Google-recommended practices. What should you do?",
    "options": {
      "A": "Grant all department members the required IAM permissions for their respective projects.",
      "B": "Create a Google Group per department and add all department members to their respective groups. Create a folder per department and grant the respective group the required IAM permissions at the folder level. Add the projects under the respective folders.",
      "C": "Create a folder per department and grant the respective members of the department the required IAM permissions at the folder level. Structure all projects for each department under the respective folders.",
      "D": "Create a Google Group per department and add all department members to their respective groups. Grant each group the required IAM permissions for their respective projects."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "The recommended practice for managing permissions at scale involves using Google Groups and the Resource Hierarchy (Folders). Create a group for each department, add members to the group. Create a folder for each department. Grant the necessary IAM roles to the group at the folder level. Place department projects inside their respective folders. Permissions are inherited, and managing access becomes a matter of updating group membership, which minimizes maintenance and provides a clear overview via folder-level policies.",
    "conditions": [
      "Manage GCP environment for multiple departments",
      "Members within a department share responsibilities",
      "Minimize maintenance, maximize IAM overview",
      "Handle project lifecycle (start/end)",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 128,
    "topic": "Security",
    "question": "Your company has an application running as a Deployment in a Google Kubernetes Engine (GKE) cluster. You have separate clusters for development, staging, and production. You have discovered that the team is able to deploy a Docker image to the production cluster without first testing the deployment in development and then staging. You want to allow the team to have autonomy but want to prevent this from happening. You want a Google Cloud solution that can be implemented quickly with minimal effort. What should you do?",
    "options": {
      "A": "Configure a Kubernetes lifecycle hook to prevent the container from starting if it is not approved for usage in the given environment.",
      "B": "Implement a corporate policy to prevent teams from deploying Docker images to an environment unless the Docker image was tested in a earlier environment.",
      "C": "Configure binary authorization policies for the development, staging, and production clusters. Create attestations as part of the continuous integration pipeline.",
      "D": "Create a Kubernetes admissions controller to prevent the container from starting if it is not approved for usage in the given environment."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Binary Authorization is a GCP service designed to enforce deployment policies on GKE. You can create policies requiring specific attestations (digital signatures created during CI/CD) before an image can be deployed to a cluster (e.g., require 'staging-passed' attestation for production deployment). This prevents untested images from reaching production while allowing teams autonomy within the defined CI/CD process. Implementing this (C) is generally quicker and involves less effort than building custom controllers (D) or relying solely on corporate policy (B). Lifecycle hooks (A) are for container runtime events, not deployment enforcement.",
    "conditions": [
      "App deployed on GKE (Dev, Staging, Prod clusters)",
      "Problem: Direct deployment to Prod possible without testing",
      "Goal: Prevent direct Prod deployment, enforce testing flow",
      "Allow team autonomy",
      "Quick implementation, minimal effort, GCP solution"
    ],
    "caseStudyContext": null
  },
  {
    "id": 129,
    "topic": "Storage",
    "question": "Your company wants to migrate their 10-TB on-premises database export into Cloud Storage. You want to minimize the time it takes to complete this activity, the overall cost, and database load. The bandwidth between the on-premises environment and Google Cloud is 1 Gbps. You want to follow Google-recommended practices. What should you do?",
    "options": {
      "A": "Develop a Dataflow job to read data directly from the database and write it into Cloud Storage.",
      "B": "Use the Data Transfer appliance to perform an offline migration.",
      "C": "Use a commercial partner ETL solution to extract the data from the on-premises database and upload it into Cloud Storage.",
      "D": "Compress the data and upload it with gsutil -m to enable multi-threaded copy."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Transferring 10 TB over a 1 Gbps connection is feasible within about a day. To optimize this network transfer, compressing the data reduces the volume, and using `gsutil -m` enables parallel uploads, maximizing bandwidth utilization and minimizing transfer time (D). This uses standard tools and avoids additional database load (since it transfers an existing export). Transfer Appliance (B) is generally for larger datasets or slower links. Dataflow (A) or ETL tools (C) are unnecessary for transferring a pre-existing file and add complexity.",
    "conditions": [
      "Migrate 10 TB on-prem DB export to Cloud Storage",
      "Minimize time, cost, DB load",
      "1 Gbps bandwidth available",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 130,
    "topic": "Compute",
    "question": "Your company has an enterprise application running on Compute Engine that requires high availability and high performance. The application has been deployed on two instances in two zones in the same region in active-passive mode. The application writes data to a persistent disk. In the case of a single zone outage, that data should be immediately made available to the other instance in the other zone. You want to maximize performance while minimizing downtime and data loss. What should you do?",
    "options": {
      "A": "1. Attach a persistent SSD disk to the first instance. 2. Create a snapshot every hour. 3. In case of a zone outage, recreate a persistent SSD disk in the second instance where data is coming from the created snapshot.",
      "B": "1. Create a Cloud Storage bucket. 2. Mount the bucket into the first instance with gcs-fuse. 3. In case of a zone outage, mount the Cloud Storage bucket to the second instance with gcs-fuse.",
      "C": "1. Attach a regional SSD persistent disk to the first instance. 2. In case of a zone outage, force-attach the disk to the other instance.",
      "D": "1. Attach a local SSD to the first instance disk. 2. Execute an rsync command every hour where the target is a persistent SSD disk attached to the second instance. 3. In case of a zone outage, use the second instance."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Regional Persistent Disks provide synchronous data replication between two zones within a region. Attaching a regional SSD (for performance) to the active instance ensures the data is also available in the standby zone. If the active zone fails, the regional disk can be force-attached to the standby instance in the other zone, providing immediate access to the latest replicated data, minimizing downtime and data loss (RPO close to zero). Snapshots (A) incur data loss. gcsfuse (B) has performance/consistency limitations. Local SSDs (D) are ephemeral and rsync involves data lag.",
    "conditions": [
      "Enterprise app on GCE, needs HA & performance",
      "Active-passive deployment across 2 zones, 1 region",
      "App writes to persistent disk",
      "Data must be immediately available in other zone on failure",
      "Maximize performance, minimize downtime/data loss"
    ],
    "caseStudyContext": null
  },
  {
    "id": 131,
    "topic": "IAM & Security",
    "question": "You are designing a Data Warehouse on Google Cloud and want to store sensitive data in BigQuery. Your company requires you to generate the encryption keys outside of Google Cloud. You need to implement a solution. What should you do?",
    "options": {
      "A": "Generate a new key in Cloud Key Management Service (Cloud KMS). Store all data in Cloud Storage using the customer-managed key option and select the created key. Set up a Dataflow pipeline to decrypt the data and to store it in a new BigQuery dataset.",
      "B": "Generate a new key in Cloud KMS. Create a dataset in BigQuery using the customer-managed key option and select the created key.",
      "C": "Import a key in Cloud KMS. Store all data in Cloud Storage using the customer-managed key option and select the created key. Set up a Dataflow pipeline to decrypt the data and to store it in a new BigQuery dataset.",
      "D": "Import a key in Cloud KMS. Create a dataset in BigQuery using the customer-supplied key option and select the created key."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "The requirement is to use keys generated *outside* Google Cloud to encrypt BigQuery data. Cloud KMS allows importing externally generated keys (Customer-Managed Keys - CMEK). BigQuery supports CMEK at the dataset or table level. Option D correctly describes importing the external key into KMS and then using this imported key (referred to slightly inaccurately as 'customer-supplied' in the option, but the context implies CMEK with an imported key) to encrypt the BigQuery dataset. Options A/C add unnecessary complexity with GCS/Dataflow. Option B incorrectly suggests generating the key *in* KMS.",
    "conditions": [
      "DWH on BigQuery storing sensitive data",
      "Requirement: Use encryption keys generated outside GCP"
    ],
    "caseStudyContext": null
  },
  {
    "id": 132,
    "topic": "Security",
    "question": "Your organization has stored sensitive data in a Cloud Storage bucket. For regulatory reasons, your company must be able to rotate the encryption key used to encrypt the data in the bucket. The data will be processed in Dataproc. You want to follow Google-recommended practices for security. What should you do?",
    "options": {
      "A": "Create a key with Cloud Key Management Service (KMS). Encrypt the data using the encrypt method of Cloud KMS.",
      "B": "Create a key with Cloud Key Management Service (KMS). Set the encryption key on the bucket to the Cloud KMS key.",
      "C": "Generate a GPG key pair. Encrypt the data using the GPG key. Upload the encrypted data to the bucket.",
      "D": "Generate an AES-256 encryption key. Encrypt the data in the bucket using the customer-supplied encryption keys feature."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Using Customer-Managed Encryption Keys (CMEK) allows Cloud Storage to encrypt/decrypt data using a key managed in Cloud KMS. This satisfies the key rotation requirement (managed via KMS) and integrates smoothly with Dataproc (which can be granted permissions to use the KMS key). Setting the bucket's default encryption to use a specific KMS key (B) is the standard CMEK setup for Cloud Storage. Manual encryption (A, C) or CSEK (D) adds complexity and potential integration issues with Dataproc.",
    "conditions": [
      "Sensitive data in GCS bucket",
      "Requirement: Able to rotate encryption key",
      "Data processed by Dataproc",
      "Follow Google recommended security practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 133,
    "topic": "Networking",
    "question": "Your team needs to create a Google Kubernetes Engine (GKE) cluster to host a newly built application that requires access to third-party services on the internet. Your company does not allow any Compute Engine instance to have a public IP address on Google Cloud. You need to create a deployment strategy that adheres to these guidelines. What should you do?",
    "options": {
      "A": "Configure the GKE cluster as a private cluster, and configure Cloud NAT Gateway for the cluster subnet.",
      "B": "Configure the GKE cluster as a private cluster. Configure Private Google Access on the Virtual Private Cloud (VPC).",
      "C": "Configure the GKE cluster as a route-based cluster. Configure Private Google Access on the Virtual Private Cloud (VPC).",
      "D": "Create a Compute Engine instance, and install a NAT Proxy on the instance. Configure all workloads on GKE to pass through this proxy to access third-party services on the Internet."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "A private GKE cluster ensures nodes do not have public IPs. To allow outbound internet access (for third-party services) from these private nodes, Cloud NAT is required. Cloud NAT provides managed network address translation for specified subnets, allowing instances without public IPs to reach the internet. Option A correctly combines a private cluster with Cloud NAT. Private Google Access (B, C) only provides access to Google APIs, not the general internet. A manual NAT proxy (D) adds operational overhead.",
    "conditions": [
      "Create GKE cluster",
      "Application needs outbound internet access (third-party services)",
      "Policy: No GCE instances (including GKE nodes) can have public IPs"
    ],
    "caseStudyContext": null
  },
  {
    "id": 134,
    "topic": "Networking",
    "question": "Your company has a support ticketing solution that uses App Engine Standard. The project that contains the App Engine application already has a Virtual Private Cloud (VPC) network fully connected to the company's on-premises environment through a Cloud VPN tunnel. You want to enable the App Engine application to communicate with a database that is running in the company's on-premises environment. What should you do?",
    "options": {
      "A": "Configure private Google access for on-premises hosts only.",
      "B": "Configure private Google access.",
      "C": "Configure private services access.",
      "D": "Configure serverless VPC access."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "App Engine Standard runs outside your VPC network. To connect it to resources within your VPC (and subsequently to on-premises resources via VPN/Interconnect), you need to use a Serverless VPC Access connector. This connector acts as a bridge, allowing the App Engine Standard service to send traffic to private IP addresses within your VPC.",
    "conditions": [
      "App Engine Standard application",
      "VPC connected to on-prem via Cloud VPN",
      "App Engine app needs to connect to on-prem DB (via VPC)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 135,
    "topic": "Storage",
    "question": "Your company is planning to upload several important files to Cloud Storage. After the upload is completed, they want to verify that the uploaded content is identical to what they have on-premises. You want to minimize the cost and effort of performing this check. What should you do?",
    "options": {
      "A": "1. Use Linux shasum to compute a digest of files you want to upload. 2. Use gsutil -m to upload all the files to Cloud Storage. 3. Use gsutil cp to download the uploaded files. 4. Use Linux shasum to compute a digest of the downloaded files. 5. Compare the hashes.",
      "B": "1. Use gsutil -m to upload the files to Cloud Storage. 2. Develop a custom Java application that computes CRC32C hashes. 3. Use gsutil ls -L gs://[YOUR_BUCKET_NAME] to collect CRC32C hashes of the uploaded files. 4. Compare the hashes.",
      "C": "1. Use gsutil -m to upload all the files to Cloud Storage. 2. Use gsutil cp to download the uploaded files. 3. Use Linux diff to compare the content of the files.",
      "D": "1. Use gsutil -m to upload the files to Cloud Storage. 2. Use gsutil hash -c FILELNAME to generate CRC32C hashes of all on-premises files. 3. Use gsutil ls -L gs://[YOUR_BUCKET_NAME] to collect CRC32C hashes of the uploaded files. 4. Compare the hashes."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "To efficiently verify file integrity after uploading to Cloud Storage: Calculate the CRC32C hash of the local file using `gsutil hash -c`. Upload the file using `gsutil -m cp`. Retrieve the CRC32C hash calculated and stored by Cloud Storage using `gsutil ls -L`. Compare the local hash and the Cloud Storage hash. This avoids re-downloading the file, minimizing cost and effort.",
    "conditions": [
      "Upload important files on-prem to GCS",
      "Verify uploaded content matches original",
      "Minimize cost and effort"
    ],
    "caseStudyContext": null
  },
  {
    "id": 136,
    "topic": "Operations",
    "question": "You have deployed an application on Anthos clusters (formerly Anthos GKE). According to the SRE practices at your company, you need to be alerted if request latency is above a certain threshold for a specified amount of time. What should you do?",
    "options": {
      "A": "Install Anthos Service Mesh on your cluster. Use the Google Cloud Console to define a Service Level Objective (SLO), and create an alerting policy based on this SLO.",
      "B": "Enable the Cloud Trace API on your project, and use Cloud Monitoring Alerts to send an alert based on the Cloud Trace metrics.",
      "C": "Use Cloud Profiler to follow up the request latency. Create a custom metric in Cloud Monitoring based on the results of Cloud Profiler, and create an Alerting policy in case this metric exceeds the threshold.",
      "D": "Configure Anthos Config Management on your cluster, and create a yaml file that defines the SLO and alerting policy you want to deploy in your cluster."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Anthos Service Mesh provides latency metrics. SRE best practices involve defining Service Level Objectives (SLOs) based on user-facing metrics like latency. Cloud Monitoring allows creating SLOs based on Service Mesh metrics and then creating Alerting Policies that trigger when the SLO's error budget is consumed or a latency threshold is breached for a specified duration. Option A describes this standard approach.",
    "conditions": [
      "App on Anthos clusters",
      "SRE practice: Alert on sustained high request latency"
    ],
    "caseStudyContext": null
  },
  {
    "id": 137,
    "topic": "Networking",
    "question": "Your company has a stateless web API that performs scientific calculations. The web API runs on a single Google Kubernetes Engine (GKE) cluster. The cluster is currently deployed in us-central1. Your company has expanded to offer your API to customers in Asia. You want to reduce the latency for users in Asia. What should you do?",
    "options": {
      "A": "Create a second GKE cluster in asia-southeast1, and expose both APIs using a Service of type LoadBalancer. Add the public IPs to the Cloud DNS zone.",
      "B": "Use a global HTTP(s) load balancer with Cloud CDN enabled.",
      "C": "Create a second GKE cluster in asia-southeast1, and use kubemci to create a global HTTP(s) load balancer.",
      "D": "Increase the memory and CPU allocated to the application in the cluster."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To reduce latency for Asian users, deploy the API closer to them. Create a second GKE cluster in an Asian region (e.g., asia-southeast1). Use a Global HTTP(S) Load Balancer to direct users to the nearest cluster. `kubemci` (or its successor, Multi Cluster Ingress/Ingress for Anthos) is used to configure the global load balancer to manage traffic across multiple GKE clusters in different regions. Option C describes this multi-cluster setup with global load balancing.",
    "conditions": [
      "Stateless web API on single GKE cluster (us-central1)",
      "New customers in Asia",
      "Goal: Reduce latency for Asian users"
    ],
    "caseStudyContext": null
  },
  {
    "id": 138,
    "topic": "Migration",
    "question": "You are migrating third-party applications from optimized on-premises virtual machines to Google Cloud. You are unsure about the optimum CPU and memory options. The applications have a consistent usage pattern across multiple weeks. You want to optimize resource usage for the lowest cost. What should you do?",
    "options": {
      "A": "Create an instance template with the smallest available machine type, and use an image of the third-party application taken from a current on-premises virtual machine. Create a managed instance group that uses average CPU utilization to autoscale the number of instances in the group. Modify the average CPU utilization threshold to optimize the number of instances running.",
      "B": "Create an App Engine flexible environment, and deploy the third-party application using a Dockerfile and a custom runtime. Set CPU and memory options similar to your application's current on-premises virtual machine in the app.yaml file.",
      "C": "Create multiple Compute Engine instances with varying CPU and memory options. Install the Cloud Monitoring agent, and deploy the third party application on each of them. Run a load test with high traffic levels on the application, and use the results to determine the optimal settings.",
      "D": "Create a Compute Engine instance with CPU and memory options similar to your application's current on-premises virtual machine. Install the Cloud Monitoring agent, and deploy the third-party application. Run a load test with normal traffic levels on the application, and follow the Rightsizing Recommendations in the Cloud Console."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Start by creating a GCE instance similar in size to the on-prem VM. Install the Cloud Monitoring agent to collect performance data. Run the application under normal load patterns. Use GCP's built-in Rightsizing Recommendations feature, which analyzes the monitoring data and suggests more appropriately sized (often smaller for cost savings, or potentially larger if under-provisioned) machine types based on actual usage. This iterative approach (D) helps find the optimal balance between performance and cost.",
    "conditions": [
      "Migrate third-party apps from optimized on-prem VMs",
      "Unsure about optimal GCP CPU/memory",
      "Consistent usage pattern",
      "Goal: Optimize resource usage for lowest cost"
    ],
    "caseStudyContext": null
  },
  {
    "id": 139,
    "topic": "IAM & Security",
    "question": "Your company has a Google Cloud project that uses BigQuery for data warehousing. They have a VPN tunnel between the on-premises environment and Google Cloud that is configured with Cloud VPN. The security team wants to avoid data exfiltration by malicious insiders, compromised code, and accidental oversharing. What should they do?",
    "options": {
      "A": "Configure Private Google Access for on-premises only.",
      "B": "Perform the following tasks: 1. Create a service account. 2. Give the BigQuery JobUser role and Storage Reader role to the service account. 3. Remove all other IAM access from the project.",
      "C": "Configure VPC Service Controls and configure Private Google Access.",
      "D": "Configure Private Google Access."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "VPC Service Controls create a security perimeter around specified GCP resources (like BigQuery datasets). This prevents data from leaving the perimeter, even by authorized users or compromised services, mitigating exfiltration risks. Configuring access levels within the perimeter (e.g., allowing access only from specific VPC networks or on-premises IPs via the VPN) further restricts access. Private Google Access allows on-prem hosts or private VPC instances to reach Google APIs without traversing the public internet, complementing VPC Service Controls for enhanced security.",
    "conditions": [
      "BigQuery DWH used",
      "VPN connection to on-prem",
      "Goal: Prevent data exfiltration (insider, compromised code, accidental)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 140,
    "topic": "Compute",
    "question": "You are working at an institution that processes medical data. You are migrating several workloads onto Google Cloud. Company policies require all workloads to run on physically separated hardware, and workloads from different clients must also be separated. You created a sole-tenant node group and added a node for each client. You need to deploy the workloads on these dedicated hosts. What should you do?",
    "options": {
      "A": "Add the node group name as a network tag when creating Compute Engine instances in order to host each workload on the correct node group.",
      "B": "Add the node name as a network tag when creating Compute Engine instances in order to host each workload on the correct node.",
      "C": "Use node affinity labels based on the node group name when creating Compute Engine instances in order to host each workload on the correct node group.",
      "D": "Use node affinity labels based on the node name when creating Compute Engine instances in order to host each workload on the correct node."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Sole-tenant nodes provide dedicated hardware. To ensure VMs are placed on specific sole-tenant nodes or groups, node affinity labels are used. You define labels on the node group (e.g., `client=client-a`) and specify matching affinity requirements when creating the VM instance. This directs the scheduler to place the VM onto a node within the designated group (C), ensuring client separation on dedicated hardware. Network tags (A, B) are for networking/firewalls. Targeting specific node names (D) is less flexible than targeting groups.",
    "conditions": [
      "Processing medical data",
      "Policy: Workloads on physically separated hardware",
      "Policy: Separate workloads for different clients",
      "Using sole-tenant nodes (one per client in a group)",
      "Need to deploy workloads to correct dedicated hosts"
    ],
    "caseStudyContext": null
  },
  {
    "id": 141,
    "topic": "DevOps",
    "question": "Your company's test suite is a custom C++ application that runs tests throughout each day on Linux virtual machines. The full test suite takes several hours to complete, running on a limited number of on-premises servers reserved for testing. Your company wants to move the testing infrastructure to the cloud, to reduce the amount of time it takes to fully test a change to the system, while changing the tests as little as possible. Which cloud infrastructure should you recommend?",
    "options": {
      "A": "Google Compute Engine unmanaged instance groups and Network Load Balancer",
      "B": "Google Compute Engine managed instance groups with auto-scaling",
      "C": "Google Cloud Dataproc to run Apache Hadoop jobs to process each test",
      "D": "Google App Engine with Google StackDriver for logging"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "The goal is to reduce test duration by running the existing C++ application on scalable cloud infrastructure. Compute Engine Managed Instance Groups (MIGs) with autoscaling (B) allow creating a pool of Linux VMs that can automatically scale up to run tests in parallel and scale down when finished, significantly reducing the overall test suite time. This approach requires minimal changes to the C++ application itself. Unmanaged groups (A) lack scaling. Dataproc (C) and App Engine (D) are unsuitable for running a custom C++ test suite.",
    "conditions": [
      "Custom C++ test suite runs on Linux VMs",
      "Currently slow due to limited on-prem servers",
      "Goal: Move to cloud, reduce test time",
      "Minimize changes to test application"
    ],
    "caseStudyContext": null
  },
  {
    "id": 142,
    "topic": "Networking",
    "question": "A lead software engineer tells you that his new application design uses websockets and HTTP sessions that are not distributed across the web servers. You want to help him ensure his application will run property on Google Cloud Platform. What should you do?",
    "options": {
      "A": "Help the engineer to convert his websocket code to use HTTP streaming.",
      "B": "Review the encryption requirements for websocket connections with the security team.",
      "C": "Meet with the cloud operations team and the engineer to discuss load balancer options.",
      "D": "Help the engineer redesign the application to use a distributed user session service that does not rely on websockets and HTTP sessions."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Non-distributed sessions (session state stored locally on web servers) require session affinity ('sticky sessions') at the load balancer level to ensure subsequent requests from the same user hit the same server. Websockets also need specific load balancer support. Google Cloud Load Balancing (specifically HTTP(S) Load Balancer) supports both websockets and session affinity configurations. Discussing these load balancer options (C) with the relevant teams is the necessary step to ensure compatibility and proper function on GCP.",
    "conditions": [
      "Application uses websockets",
      "Application uses non-distributed HTTP sessions (local state)",
      "Need to ensure proper operation on GCP"
    ],
    "caseStudyContext": null
  },
  {
    "id": 143,
    "topic": "Storage",
    "question": "The application reliability team at your company this added a debug feature to their backend service to send all server events to Google Cloud Storage for eventual analysis. The event records are at least 50 KB and at most 15 MB and are expected to peak at 3,000 events per second. You want to minimize data loss. Which process should you implement?",
    "options": {
      "A": " Append metadata to file body  Compress individual files   Name files with serverName - Timestamp   Create a new bucket bucket is older than 1 hour and save individual files to the new bucket. Otherwise, save files to existing bucket.",
      "B": " Batch every 10,000 events with a single manifest file for metadata  Compress event files and manifest file into a single archive file  Name files using serverName - EventSequence  Create a new bucket if bucket is older than 1 day and save the single archive file to the new bucket. Otherwise, save the single archive file to existing bucket.",
      "C": " Compress individual files  Name files with serverName - EventSequence  Save files to one bucket  Set custom metadata headers for each object after saving",
      "D": " Append metadata to file body  Compress individual files   Name files with a random prefix pattern  Save files to one bucket"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "High ingestion rates (3000 objects/sec) into Cloud Storage can lead to performance issues if object names follow sequential patterns (like timestamps or sequences), creating 'hotspots'. Naming files with a random prefix pattern (D) distributes writes across the GCS key space, ensuring high throughput and reliability, thus minimizing potential data loss due to write throttling. Compressing files and appending metadata are reasonable choices. Using a single bucket simplifies management.",
    "conditions": [
      "Send server events to Cloud Storage",
      "Record size: 50KB - 15MB",
      "Peak rate: 3000 events/sec",
      "Minimize data loss (implies maximizing write performance/reliability)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 144,
    "topic": "Operations",
    "question": "A recent audit that a new network was created in Your GCP project. In this network, a GCE instance has an SSH port open the world. You want to discover this network's origin. What should you do?",
    "options": {
      "A": "Search for Create VM entry in the Stackdriver alerting console.",
      "B": "Navigate to the Activity page in the Home sectio Set category to Data Access and search for Create VM entry.",
      "C": "In the logging section of the console, specify GCE Network as the logging sectio Search for the Create Insert entry.",
      "D": "Connect to the GCE instance using project SSH Key Identify previous logins in system logs, and match these with the project owners list."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To find out who created a specific GCP resource (like a VPC network or a GCE instance), you need to consult the Admin Activity audit logs. These logs are accessible via Cloud Logging. Filtering the logs by resource type (`gce_network` or `gce_instance`) and the relevant creation method name (e.g., `v1.compute.networks.insert` or `v1.compute.instances.insert`) will reveal the principal (user or service account) that performed the action and the timestamp.",
    "conditions": [
      "Audit found newly created network",
      "Instance within network has SSH open to 0.0.0.0/0",
      "Need to find origin (who/when created) of the network"
    ],
    "caseStudyContext": null
  },
  {
    "id": 145,
    "topic": "Compute",
    "question": "You want to make a copy of a production Linux virtual machine in the US-Central region. You want to manage and replace the copy easily if there are changes on the production virtual machine. You will deploy the copy as a new instance in a different project in the US-East region. What steps must you take?",
    "options": {
      "A": "Use the Linux dd and netcat commands to copy and stream the root disk contents to a new virtual machine instance in the US-East region",
      "B": "Create a snapshot of the root disk and select the snapshot as the root disk when you create a new virtual machine instance in the US-East region.",
      "C": "Create an image file from the root disk with Linux dd command, create a new virtual machine instance in the US-East region",
      "D": "Create a snapshot of the root disk, create an image file in Google Cloud Storage from the snapshot, and create a new virtual machine instance in the US-East region using the image file the root disk."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "To copy a VM across regions and projects, the standard method involves creating a custom image: 1. Create a snapshot of the source VM's disk. 2. Create a custom image from that snapshot (images can be used across regions and shared across projects). 3. In the target project and region (US-East), create a new VM instance using the custom image as the boot source. Option D describes this process (although step 2 creates the image in Compute Engine Images, not directly GCS). Snapshots (B) are regional and cannot be directly used across regions/projects.",
    "conditions": [
      "Copy production Linux VM (us-central1)",
      "Deploy copy in different project and region (us-east1)",
      "Manage/replace copy easily"
    ],
    "caseStudyContext": null
  },
  {
    "id": 146,
    "topic": "Storage",
    "question": "Your company runs several databases on a single MySQL instance. They need to take backups of a specific database at regular intervals. The backup activity needs to complete as quickly as possible and cannot be allowed to impact disk performance. How should you configure the storage?",
    "options": {
      "A": "Configure a cron job to use the gcloud tool to take regular backups using persistent disk snapshots.",
      "B": "Mount a Local SSD volume as the backup locatio After the backup is complete, use gsutil to move the backup to Google Cloud Storage.",
      "C": "Use gcsfuse to mount a Google Cloud Storage bucket as a volume directly on the instance and write backups to the mounted location using mysqldump",
      "D": "Mount additional persistent disk volumes onto each virtual machine (VM) instance in a RAID10 array and use LVM to create snapshots to send to Cloud Storage."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Persistent Disk snapshots provide a fast, low-impact way to back up the entire disk state. Creating a snapshot (A) typically has minimal performance impact on the running instance compared to writing large backup files. While snapshots are disk-level, they are commonly used for database backups, allowing point-in-time recovery of the disk. Automating snapshot creation via `gcloud` in a cron job is straightforward. Local SSDs (B) are fast but ephemeral. gcsfuse (C) can have performance issues. LVM snapshots (D) add complexity.",
    "conditions": [
      "Backup specific database from multi-DB MySQL instance",
      "Regular intervals",
      "Backup must be fast",
      "Minimal impact on disk performance during backup"
    ],
    "caseStudyContext": null
  },
  {
    "id": 147,
    "topic": "DevOps",
    "question": "You are helping the QA team to roll out a new load-testing tool to test the scalability of your primary cloud services that run on Google Compute Engine with Cloud Bigtable. Which three requirements should they include? Choose 3 answers",
    "options": {
      "A": "Ensure that the load tests validate the performance of Cloud Bigtable.",
      "B": "Create a separate Google Cloud project to use for the load-testing environment.",
      "C": "Schedule the load-testing tool to regularly run against the production environment.",
      "D": "Ensure all third-party systems your services use are capable of handling high load.",
      "E": "Instrument the production services to record every transaction for replay by the load- testing tool.",
      "F": "Instrument the load-testing tool and the target services with detailed logging and metrics collection."
    },
    "correctAnswer": [
      "A",
      "B",
      "F"
    ],
    "explanation": "Effective load testing requires: A) Testing critical components like Cloud Bigtable under load. B) Isolating the test environment in a separate project to avoid impacting production and manage costs/quotas independently. F) Comprehensive instrumentation (logging, metrics) of both the load generator and the target system (GCE, Bigtable) to analyze results and identify bottlenecks. Running against production (C) is risky. Validating third parties (D) might be out of scope. Replaying production traffic (E) can be complex and may not represent future load.",
    "conditions": [
      "Roll out load-testing tool",
      "Target: GCE services using Cloud Bigtable",
      "Goal: Test scalability"
    ],
    "caseStudyContext": null
  },
  {
    "id": 148,
    "topic": "IAM & Security",
    "question": "Your customer is moving their corporate applications to Google Cloud Platform. The security team wants detailed visibility of all projects in the organization. You provision the Google Cloud Resource Manager and set up yourself as the org admin. What Google Cloud Identity and Access Management (Cloud IAM) roles should you give to the security team'?",
    "options": {
      "A": "Org viewer, project owner",
      "B": "Org viewer, project viewer",
      "C": "Org admin, project browser",
      "D": "Project owner, network admin"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "To provide detailed visibility across all projects without granting modification rights: Grant `roles/resourcemanager.organizationViewer` at the Organization level. This allows viewing the org structure and projects. Grant `roles/viewer` (Project Viewer) at the Organization level. This role is inherited by all projects, allowing the security team to view resources and metadata within each project. This combination (B) provides the required visibility with read-only access.",
    "conditions": [
      "Customer moving apps to GCP",
      "Security team needs detailed visibility of ALL projects",
      "Org Admin already set up"
    ],
    "caseStudyContext": null
  },
  {
    "id": 149,
    "topic": "DevOps",
    "question": "Your company places a high value on being responsive and meeting customer needs quickly. Their primary business objectives are release speed and agility. You want to reduce the chance of security errors being accidentally introduced. Which two actions can you take? Choose 2 answers",
    "options": {
      "A": "Ensure every code check-in is peer reviewed by a security SME.",
      "B": "Use source code security analyzers as part of the CI/CD pipeline.",
      "C": "Ensure you have stubs to unit test all interfaces between components.",
      "D": "Enable code signing and a trusted binary repository integrated with your CI/CD pipeline.",
      "E": "Run a vulnerability security scanner as part of your continuous-integration /continuous- delivery (CI/CD) pipeline."
    },
    "correctAnswer": [
      "B",
      "E"
    ],
    "explanation": "To balance release speed with security ('Shift Left Security'), automated security testing within the CI/CD pipeline is crucial. B: Static Application Security Testing (SAST) tools analyze source code for vulnerabilities during the build phase. E: Dynamic Application Security Testing (DAST) tools or vulnerability scanners test the running application (e.g., in staging) for security flaws. Integrating these automated checks catches potential issues early without significantly slowing down the agile release process.",
    "conditions": [
      "Objectives: Release speed, agility",
      "Goal: Reduce introduction of security errors"
    ],
    "caseStudyContext": null
  },
  {
    "id": 150,
    "topic": "Compute",
    "question": "You want to enable your running Google Kubernetes Engine cluster to scale as demand for your application changes. What should you do?",
    "options": {
      "A": "Add additional nodes to your Kubernetes Engine cluster using the following command: gcloud container clusters resize CLUSTER_NAME --size 10",
      "B": "Add a tag to the instances in the cluster with the following command: gcloud compute instances add-tags INSTANCE --tags enable --autoscaling max-nodes-10",
      "C": "Update the existing Kubernetes Engine cluster with the following command: gcloud alpha container clusters update mycluster --enable-autoscaling --min-nodes=1 -- max-nodes=10",
      "D": "Create a new Kubernetes Engine cluster with the following command: gcloud alpha container clusters create mycluster --enable-autocaling --min-nodes=1 --max-nodes=10 and redeploy your application."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To enable cluster autoscaling (adding/removing nodes based on demand) on an *existing* GKE cluster, you use the `gcloud container clusters update` command with the `--enable-autoscaling` flag and specify the `--min-nodes` and `--max-nodes` limits. Option C shows the correct command structure (though `alpha` might not be strictly necessary depending on the feature status). Option A manually resizes. Option B uses incorrect tagging. Option D creates a new cluster.",
    "conditions": [
      "Running GKE cluster",
      "Enable autoscaling based on demand"
    ],
    "caseStudyContext": null
  },
  {
    "id": 151,
    "topic": "Compute",
    "question": "Your marketing department wants to send out a promotional email campaign. The development team wants to minimize direct operation management. They project a wide range of possible customer responses, from 100 to 500,000 click-throughs per day. The link leads to a simple website that explains the promotion and collects user information and preferences. Which infrastructure should you recommend? (Choose two.)",
    "options": {
      "A": "Use Google App Engine to serve the website and Google Cloud Datastore to store user data.",
      "B": "Use a Google Container Engine cluster to serve the website and store data to persistent disk.",
      "C": "Use a managed instance group to serve the website and Google Cloud Bigtable to store user data.",
      "D": "Use a single Compute Engine virtual machine (VM) to host a web server, backend by Google Cloud SQL."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "For a simple website with highly variable traffic (100 to 500k/day) and minimal operations management, App Engine Standard is ideal. It scales automatically (including to zero) and requires no server management. Cloud Datastore (Firestore in Datastore mode) is a scalable, managed NoSQL database suitable for storing user information/preferences collected by the website. GKE (B) and MIGs (C) require more operational overhead. A single VM (D) cannot handle the potential peak load.",
    "conditions": [
      "Promotional landing page/website",
      "Collects user info/preferences",
      "Minimize operations management",
      "Highly variable traffic (100 - 500,000 clicks/day)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 152,
    "topic": "Compute",
    "question": "Your company just finished a rapid lift and shift to Google Compute Engine for your compute needs. You have another 9 months to design and deploy a more cloud-native solution. Specifically, you want a system that is no-ops and auto-scaling. Which two compute products should you choose? (Choose two.)",
    "options": {
      "A": "Compute Engine with containers",
      "B": "Google Kubernetes Engine with containers",
      "C": "Google App Engine Standard Environment",
      "D": "Compute Engine with custom instance types",
      "E": "Compute Engine with managed instance groups"
    },
    "correctAnswer": [
      "B",
      "C"
    ],
    "explanation": "No-ops implies minimal infrastructure management. App Engine Standard (C) is fully managed serverless PaaS. Google Kubernetes Engine (GKE) (B) significantly reduces operational burden compared to raw VMs by managing the control plane and offering features like node auto-upgrades/repairs. Both offer robust auto-scaling. Compute Engine options (A, D, E) require more hands-on management (OS patching, instance configuration, etc.).",
    "conditions": [
      "Post lift-and-shift to GCE",
      "Need cloud-native solution",
      "Requirement: No-ops",
      "Requirement: Auto-scaling"
    ],
    "caseStudyContext": null
  },
  {
    "id": 153,
    "topic": "Security",
    "question": "One of your primary business objectives is being able to trust the data stored in your application. You want to log all changes to the application data. How can you design your logging system to verify authenticity of your logs?",
    "options": {
      "A": "Write the log concurrently in the cloud and on premises",
      "B": "Use a SQL database and limit who can modify the log table",
      "C": "Digitally sign each timestamp and log entry and store the signature",
      "D": "Create a JSON dump of each log entry and store it in Google Cloud Storage"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To verify authenticity (origin) and integrity (tamper detection) of logs, digital signatures are used. Signing each log entry (or batches of entries) with a private key allows anyone with the corresponding public key to verify that the log entry came from the expected source and has not been altered since signing. This provides strong evidence of log authenticity.",
    "conditions": [
      "Log all application data changes",
      "Need to verify authenticity of logs"
    ],
    "caseStudyContext": null
  },
  {
    "id": 154,
    "topic": "IAM & Security",
    "question": "Your company has a Google Workspace account and Google Cloud Organization. Some developers in the company have created Google Cloud projects outside of the Google Cloud Organization.\nYou want to create an Organization structure that allows developers to create projects, but prevents them from modifying production projects. You want to manage policies for all projects centrally and be able to set more restrictive policies for production projects.\nYou want to minimize disruption to users and developers when business needs change in the future. You want to follow Google-recommended practices. How should you design the Organization structure?",
    "options": {
      "A": "1, Create a second Google Workspace account and Organization. 2. Grant all developers the Project Creator IAM role on the new Organization. 3. Move the developer projects into the new Organization. 4. Set the policies for all projects on both Organizations. 5. Additionally, set the production policies on the original Organization.",
      "B": "1. Create a folder under the Organization resource named Production. 2. Grant all developers the Project Creator IAM role on the new Organization. 3. Move the developer projects into the new Organization. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the Production folder.",
      "C": "1. Create folders under the Organization resource named Development and Production. a. Grant all developers the Project Creator IAM role on the Development folder. 3. Move the developer projects into the Development folder. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the Production folder.",
      "D": "1. Designate the Organization for production projects only. 2. Ensure that developers do not have the Project Creator IAM role on the Organization. 3. Create development projects outside of the Organization using the developer Google Workspace accounts. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the individual production projects."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Use a single Organization. Create Folders for 'Development' and 'Production'. Move existing developer projects (and ensure new ones are created) into the 'Development' folder. Grant developers the `roles/resourcemanager.projectCreator` role on the 'Development' folder only. Apply baseline policies at the Org level, and stricter policies on the 'Production' folder. This structure (C) centralizes management, enforces separation, follows least privilege, and uses the recommended hierarchy.",
    "conditions": [
      "Existing Google Workspace and Org",
      "Some developer projects outside Org",
      "Allow developers project creation (only in Dev)",
      "Prevent developer access to Prod",
      "Central policy management",
      "Restrictive policies for Prod",
      "Minimize future disruption",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 155,
    "topic": "Operations",
    "question": "Your company has an application running on Compute Engine that allows users to play their favorite music. There are a fixed number of instances. Files are stored in Cloud Storage, and data is streamed directly to users. Users are reporting that they sometimes need to attempt to play popular songs multiple times before they are successful. You need to improve the performance of the application. What should you do?",
    "options": {
      "A": "1. Mount the Cloud Storage bucket using gcsfuse on all backend Compute Engine instances. 2. Serve music files directly from the backend Compute Engine instance.",
      "B": "1. Create a Cloud Filestore NFS volume and attach it to the backend Compute Engine instances. 2. Download popular songs in Cloud Filestore. 3. Serve music files directly from the backend Compute Engine instance.",
      "C": "1. Copy popular songs into CloudSQL as a blob. 2. Update application code to retrieve data from CloudSQL when Cloud Storage is overloaded.",
      "D": "1. Create a managed instance group with Compute Engine instances. 2. Create a global load balancer and configure it with two backends:\n  Managed instance group\n  Cloud Storage bucket\n3. Enable Cloud CDN on the bucket backend."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Failures on popular songs indicate a performance bottleneck, likely with serving content from GCS or the fixed instances under load. Option D provides a comprehensive solution: Use a MIG for scalable application instances. Use a Global Load Balancer to distribute traffic. Configure the GCS bucket as a backend *and* enable Cloud CDN. The CDN caches popular songs globally, reducing latency and load on GCS, while the MIG allows the application tier to scale.",
    "conditions": [
      "Music streaming app on fixed GCE instances",
      "Files in GCS, streamed directly",
      "Intermittent failures playing popular songs",
      "Need performance improvement"
    ],
    "caseStudyContext": null
  },
  {
    "id": 156,
    "topic": "Networking",
    "question": "The operations team in your company wants to save Cloud VPN log events for one year. You need to configure the cloud infrastructure to save the logs. What should you do?",
    "options": {
      "A": "Set up a filter in Cloud Logging and a Cloud Storage bucket as an export target for the logs you want to save.",
      "B": "Enable the Compute Engine API, and then enable logging on the firewall rules that match the traffic you want to save.",
      "C": "Set up a Cloud Logging Dashboard titled Cloud VPN Logs, and then add a chart that queries for the VPN metrics over a one-year time period.",
      "D": "Set up a filter in Cloud Logging and a topic in Pub/Sub to publish the logs."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Cloud Logging has default retention periods shorter than one year. To retain logs longer, you must export them using a log sink. Creating a sink that filters for Cloud VPN logs (`resource.type=\"vpn_tunnel\"`) and exports them to a Cloud Storage bucket (A) is the standard and cost-effective method for long-term archival.",
    "conditions": [
      "Save Cloud VPN logs for 1 year"
    ],
    "caseStudyContext": null
  },
  {
    "id": 157,
    "topic": "Data Processing",
    "question": "You are working with a data warehousing team that performs data analysis. The team needs to process data from external partners, but the data contains personally identifiable information (PII). You need to process and store the data without storing any of the PII data. What should you do?",
    "options": {
      "A": "Create a Dataflow pipeline to retrieve the data from the external sources. As part of the pipeline, use the Cloud Data Loss Prevention (Cloud DLP) API to remove any Pll data. Store the result in BigQuery.",
      "B": "Create a Dataflow pipeline to retrieve the data from the external sources. As part of the pipeline, store all non-Pll data in BigQuery and store all Pll data in a Cloud Storage bucket that has a retention policy set.",
      "C": "Ask the external partners to upload all data on Cloud Storage. Configure Bucket Lock for the bucket. Create a Dataflow pipeline to read the data from the bucket. As part of the pipeline, use the Cloud Data Loss Prevention (Cloud DLP) API to remove any Pll data. Store the result in BigQuery.",
      "D": "Ask the external partners to import all data in your BigQuery dataset. Create a dataflow pipeline to copy the data into a new table. As part of the Dataflow bucket, skip all data in columns that have Pll data"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The requirement is to process data and store it *without* the PII. The best approach is to sanitize the data during the ingestion/processing pipeline *before* it lands in the final storage (BigQuery). Using a Dataflow pipeline to retrieve data and incorporating the Cloud DLP API within the pipeline to detect and remove/mask/tokenize PII (A) ensures that only de-identified data reaches BigQuery.",
    "conditions": [
      "Process external partner data containing PII",
      "Store processed data without PII"
    ],
    "caseStudyContext": null
  },
  {
    "id": 158,
    "topic": "Operations",
    "question": "You want to allow your operations team to store logs from all the production projects in your Organization, without including logs from other projects. All of the production projects are contained in a folder. You want to ensure that all logs for existing and new production projects are captured automatically. What should you do?",
    "options": {
      "A": "Create an aggregated export on the Production folder. Set the log sink to be a Cloud Storage bucket in an operations project.",
      "B": "Create an aggregated export on the Organization resource. Set the log sink to be a Cloud Storage bucket in an operations project.",
      "C": "Create log exports in the production projects. Set the log sinks to be a Cloud Storage bucket in an operations project.",
      "D": "Create log exports in the production projects. Set the log sinks to be BigQuery datasets in the production projects, and grant IAM access to the operations team to run queries on the datasets."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Aggregated Sinks in Cloud Logging can collect logs from all projects within a specified Folder or Organization. Creating an aggregated sink at the 'Production' Folder level (A) ensures that logs from all current and future projects placed in that folder are automatically exported to the designated destination (e.g., a GCS bucket in a central operations project). This meets the requirements for automatic capture and scope limitation.",
    "conditions": [
      "Collect logs from all Production projects only",
      "Production projects are within a specific Folder",
      "Automatically capture logs from existing and new Production projects",
      "Store logs centrally"
    ],
    "caseStudyContext": null
  },
  {
    "id": 159,
    "topic": "Operations",
    "question": "Your company has an application running on multiple instances of Compute Engine. It generates 1 TB per day of logs. For compliance reasons, the logs need to be kept for at least two years. The logs need to be available for active query for 30 days. After that, they just need to be retained for audit purposes. You want to implement a storage solution that is compliant, minimizes costs, and follows Google-recommended practices. What should you do?",
    "options": {
      "A": "1, Install a Cloud Logging agent on all instances. 2. Create a sink to export logs into a regional Cloud Storage bucket. 3. Create an Object Lifecycle rule to move files into a Coldline Cloud Storage bucket after one month. 4. Configure a retention policy at the bucket level using bucket lock.",
      "B": "1. Write a daily cron job, running on all instances, that uploads logs into a Cloud Storage bucket. 2. Create a sink to export logs into a regional Cloud Storage bucket. 3. Create an Object Lifecycle rule to move files into a Coldline Cloud Storage bucket after one month.",
      "C": "1. Install a Cloud Logging agent on all instances. 2. Create a sink to export logs into a partitioned BigQuery table. 3. Set a time_partitioning_expiration of 30 days.",
      "D": "1. Create a daily cron job, running on all instances, that uploads logs into a partitioned BigQuery table. 2. Set a time_partitioning_expiration of 30 days."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "1. Use Cloud Logging agent for reliable collection. 2. Export logs via sink to Cloud Storage for long-term, cost-effective storage. 3. Use Object Lifecycle rules to transition data to cheaper storage (e.g., Nearline/Coldline/Archive) after 30 days of active query need. 4. Apply a Bucket Retention Policy (potentially locked) for the required 2-year compliance period to prevent premature deletion. Option A combines these elements. BigQuery expiration (C, D) would delete logs after 30 days. Cron jobs (B, D) are less reliable than the agent.",
    "conditions": [
      "1 TB logs/day from GCE instances",
      "Retain >= 2 years (compliance)",
      "Active query for 30 days",
      "Retain for audit after 30 days",
      "Compliant, cost-minimized, recommended solution"
    ],
    "caseStudyContext": null
  },
  {
    "id": 160,
    "topic": "IAM & Security",
    "question": "Your company has just recently activated Cloud Identity to manage users. The Google Cloud Organization has been configured as well. The security team needs to secure projects that will be part of the Organization. They want to prohibit IAM users outside the domain from gaining permissions from now on. What should they do?",
    "options": {
      "A": "Configure an organization policy to restrict identities by domain.",
      "B": "Configure an organization policy to block creation of service accounts.",
      "C": "Configure Cloud Scheduler to trigger a Cloud Function every hour that removes all users that don't belong to the Cloud Identity domain from all projects.",
      "D": "Create a technical user (e.g., crawler@yourdomain.com), and give it the project owner role at root organization level. Write a bash script that: Lists all the IAM rules of all projects within the organization. Deletes all users that do not belong to the company domain. Create a Compute Engine instance in a project within the Organization and configure gcloud to be executed with technical user credentials. Configure a cron job that executes the bash script every hour."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Organization Policies provide centralized control. The `constraints/iam.allowedPolicyMemberDomains` constraint allows you to specify which Cloud Identity/Workspace domains are allowed in IAM policies. Enforcing this at the Organization level prevents granting permissions to users from any other domain.",
    "conditions": [
      "Cloud Identity & Org configured",
      "Secure projects within Org",
      "Prohibit granting IAM permissions to external users"
    ],
    "caseStudyContext": null
  },
  {
    "id": 161,
    "topic": "Databases",
    "question": "Your company has an application running on Google Cloud that is collecting data from thousands of physical devices that are globally distributed. Data is published to Pub/Sub and streamed in real time into an SSD Cloud Bigtable cluster via a Dataflow pipeline. The operations team informs you that your Cloud Bigtable cluster has a hotspot, and queries are taking longer than expected. You need to resolve the problem and prevent it from happening in the future. What should you do?",
    "options": {
      "A": "Advise your clients to use HBase APIs instead of NodeJS APIs.",
      "B": "Delete records older than 30 days.",
      "C": "Review your RowKey strategy and ensure that keys are evenly spread across the alphabet.",
      "D": "Double the number of nodes you currently have."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Hotspotting in Bigtable occurs when reads/writes concentrate on a narrow range of row keys, overwhelming specific nodes. This is almost always caused by poorly designed row keys (e.g., sequential timestamps, device IDs at the start). The primary solution is to review and redesign the row key strategy (C) to distribute keys evenly across the keyspace (e.g., using reversed domain names, hashing, salting). Changing APIs (A), deleting data (B), or adding nodes (D) doesn't fix the underlying poor key design.",
    "conditions": [
      "Data flow: Devices -> Pub/Sub -> Dataflow -> Bigtable (SSD)",
      "Problem: Bigtable hotspotting, slow queries",
      "Need to resolve and prevent future hotspots"
    ],
    "caseStudyContext": null
  },
  {
    "id": 162,
    "topic": "Data Analytics",
    "question": "Your BigQuery project has several users. For audit purposes, you need to see how many queries each user ran in the last month. What should you do?",
    "options": {
      "A": "Connect Google Data Studio to BigQuery. Create a dimension for the users and a metric for the amount of queries per user.",
      "B": "In the BigQuery interface, execute a query on the JOBS table to get the required information.",
      "C": "Use 'bq show ' to list all jobs. Per job, use ‘bq ls’ to list job information and get the required information.",
      "D": "Use Cloud Audit Logging to view Cloud Audit Logs, and create a filter on the query operation to get the required information."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "BigQuery automatically records metadata about all executed jobs (including queries) in `INFORMATION_SCHEMA` views. Querying views like `INFORMATION_SCHEMA.JOBS_BY_USER` or `JOBS_BY_PROJECT` using SQL allows filtering by user email and creation time to count queries executed within the last month (B). This is the standard and most direct method for this type of audit.",
    "conditions": [
      "BigQuery project, multiple users",
      "Audit: Count queries per user in last month"
    ],
    "caseStudyContext": null
  },
  {
    "id": 163,
    "topic": "Storage",
    "question": "Your company wants to migrate their 10-TB on-premises database export into Cloud Storage. You want to minimize the time it takes to complete this activity, the overall cost, and database load. The bandwidth between the on-premises environment and Google Cloud is 1 Gbps. You want to follow Google-recommended practices. What should you do?",
    "options": {
      "A": "Develop a Dataflow job to read data directly from the database and write it into Cloud Storage.",
      "B": "Use the Data Transfer appliance to perform an offline migration.",
      "C": "Use a commercial partner ETL solution to extract the data from the on-premises database and upload it into Cloud Storage.",
      "D": "Compress the data and upload it with gsutil -m to enable multi-threaded copy."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "A 1 Gbps link can transfer 10 TB in roughly a day, which is feasible. Compressing the data reduces transfer size, and using `gsutil -m` enables parallel uploads, maximizing the 1 Gbps bandwidth and minimizing transfer time (D). This method uses standard tools and works on an existing export file, avoiding extra DB load. Transfer Appliance (B) is overkill. Dataflow (A) or ETL (C) add unnecessary complexity for transferring a file.",
    "conditions": [
      "Migrate 10 TB on-prem DB export to GCS",
      "Minimize time, cost, DB load",
      "1 Gbps bandwidth",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 164,
    "topic": "Compute",
    "question": "Your company just finished a rapid lift and shift to Google Compute Engine for your compute needs. You have another 9 months to design and deploy a more cloud-native solution. Specifically, you want a system that is no-ops and auto-scaling.\nWhich two compute products should you choose? (Choose two.)",
    "options": {
      "A": "Compute Engine with containers",
      "B": "Google Kubernetes Engine with containers",
      "C": "Google App Engine Standard Environment",
      "D": "Compute Engine with custom instance types",
      "E": "Compute Engine with managed instance groups"
    },
    "correctAnswer": [
      "B",
      "C"
    ],
    "explanation": "No-ops and auto-scaling point towards managed and serverless platforms. App Engine Standard (C) is fully managed PaaS that autoscales seamlessly. Google Kubernetes Engine (GKE) (B) is a managed container orchestrator that handles control plane management and offers robust autoscaling for both pods and nodes, significantly reducing ops compared to raw VMs. Compute Engine options (A, D, E) require more operational overhead.",
    "conditions": [
      "Post lift-and-shift to GCE",
      "Need cloud-native solution",
      "Requirement: No-ops",
      "Requirement: Auto-scaling"
    ],
    "caseStudyContext": null
  },
  {
    "id": 165,
    "topic": "Security",
    "question": "One of your primary business objectives is being able to trust the data stored in your application. You want to log all changes to the application data.\nHow can you design your logging system to verify authenticity of your logs?",
    "options": {
      "A": "Write the log concurrently in the cloud and on premises",
      "B": "Use a SQL database and limit who can modify the log table",
      "C": "Digitally sign each timestamp and log entry and store the signature",
      "D": "Create a JSON dump of each log entry and store it in Google Cloud Storage"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Digital signatures provide cryptographic proof of authenticity (origin) and integrity (tamper-evidence). By signing each log entry (or batches) with a private key, anyone with the public key can verify that the log originated from the expected source and hasn't been altered.",
    "conditions": [
      "Log application data changes",
      "Verify authenticity of logs"
    ],
    "caseStudyContext": null
  },
  {
    "id": 166,
    "topic": "IAM & Security",
    "question": "Your company has a Google Workspace account and Google Cloud Organization. Some developers in the company have created Google Cloud projects outside of the Google Cloud Organization.\nYou want to create an Organization structure that allows developers to create projects, but prevents them from modifying production projects. You want to manage policies for all projects centrally and be able to set more restrictive policies for production projects.\nYou want to minimize disruption to users and developers when business needs change in the future. You want to follow Google-recommended practices. How should you design the Organization structure?",
    "options": {
      "A": "1, Create a second Google Workspace account and Organization. 2. Grant all developers the Project Creator IAM role on the new Organization. 3. Move the developer projects into the new Organization. 4. Set the policies for all projects on both Organizations. 5. Additionally, set the production policies on the original Organization.",
      "B": "1. Create a folder under the Organization resource named Production. 2. Grant all developers the Project Creator IAM role on the new Organization. 3. Move the developer projects into the new Organization. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the Production folder.",
      "C": "1. Create folders under the Organization resource named Development and Production. a. Grant all developers the Project Creator IAM role on the Development folder. 3. Move the developer projects into the Development folder. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the Production folder.",
      "D": "1. Designate the Organization for production projects only. 2. Ensure that developers do not have the Project Creator IAM role on the Organization. 3. Create development projects outside of the Organization using the developer Google Workspace accounts. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the individual production projects."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The recommended practice is to use a single Organization with Folders for environment separation ('Development', 'Production'). Migrate existing projects. Grant developers `roles/resourcemanager.projectCreator` only on the 'Development' folder. Apply Org-level baseline policies and stricter policies on the 'Production' folder. This centralizes management, provides isolation, follows least privilege, and uses the intended hierarchy.",
    "conditions": [
      "Existing Google Workspace & Org",
      "Some dev projects outside Org",
      "Allow dev project creation (only in Dev)",
      "Prevent dev modification of Prod",
      "Central policy management",
      "Restrictive policies for Prod",
      "Minimize future disruption",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 167,
    "topic": "Compute",
    "question": "You want to enable your running Google Kubernetes Engine cluster to scale as demand for your application changes. What should you do?",
    "options": {
      "A": "Add additional nodes to your Kubernetes Engine cluster using the following command: gcloud container clusters resize CLUSTER_Name --size 10",
      "B": "Add a tag to the instances in the cluster with the following command: gcloud compute instances add-tags INSTANCE --tags enable --autoscaling max-nodes-10",
      "C": "Update the existing Kubernetes Engine cluster with the following command: gcloud alpha container clusters update mycluster --enable-autoscaling --min-nodes=1 -- max-nodes=10",
      "D": "Create a new Kubernetes Engine cluster with the following command: gcloud alpha container clusters create mycluster --enable-autocaling --min-nodes=1 --max-nodes=10 and redeploy your application."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To enable Cluster Autoscaler on an existing GKE cluster, use the `gcloud container clusters update` command with the `--enable-autoscaling` flag, specifying `--min-nodes` and `--max-nodes` limits. This allows the cluster to automatically add or remove nodes based on pod scheduling demands.",
    "conditions": [
      "Running GKE cluster",
      "Enable autoscaling based on demand"
    ],
    "caseStudyContext": null
  },
  {
    "id": 168,
    "topic": "Compute",
    "question": "Your marketing department wants to send out a promotional email campaign. The development team wants to minimize direct operation management. They project a wide range of possible customer responses, from 100 to 500,000 click-throughs per day. The link leads to a simple website that explains the promotion and collects user information and preferences. Which infrastructure should you recommend? (Choose two.)",
    "options": {
      "A": "Use Google App Engine to serve the website and Google Cloud Datastore to store user data.",
      "B": "Use a Google Container Engine cluster to serve the website and store data to persistent disk.",
      "C": "Use a managed instance group to serve the website and Google Cloud Bigtable to store user data.",
      "D": "Use a single Compute Engine virtual machine (VM) to host a web server, backend by Google Cloud SQL."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "App Engine Standard is fully managed, scales automatically (including to zero), minimizing ops and handling wide traffic variance. Cloud Datastore (Firestore in Datastore mode) is a managed, scalable NoSQL database suitable for storing user info collected from the site. This combination (A) fits the requirements best. GKE (B) and MIGs (C) require more ops. Single VM (D) won't scale. Bigtable (C) is overkill for user preferences.",
    "conditions": [
      "Promotional landing page/website",
      "Collects user info/preferences",
      "Minimize operations management",
      "Highly variable traffic (100 - 500k/day)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 169,
    "topic": "Compute",
    "question": "Your company just finished a rapid lift and shift to Google Compute Engine for your compute needs. You have another 9 months to design and deploy a more cloud-native solution. Specifically, you want a system that is no-ops and auto-scaling. Which two compute products should you choose? (Choose two.)",
    "options": {
      "A": "Compute Engine with containers",
      "B": "Google Kubernetes Engine with containers",
      "C": "Google App Engine Standard Environment",
      "D": "Compute Engine with custom instance types",
      "E": "Compute Engine with managed instance groups"
    },
    "correctAnswer": [
      "B",
      "C"
    ],
    "explanation": "No-ops and auto-scaling point towards managed and serverless platforms. App Engine Standard (C) is fully managed PaaS. GKE (B) offers managed container orchestration with reduced operational overhead compared to VMs. Both provide robust autoscaling. GCE options (A, D, E) involve more infrastructure management.",
    "conditions": [
      "Post lift-and-shift to GCE",
      "Need cloud-native solution",
      "Requirement: No-ops",
      "Requirement: Auto-scaling"
    ],
    "caseStudyContext": null
  },
  {
    "id": 170,
    "topic": "Security",
    "question": "One of your primary business objectives is being able to trust the data stored in your application. You want to log all changes to the application data. How can you design your logging system to verify authenticity of your logs?",
    "options": {
      "A": "Write the log concurrently in the cloud and on premises",
      "B": "Use a SQL database and limit who can modify the log table",
      "C": "Digitally sign each timestamp and log entry and store the signature",
      "D": "Create a JSON dump of each log entry and store it in Google Cloud Storage"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Digital signatures provide cryptographic proof of authenticity and integrity. Signing log entries (C) ensures that their origin can be verified and that any tampering after signing can be detected.",
    "conditions": [
      "Log application data changes",
      "Verify log authenticity"
    ],
    "caseStudyContext": null
  },
  {
    "id": 171,
    "topic": "IAM & Security",
    "question": "Your company has a Google Workspace account and Google Cloud Organization. Some developers in the company have created Google Cloud projects outside of the Google Cloud Organization.\nYou want to create an Organization structure that allows developers to create projects, but prevents them from modifying production projects. You want to manage policies for all projects centrally and be able to set more restrictive policies for production projects.\nYou want to minimize disruption to users and developers when business needs change in the future. You want to follow Google-recommended practices. How should you design the Organization structure?",
    "options": {
      "A": "1, Create a second Google Workspace account and Organization. 2. Grant all developers the Project Creator IAM role on the new Organization. 3. Move the developer projects into the new Organization. 4. Set the policies for all projects on both Organizations. 5. Additionally, set the production policies on the original Organization.",
      "B": "1. Create a folder under the Organization resource named Production. 2. Grant all developers the Project Creator IAM role on the new Organization. 3. Move the developer projects into the new Organization. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the Production folder.",
      "C": "1. Create folders under the Organization resource named Development and Production. a. Grant all developers the Project Creator IAM role on the Development folder. 3. Move the developer projects into the Development folder. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the Production folder.",
      "D": "1. Designate the Organization for production projects only. 2. Ensure that developers do not have the Project Creator IAM role on the Organization. 3. Create development projects outside of the Organization using the developer Google Workspace accounts. 4. Set the policies for all projects on the Organization. 5. Additionally, set the production policies on the individual production projects."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Use a single Org. Create Folders for 'Development' and 'Production'. Grant Project Creator role on the 'Development' folder only. Set Org-level baseline policies and stricter 'Production' folder policies (C). This follows best practices for hierarchy, central management, and least privilege.",
    "conditions": [
      "Existing Org & Workspace",
      "Dev projects outside Org",
      "Allow dev project creation in Dev only",
      "Prevent dev access to Prod",
      "Central/restrictive policies",
      "Minimize disruption",
      "Follow Google practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 172,
    "topic": "Compute",
    "question": "Your company has an application running on Compute Engine that allows users to play their favorite music. There are a fixed number of instances. Files are stored in Cloud Storage, and data is streamed directly to users. Users are reporting that they sometimes need to attempt to play popular songs multiple times before they are successful. You need to improve the performance of the application. What should you do?",
    "options": {
      "A": "1. Mount the Cloud Storage bucket using gcsfuse on all backend Compute Engine instances. 2. Serve music files directly from the backend Compute Engine instance.",
      "B": "1. Create a Cloud Filestore NFS volume and attach it to the backend Compute Engine instances. 2. Download popular songs in Cloud Filestore. 3. Serve music files directly from the backend Compute Engine instance.",
      "C": "1. Copy popular songs into CloudSQL as a blob. 2. Update application code to retrieve data from CloudSQL when Cloud Storage is overloaded.",
      "D": "1. Create a managed instance group with Compute Engine instances. 2. Create a global load balancer and configure it with two backends:\n  Managed instance group\n  Cloud Storage bucket\n3. Enable Cloud CDN on the bucket backend."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Failures on popular songs suggest bottlenecks. Option D provides scalability (MIG), global distribution (Global LB), and caching for popular content (GCS backend + Cloud CDN), addressing potential bottlenecks at the instance, network, and storage layers.",
    "conditions": [
      "Music streaming app, fixed GCE instances",
      "Files in GCS, streamed directly",
      "Intermittent failures for popular songs",
      "Improve performance"
    ],
    "caseStudyContext": null
  },
  {
    "id": 173,
    "topic": "Networking",
    "question": "The operations team in your company wants to save Cloud VPN log events for one year. You need to configure the cloud infrastructure to save the logs. What should you do?",
    "options": {
      "A": "Set up a filter in Cloud Logging and a Cloud Storage bucket as an export target for the logs you want to save.",
      "B": "Enable the Compute Engine API, and then enable logging on the firewall rules that match the traffic you want to save.",
      "C": "Set up a Cloud Logging Dashboard titled Cloud VPN Logs, and then add a chart that queries for the VPN metrics over a one-year time period.",
      "D": "Set up a filter in Cloud Logging and a topic in Pub/Sub to publish the logs."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To retain logs beyond the default Cloud Logging retention period, configure a log sink to export them. For long-term archival (1 year) at low cost, exporting filtered Cloud VPN logs to a Cloud Storage bucket (A) is the recommended approach.",
    "conditions": [
      "Save Cloud VPN logs for 1 year"
    ],
    "caseStudyContext": null
  },
  {
    "id": 174,
    "topic": "Data Processing",
    "question": "You are working with a data warehousing team that performs data analysis. The team needs to process data from external partners, but the data contains personally identifiable information (PII). You need to process and store the data without storing any of the PII data. What should you do?",
    "options": {
      "A": "Create a Dataflow pipeline to retrieve the data from the external sources. As part of the pipeline, use the Cloud Data Loss Prevention (Cloud DLP) API to remove any Pll data. Store the result in BigQuery.",
      "B": "Create a Dataflow pipeline to retrieve the data from the external sources. As part of the pipeline, store all non-Pll data in BigQuery and store all Pll data in a Cloud Storage bucket that has a retention policy set.",
      "C": "Ask the external partners to upload all data on Cloud Storage. Configure Bucket Lock for the bucket. Create a Dataflow pipeline to read the data from the bucket. As part of the pipeline, use the Cloud Data Loss Prevention (Cloud DLP) API to remove any Pll data. Store the result in BigQuery.",
      "D": "Ask the external partners to import all data in your BigQuery dataset. Create a dataflow pipeline to copy the data into a new table. As part of the Dataflow bucket, skip all data in columns that have Pll data"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The requirement is to process data and store the result without PII. Using a Dataflow pipeline to ingest the data and incorporating the Cloud DLP API within the pipeline (A) allows detection and de-identification (removal, masking, etc.) of PII *during* processing, before the sanitized data is written to BigQuery.",
    "conditions": [
      "Process external data containing PII",
      "Store processed data *without* PII"
    ],
    "caseStudyContext": null
  },
  {
    "id": 175,
    "topic": "Operations",
    "question": "You want to allow your operations team to store logs from all the production projects in your Organization, without including logs from other projects. All of the production projects are contained in a folder. You want to ensure that all logs for existing and new production projects are captured automatically. What should you do?",
    "options": {
      "A": "Create an aggregated export on the Production folder. Set the log sink to be a Cloud Storage bucket in an operations project.",
      "B": "Create an aggregated export on the Organization resource. Set the log sink to be a Cloud Storage bucket in an operations project.",
      "C": "Create log exports in the production projects. Set the log sinks to be a Cloud Storage bucket in an operations project.",
      "D": "Create log exports in the production projects. Set the log sinks to be BigQuery datasets in the production projects, and grant IAM access to the operations team to run queries on the datasets."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Creating an aggregated sink at the 'Production' Folder level (A) ensures logs from all current and future projects within that specific folder are automatically exported to the central destination, meeting all requirements efficiently.",
    "conditions": [
      "Collect logs only from Production projects",
      "Prod projects within a specific Folder",
      "Automatic capture for existing/new Prod projects",
      "Central log storage"
    ],
    "caseStudyContext": null
  },
  {
    "id": 176,
    "topic": "Operations",
    "question": "Your company has an application running on multiple instances of Compute Engine. It generates 1 TB per day of logs. For compliance reasons, the logs need to be kept for at least two years. The logs need to be available for active query for 30 days. After that, they just need to be retained for audit purposes. You want to implement a storage solution that is compliant, minimizes costs, and follows Google-recommended practices. What should you do?",
    "options": {
      "A": "1, Install a Cloud Logging agent on all instances. 2. Create a sink to export logs into a regional Cloud Storage bucket. 3. Create an Object Lifecycle rule to move files into a Coldline Cloud Storage bucket after one month. 4. Configure a retention policy at the bucket level using bucket lock.",
      "B": "1. Write a daily cron job, running on all instances, that uploads logs into a Cloud Storage bucket. 2. Create a sink to export logs into a regional Cloud Storage bucket. 3. Create an Object Lifecycle rule to move files into a Coldline Cloud Storage bucket after one month.",
      "C": "1. Install a Cloud Logging agent on all instances. 2. Create a sink to export logs into a partitioned BigQuery table. 3. Set a time_partitioning_expiration of 30 days.",
      "D": "1. Create a daily cron job, running on all instances, that uploads logs into a partitioned BigQuery table. 2. Set a time_partitioning_expiration of 30 days."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Use agent for collection. Export logs to GCS for long-term storage. Use lifecycle rules to move data to Coldline after 30 days for cost savings. Apply a 2-year bucket retention policy (with lock for compliance) to ensure data isn't deleted prematurely (A). BigQuery expiration (C, D) deletes data too soon. Cron jobs (B, D) are less reliable.",
    "conditions": [
      "1 TB logs/day from GCE",
      "Retain >= 2 years",
      "Active query for 30 days",
      "Audit retention after 30 days",
      "Compliant, cost-minimized, recommended solution"
    ],
    "caseStudyContext": null
  },
  {
    "id": 177,
    "topic": "IAM & Security",
    "question": "Your company has just recently activated Cloud Identity to manage users. The Google Cloud Organization has been configured as well. The security team needs to secure projects that will be part of the Organization. They want to prohibit IAM users outside the domain from gaining permissions from now on. What should they do?",
    "options": {
      "A": "Configure an organization policy to restrict identities by domain.",
      "B": "Configure an organization policy to block creation of service accounts.",
      "C": "Configure Cloud Scheduler to trigger a Cloud Function every hour that removes all users that don't belong to the Cloud Identity domain from all projects.",
      "D": "Create a technical user (e.g., crawler@yourdomain.com), and give it the project owner role at root organization level. Write a bash script that: a€¢ Lists all the IAM rules of all projects within the organization. a€¢ Deletes all users that do not belong to the company domain. Create a Compute Engine instance in a project within the Organization and configure gcloud to be executed with technical user credentials. Configure a cron job that executes the bash script every hour."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Use the Organization Policy constraint `constraints/iam.allowedPolicyMemberDomains` at the Organization level (A). Specify your company's Cloud Identity domain ID. This prevents granting IAM roles to any user identity outside that domain.",
    "conditions": [
      "Cloud Identity & Org configured",
      "Secure projects within Org",
      "Prohibit granting IAM permissions to external users"
    ],
    "caseStudyContext": null
  },
  {
    "id": 178,
    "topic": "Databases",
    "question": "Your company has an application running on Google Cloud that is collecting data from thousands of physical devices that are globally distributed. Data is published to Pub/Sub and streamed in real time into an SSD Cloud Bigtable cluster via a Dataflow pipeline. The operations team informs you that your Cloud Bigtable cluster has a hotspot, and queries are taking longer than expected. You need to resolve the problem and prevent it from happening in the future. What should you do?",
    "options": {
      "A": "Advise your clients to use HBase APIs instead of NodeJS APIs.",
      "B": "Delete records older than 30 days.",
      "C": "Review your RowKey strategy and ensure that keys are evenly spread across the alphabet.",
      "D": "Double the number of nodes you currently have."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Bigtable hotspotting is caused by non-uniform access patterns, usually due to poor row key design. Reviewing and redesigning the row key (C) to ensure writes/reads are distributed across all nodes (e.g., hashing prefixes, reversing domains) is the fundamental fix.",
    "conditions": [
      "Data flow: Devices -> Pub/Sub -> Dataflow -> Bigtable",
      "Problem: Bigtable hotspotting, slow queries",
      "Resolve and prevent recurrence"
    ],
    "caseStudyContext": null
  },
  {
    "id": 179,
    "topic": "Data Analytics",
    "question": "Your BigQuery project has several users. There are some tables that contain personally identifiable information (Pll). Only the compliance team may access the PII. The other information in the tables must be available to the data science team. You want to minimize cost and the time it takes to assign appropriate access to the tables. What should you do?",
    "options": {
      "A": "1. From the dataset where you have the source data, create views of tables that you want to share, excluding Pll. 2. Assign an appropriate project-level IAM role to the members of the data science team. 3. Assign access controls to the dataset that contains the view.",
      "B": "1. From the dataset where you have the source data, create materialized views of tables that you want to share, excluding Pll. 2. Assign an appropriate project-level IAM role to the members of the data science team. 3. Assign access controls to the dataset that contains the view.",
      "C": "1. Create a dataset for the data science team. 2. Create views of tables that you want to share, excluding Pll. 3. Assign an appropriate project-level IAM role to the members of the data science team. 4. Assign access controls to the dataset that contains the view. 5. Authorize the view to access the source dataset.",
      "D": "1. Create a dataset for the data science team. 2. Create materialized views of tables that you want to share, excluding PII. 3. Assign an appropriate project-level IAM role to the members of the data science team. 4. Assign access controls to the dataset that contains the view. Authorize the view to access the source dataset."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Use Authorized Views. Create a separate dataset for data science. Create views in this dataset selecting only non-PII columns from the source tables. Grant the data science team access to this *view dataset*. Authorize the views themselves to access the underlying source dataset (C). This provides access control without duplicating data (unlike materialized views B, D) and avoids broad project-level roles (A).",
    "conditions": [
      "BQ tables with PII",
      "Compliance team: full access",
      "Data science team: non-PII access only",
      "Minimize cost and setup time"
    ],
    "caseStudyContext": null
  },
  {
    "id": 180,
    "topic": "Storage",
    "question": "Your operations team currently stores 10 TB of data m an object storage service from a third-party provider. They want to move this data to a Cloud Storage bucket as quickly as possible, following Google-recommended practices. They want to minimize the cost of this data migration. When approach should they use?",
    "options": {
      "A": "Use the gsutil mv command lo move the data",
      "B": "Use the Storage Transfer Service to move the data",
      "C": "Download the data to a Transfer Appliance and ship it to Google",
      "D": "Download the data to the on-premises data center and upload it to the Cloud Storage bucket"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Storage Transfer Service is designed for transferring large amounts of data *into* Cloud Storage from other cloud providers (like AWS S3, Azure Blob) or HTTP sources. It manages parallelism and retries, typically making it faster and more cost-effective (avoids double bandwidth charges compared to D) for cloud-to-cloud transfers than manual methods like gsutil or offline methods like Transfer Appliance (C) which is for on-prem sources.",
    "conditions": [
      "10 TB data in third-party object storage",
      "Move to GCS bucket",
      "Quickly, follow recommendations, minimize cost"
    ],
    "caseStudyContext": null
  },
  {
    "id": 181,
    "topic": "Compute",
    "question": "You have a Compute Engine managed instance group that adds and removes Compute Engine instances from the group in response to the load of your application. The instances have a shutdown script that removes REDIS database entries associated with the instance. You see that many database entries have not been removed, and you suspect that the shutdown script is the problem. You need to ensure that the commands in the shutdown script are run reliably every time an instance is shut down. You create a Cloud Function to remove the database entries. What should you do next?",
    "options": {
      "A": "Modify the shutdown script to wait for 30 seconds before triggering the Cloud Function.",
      "B": "Do not use the Cloud Function. Modify the shutdown script to restart if it has not completed in 30 seconds.",
      "C": "Set up a Cloud Monitoring sink that triggers the Cloud Function after an instance removal log message arrives in Cloud Logging.",
      "D": "Modify the shutdown script to wait for 30 seconds and then publish a message to a Pub/Sub queue."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Shutdown scripts are unreliable. A better approach is to trigger the cleanup Cloud Function based on the instance deletion event itself. Configure a Cloud Logging sink to filter for instance deletion logs and send them to Pub/Sub (or trigger the function directly). This ensures the cleanup logic runs reliably *after* the instance deletion process starts, independent of the shutdown script's success.",
    "conditions": [
      "Autoscaled MIG",
      "Unreliable shutdown script for Redis cleanup",
      "Need reliable cleanup",
      "Cloud Function created for cleanup"
    ],
    "caseStudyContext": null
  },
  {
    "id": 182,
    "topic": "Compute",
    "question": "You are managing several projects on Google Cloud and need to interact on a daily basis with BigQuery, Bigtable, and Kubernetes Engine using the gcloud CLI tool. You are travelling a lot and work on different workstations during the week. You want to avoid having to manage the gcloud CLI manually. What should you do?",
    "options": {
      "A": "Use Google Cloud Shell in the Google Cloud Console to interact with Google Cloud.",
      "B": "Create a Compute Engine instance and install gcloud on the instance. Connect to this instance via SSH to always use the same gcloud installation when interacting with Google Cloud.",
      "C": "Install gcloud on all of your workstations. Run the command gcloud components auto-update on each workstation",
      "D": "Use a package manager to install gcloud on your workstations instead of installing it manually."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Cloud Shell provides a web-based, pre-authenticated terminal with gcloud, kubectl, bq, etc., already installed and updated. It's accessible from any browser, eliminating the need to install/manage gcloud on multiple workstations.",
    "conditions": [
      "Manage multiple GCP projects",
      "Daily gcloud use (BQ, BT, GKE)",
      "Use different workstations",
      "Avoid manual gcloud management"
    ],
    "caseStudyContext": null
  },
  {
    "id": 183,
    "topic": "Networking",
    "question": "Your company recently acquired a company that has infrastructure in Google Cloud. Each company has its own Google Cloud organization Each company is using a Shared Virtual Private Cloud (VPC) to provide network connectivity tor its applications Some of the subnets used by both companies overlap In order for both businesses to integrate, the applications need to have private network connectivity. These applications are not on overlapping subnets. You want to provide connectivity with minimal re-engineering. What should you do?",
    "options": {
      "A": "Set up VPC peering and peer each Shared VPC together",
      "B": "Configure SSH port forwarding on each application to provide connectivity between applications i the different Shared VPCs",
      "C": "Migrate the protects from the acquired company into your company's Google Cloud organization Re launch the instances in your companies Shared VPC",
      "D": "Set up a Cloud VPN gateway in each Shared VPC and peer Cloud VPNs"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "VPC Peering doesn't work across organizations or with overlapping subnets. Migration is major re-engineering. Cloud VPN can connect VPCs across organizations, and while overlapping subnets require careful routing, the specific applications needing connectivity are *not* on overlapping subnets, making VPN a viable option with minimal re-engineering compared to migration.",
    "conditions": [
      "Two companies, separate Orgs, separate Shared VPCs",
      "Some subnet overlaps exist",
      "Need private connectivity for specific apps",
      "Communicating apps are *not* on overlapping subnets",
      "Minimize re-engineering"
    ],
    "caseStudyContext": null
  },
  {
    "id": 184,
    "topic": "Operations",
    "question": "You are managing several internal applications that are deployed on Compute Engine. Business users inform you that an application has become very slow over the past few days. You want to find the underlying cause in order to solve the problem. What should you do first?",
    "options": {
      "A": "Inspect the logs and metrics from the instances in Cloud Logging and Cloud Monitoring.",
      "B": "Change the Compute Engine Instances behind the application to a machine type with more CPU and memory.",
      "C": "Restore a backup of the application database from a time before the application became slow.",
      "D": "Deploy the applications on a managed instance group with autoscaling enabled. Add a load balancer in front of the managed instance group, and have the users connect to the IP of the load balancer."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The first step in troubleshooting performance degradation is always investigation. Checking logs (for errors) and metrics (CPU, memory, latency, etc.) in Cloud Logging and Monitoring (A) helps identify the bottleneck before making potentially unnecessary changes (B, C, D).",
    "conditions": [
      "Internal GCE app became slow",
      "Find the cause"
    ],
    "caseStudyContext": null
  },
  {
    "id": 185,
    "topic": "Compute",
    "question": "Your company has an application running as a Deployment in a Google Kubernetes Engine (GKE) cluster. When releasing new versions of the application via a rolling deployment, the team has been causing outages. The root cause of the outages is misconfigurations with parameters that are only used in production. You want to put preventive measures for this in the platform to prevent outages. What should you do?",
    "options": {
      "A": "Configure liveness and readiness probes in the Pod specification.",
      "B": "Configure health checks on the managed instance group.",
      "C": "Create a Scheduled Task to check whether the application is available.",
      "D": "Configure an uptime alert in Cloud Monitoring."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Properly configured liveness and readiness probes (A) are essential for safe rolling deployments in Kubernetes. Readiness probes ensure traffic isn't sent to new pods until they are fully started and configured correctly. Liveness probes detect unhealthy pods and restart them. This prevents traffic from hitting misconfigured pods during rollout.",
    "conditions": [
      "GKE Deployment",
      "Rolling deployments cause outages due to misconfiguration",
      "Need preventative measure"
    ],
    "caseStudyContext": null
  },
  {
    "id": 186,
    "topic": "Compute",
    "question": "Your company uses Google Kubernetes Engine (GKE) as a platform for all workloads. Your company has a single large GKE cluster that contains batch, stateful, and stateless workloads. The GKE cluster is configured with a single node pool with 200 nodes. Your company needs to reduce the cost of this cluster but does not want to compromise availability. What should you do?",
    "options": {
      "A": "Create a second GKE cluster for the batch workloads only. Allocate the 200 original nodes across both clusters.",
      "B": "Configure CPU and memory limits on the namespaces in the cluster. Configure all Pods to have a CPU and memory limits.",
      "C": "Configure a HorizontalPodAutoscaler for all stateless workloads and for all compatible stateful workloads. Configure the cluster to use node auto scaling.",
      "D": "Change the node pool to use spot VMs."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To reduce cost without compromising availability, enable autoscaling. Configure Horizontal Pod Autoscaler (HPA) for applicable workloads to scale pods based on demand. Enable Cluster Autoscaler (node auto scaling) to adjust the number of nodes based on pod requirements (C). This ensures resources match usage, reducing cost during low load while maintaining availability.",
    "conditions": [
      "Single large GKE cluster (200 nodes)",
      "Mixed workloads",
      "Reduce cost, maintain availability"
    ],
    "caseStudyContext": null
  },
  {
    "id": 187,
    "topic": "Data Analytics",
    "question": "Your company has a Google Cloud project that uses BigQuery for data warehousing on a pay-per-use basis. You want to monitor queries in real time to discover the most costly queries and which users spend the most. What should you do?",
    "options": {
      "A": "1. In the BigQuery dataset that contains all the tables to be queried, add a label for each user that can launch a query. 2. Open the Billing page of the project. 3. Select Reports. 4. Select BigQuery as the product and filter by the user you want to check.",
      "B": "1. Create a Cloud Logging sink to export BigQuery data access logs to BigQuery. 2. Perform a BigQuery query on the generated table to extract the information you need.",
      "C": "1. Create a Cloud Logging sink to export BigQuery data access logs to Cloud Storage. 2. Develop a Dataflow pipeline to compute the cost of queries split by users.",
      "D": "1. Activate billing export into BigQuery. 2. Perform a BigQuery query on the billing table to extract the information you need."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "BigQuery Audit Logs (Data Access logs) contain detailed information about each query, including user and bytes billed. Exporting these logs to another BigQuery dataset via a sink (B) allows near real-time querying of this metadata to identify costly queries and aggregate costs by user.",
    "conditions": [
      "BigQuery DWH (pay-per-use)",
      "Monitor queries in real time",
      "Identify costly queries and high-spending users"
    ],
    "caseStudyContext": null
  },
  {
    "id": 188,
    "topic": "Networking",
    "question": "Your company and one of its partners each have a Google Cloud project in separate organizations. Your company's project (prj-a) runs in Virtual Private Cloud (vpc-a). The partner's project (prj-b) runs in vpc-b. There are two instances running on vpc-a and one instance running on vpc-b. Subnets defined in both VPCs are not overlapping. You need to ensure that all instances communicate with each other via internal IPs, minimizing latency and maximizing throughput. What should you do?",
    "options": {
      "A": "Set up a network peering between vpc-a and vpc-b.",
      "B": "Set up a VPN between vpc-a and vpc-b using Cloud VPN.",
      "C": "Configure [AP TCP forwarding on the instance in vpc-b, and then launch the following gcloud command from one of the instances in vpc-a gcloud: gcloud compute start-iap-tunnel INSTANCE_NAME_IN_VPC_8 22 \\ --local-host-port=localhost:22",
      "D": "1. Create an additional instance in vpc-a. 2. Create an additional instance in vpc-b. 3. Install OpenVPN in newly created instances. 4. Configure a VPN tunnel between vpc-a and vpc-b with the help of OpenVPN."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "VPC Network Peering allows private connectivity between VPCs, even across organizations, using Google's network backbone. Since subnets don't overlap, peering (A) provides the lowest latency and highest throughput compared to VPN options (B, D).",
    "conditions": [
      "Two projects, separate Orgs (prj-a/vpc-a, prj-b/vpc-b)",
      "Non-overlapping subnets",
      "Need internal IP communication",
      "Minimize latency, maximize throughput"
    ],
    "caseStudyContext": null
  },
  {
    "id": 189,
    "topic": "Storage",
    "question": "You want to store critical business information in Cloud Storage buckets. The information is regularly changed, but previous versions need to be referenced on a regular basis. You want to ensure that there is a record of all changes to any information in these buckets. You want to ensure that accidental edits or deletions can be easily rolled back. Which feature should you enable?",
    "options": {
      "A": "Bucket Lock",
      "B": "Object Versioning",
      "C": "Object change notification",
      "D": "Object Lifecycle Management"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Object Versioning keeps all versions of an object when it's overwritten or deleted. This provides a history of changes and allows easy rollback by restoring a previous (noncurrent) version.",
    "conditions": [
      "Store critical info in GCS",
      "Regularly changed",
      "Reference previous versions",
      "Record of changes needed",
      "Easy rollback needed"
    ],
    "caseStudyContext": null
  },
  {
    "id": 190,
    "topic": "Compute",
    "question": "You have a Compute Engine application that you want to autoscale when total memory usage exceeds 80%. You have installed the Cloud Monitoring agent and configured the autoscaling policy as follows:\n\n* Metric identifier: agent.googleapis.com/memory/percent_used\n* Filter: metric.label.state = 'used'\n* Target utilization level: 80\n* Target type: GAUGE\n\nYou observe that the application does not scale under high load. You want to resolve this. What should you do?",
    "options": {
      "A": "Change the Target type to DELTA_PER_MINUTE.",
      "B": "Change the Metric identifier to agent.googleapis.com/memory/bytes_used.",
      "C": "Change the filter to metric.label.state = ‘used’ AND metric.label.state = ‘buffered’ AND metric.label.state = ‘cached’ AND metric.label.state ‘slab’.",
      "D": "Change the filter to metric.label.state = ‘free’ and the Target utilization to 20."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The `percent_used` metric with only `state='used'` underestimates memory pressure on Linux. To accurately scale based on >80% usage, the filter needs to account for memory used by buffers and cache as well. Option C suggests including 'buffered', 'cached', and 'slab' states in the filter (or targeting low 'free' memory as in D).",
    "conditions": [
      "Autoscale GCE app when memory > 80%",
      "Monitoring agent installed",
      "Current policy uses metric `percent_used`, filter `state='used'`, target 80%",
      "App fails to scale"
    ],
    "caseStudyContext": null
  },
  {
    "id": 191,
    "topic": "Networking",
    "question": "You are deploying an application to Google Cloud. The application is part of a system. The application in Google Cloud must communicate over a private network with applications in a non-Google Cloud environment. The expected average throughput is 200 kbps. The business requires:\n\n* as Close to 100% system availability as possible\n* cost optimization\n\nYou need to design the connectivity between the locations to meet the Business Requirements. What should you provision?",
    "options": {
      "A": "An HA Cloud VPN gateway connected with two tunnels to an on-premises VPN gateway",
      "B": "Two Classic Cloud VPN gateways connected to two on-premises VPN gateways Configure each Classic Cloud VPN gateway to have two tunnels, each connected to different on-premises VPN gateways",
      "C": "Two HA Cloud VPN gateways connected to two on-premises VPN gateways Configure each HA Cloud VPN gateway to have two tunnels, each connected to different on-premises VPN gateways",
      "D": "A single Cloud VPN gateway connected to an on-premises VPN gateway"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Requirement is near 100% availability (99.99% SLA) with low throughput and cost optimization. HA VPN offers a 99.99% SLA using redundant tunnels on the GCP side. Connecting a single HA VPN gateway to the non-GCP gateway (A) meets the SLA requirement more cost-effectively than using two HA VPN gateways (C). Classic VPN (B, D) has a lower SLA.",
    "conditions": [
      "GCP app needs private communication with non-GCP app",
      "Throughput: 200 kbps",
      "Requirement: Near 100% availability",
      "Requirement: Cost optimization"
    ],
    "caseStudyContext": null
  },
  {
    "id": 192,
    "topic": "App Engine",
    "question": "Your company has an application running on App Engine that allows users to upload music files and share them with other people. You want to allow users to upload files directly into Cloud Storage from their browser session. The payload should not be passed through the backend. What should you do?",
    "options": {
      "A": "1. Set a CORS configuration in the target Cloud Storage bucket where the base URL of the App Engine application is an allowed origin. 2. Use the Cloud Storage Signed URL feature to generate a POST URL.",
      "B": "1. Set a CORS configuration in the target Cloud Storage bucket where the base URL of the App Engine application is an allowed origin. 2. Assign the Cloud Storage WRITER role to users who upload files.",
      "C": "1. Use the Cloud Storage Signed URL feature to generate a POST URL. 2. Use App Engine default credentials to sign requests against Cloud Storage.",
      "D": "1. Assign the Cloud Storage WRITER role to users who upload files. 2. Use App Engine default credentials to sign requests against Cloud Storage."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Direct browser uploads require: 1) CORS configured on the target GCS bucket to allow requests from the App Engine app's origin. 2) A way for the browser to authenticate, typically a Signed URL (specifically a POST URL or V4 signed URL for uploads) generated by the backend (App Engine) that grants temporary permission to upload.",
    "conditions": [
      "App Engine app",
      "Allow direct browser uploads to GCS",
      "Avoid passing payload through backend"
    ],
    "caseStudyContext": null
  },
  {
    "id": 193,
    "topic": "Networking",
    "question": "You are configuring the cloud network architecture for a newly created project in Google Cloud that will host applications in Compute Engine. Compute Engine virtual machine instances will be created in two different subnets (sub-a and sub-b) within a single region:\n\n* Instances in sub-a will have public IP addresses.\n* Instances in sub-b will have only private IP addresses.\n\nTo download updated packages, instances must connect to a public repository outside the boundaries of Google Cloud. You need to allow sub-b to access the external repository. What should you do?",
    "options": {
      "A": "Enable Private Google Access on sub-b.",
      "B": "Configure Cloud NAT and select sub-b in the NAT mapping section.",
      "C": "Configure a bastion host instance in sub-a to connect to instances in sub-b.",
      "D": "Enable Identity-Aware Proxy for TCP forwarding for instances in sub-b."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Instances with only private IPs (sub-b) need a way to initiate outbound connections to the public internet (external repository). Cloud NAT provides managed network address translation, allowing instances in specified subnets (sub-b) without public IPs to route outbound traffic through the NAT gateway.",
    "conditions": [
      "GCE instances in two subnets (sub-a: public IPs, sub-b: private IPs)",
      "Instances need access to public external repository",
      "Allow sub-b instances outbound access"
    ],
    "caseStudyContext": null
  },
  {
    "id": 194,
    "topic": "Compute",
    "question": "Your company is planning to migrate their Windows Server 2022 from their on-premises data center to Google Cloud. You need to bring the licenses that are currently in use in on-premises virtual machines into the target cloud environment. What should you do?",
    "options": {
      "A": "1, Create an image of the on-premises virtual machines and upload into Cloud Storage. 2. Import the image as a virtual disk on Compute Engine.",
      "B": "1. Create standard instances on Compute Engine. 2. Select as the OS the same Microsoft Windows version that is currently in use in the on-premises environment.",
      "C": "1. Create an image of the on-premises virtual machine. 2. Import the image as a virtual disk on Compute Engine. 3. Create a standard instance on Compute Engine, selecting as the OS the same Microsoft Windows version that is currently in use in the on-premises environment. 4. Attach a data disk that includes data that matches the created image.",
      "D": "1. Create an image of the on-premises virtual machines. 2. Import the image as a virtual disk on Compute Engine using --os=windows-2022-dc-v. 3. Create a sole-tenancy instance on Compute Engine that uses the imported disk as a boot disk."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Bringing your own licenses (BYOL) for Windows Server to GCP requires using Sole-Tenant Nodes for compliance. The process involves importing the existing VM image (correctly specifying the OS during import) and then launching an instance on a sole-tenant node group using the imported image as the boot disk (D).",
    "conditions": [
      "Migrate Windows Server 2022 from on-prem",
      "Bring existing licenses (BYOL)"
    ],
    "caseStudyContext": null
  },
  {
    "id": 195,
    "topic": "Networking",
    "question": "You are deploying an application to Google Cloud. The application is part of a system. The application in Google Cloud must communicate over a private network with applications in a non-Google Cloud environment. The expected average throughput is 200 kbps. The business requires:\n\n* 99.99% system availability\n* cost optimization\n\nYou need to design the connectivity between the locations to meet the Business Requirements. What should you provision?",
    "options": {
      "A": "An HA Cloud VPN gateway connected with two tunnels to an on-premises VPN gateway.",
      "B": "A Classic Cloud VPN gateway connected with two tunnels to an on-premises VPN gateway.",
      "C": "Two HA Cloud VPN gateways connected to two on-premises VPN gateways. Configure each HA Cloud VPN gateway to have two tunnels, each connected to different on-premises VPN gateways.",
      "D": "A Classic Cloud VPN gateway connected with one tunnel to an on-premises VPN gateway."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Requirement is 99.99% availability with low throughput and cost optimization. HA VPN provides a 99.99% SLA via redundant tunnels/gateways on the GCP side. Connecting one HA VPN gateway to the non-GCP gateway (A) meets the SLA requirement more cost-effectively than two HA VPN gateways (C). Classic VPN (B, D) has a lower SLA.",
    "conditions": [
      "GCP app needs private communication with non-GCP app",
      "Throughput: 200 kbps",
      "Requirement: 99.99% availability",
      "Requirement: Cost optimization"
    ],
    "caseStudyContext": null
  },
  {
    "id": 196,
    "topic": "Storage",
    "question": "Your company wants to migrate their 10-TB on-premises database export into Cloud Storage. You want to minimize the time it takes to complete\nthis activity and the overall cost. The bandwidth between the on-premises environment and Google Cloud is 1 Gbps. You want to follow Google-recommended practices. What should you do?",
    "options": {
      "A": "Develop a Dataflow job to read data directly from the database and write it into Cloud Storage.",
      "B": "Use the Data Transfer appliance to perform an offline migration.",
      "C": "Use a commercial partner ETL solution to extract the data from the on-premises database and upload it into Cloud Storage.",
      "D": "Upload the data with gcloud storage cp."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Transferring 10 TB over 1 Gbps is feasible (approx. 1 day). The standard recommended tool for uploading files to GCS is `gcloud storage cp` (or `gsutil cp`), which supports parallel uploads (`-m` for gsutil, often default in gcloud) to maximize bandwidth usage (D). Transfer Appliance (B) is overkill. Dataflow (A) or ETL (C) are unnecessary for transferring an existing file.",
    "conditions": [
      "Migrate 10 TB on-prem DB export to GCS",
      "Minimize time and cost",
      "1 Gbps bandwidth",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 197,
    "topic": "Storage",
    "question": "You are working at a financial institution that stores mortgage loan approval documents on Cloud Storage. Any change to these approval documents must be uploaded as a separate approval file. You need to ensure that these documents cannot be deleted or overwritten for the next 5 years. What should you do?",
    "options": {
      "A": "Create a retention policy on the bucket for the duration of 5 years. Create a lock on the retention policy.",
      "B": "Create a retention policy organizational constraint constraints/storage.retentionPolicySeconds at the organization level. Set the duration { 5 years.",
      "C": "Use a customer-managed key for the encryption of the bucket. Rotate the key after 5 years.",
      "D": "Create a retention policy organizational constraint constraints/storage.retentionPolicySeconds at the project level. Set the duration to 5 years."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To ensure immutability (no deletion/overwriting) for a fixed period (5 years), use a Cloud Storage Bucket Retention Policy. Setting the policy for 5 years and then locking it (A) makes the retention period irreversible, providing the strongest guarantee.",
    "conditions": [
      "Store mortgage documents in GCS",
      "Originals immutable",
      "Prevent deletion/overwriting for 5 years"
    ],
    "caseStudyContext": null
  },
  {
    "id": 198,
    "topic": "IAM & Security",
    "question": "The JencoMart security team requires that all Google Cloud Platform infrastructure is deployed using a least privilege model with separation of duties for administration between production and development resources.\nWhat Google domain and project structure should you recommend?",
    "options": {
      "A": "Create two G Suite accounts to manage users: one for development/test/staging and one for production. Each account should contain on project for every application",
      "B": "Create two G Suite accounts to manage users: one with a single project for all development applications and one with a single project for all production applications",
      "C": "Create a single G Suite account to manage users with each stage of each application in its own project",
      "D": "Create a single G Suite account to manage users with one project for the development/test/staging environment and one project for the production environment"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Use a single Google Workspace/Cloud Identity domain for user management. Separate Production and Non-Production (Dev/Test/Staging) environments into distinct GCP Projects (D). This allows applying different IAM policies to each environment, enforcing least privilege and separation of duties effectively.",
    "conditions": [
      "Least privilege model",
      "Separation of duties (Prod vs. Dev admin)"
    ],
    "caseStudyContext": "Introductory Info\n<strong>Company overview: </strong><br>- JencoMart is a global retailer with over 10,000 stores in 16 countries. The stores carry a range of goods, such as groceries, tires, and jewelry. One of the company’s core values is excellent customer service. In addition, they recently introduced an environmental policy to reduce their carbon output by 50% over the next 5 years.\nCompany background - JencoMart started as a general store in 1931, and has grown into one of the world's leading brands, known for great value and customer service. Over time, the company transitioned from only physical stores to a stores and online hybrid model, with 25% of sales online. Currently, JencoMart has little presence in Asia, but considers that market key for future growth.\n<strong>Solution Concept </strong><br> - JencoMart wants to migrate several critical applications to the cloud but has not completed a technical review to determine their suitability for the cloud and the engineering required for migration. They currently host all of these applications on infrastructure that is at its end of life and is no longer supported.\n<strong>Existing Technical Environment </strong><br> - JencoMart hosts all of its applications in 4 data centers: 3 in North American and 1 in Europe; most applications are dual-homed. JencoMart understands the dependencies and resource usage metrics of their on-premises architecture. Application: Customer loyalty portal LAMP (Linux, Apache, MySQL and PHP) application served from the two JencoMart-owned U.S. data centers.\nDatabase - Oracle Database stores user profiles - 20 TB - Complex table structure - Well maintained, clean data - Strong backup strategy PostgreSQL database stores user credentials - Single-homed in US West - No redundancy - Backed up every 12 hours - 100% uptime service level agreement (SLA) - Authenticates all users Compute - 30 machines in US West Coast, each machine has: - Twin, dual core CPUs - 32 GB of RAM - Twin 250 GB HDD (RAID 1) 20 machines in US East Coast, each machine has: - Single, dual-core CPU - 24 GB of RAM - Twin 250 GB HDD (RAID 1) Storage - Access to shared 100 TB SAN in each location Tape backup every week\n<strong>Business Requirements </strong><br> - Optimize for capacity during peak periods and value during off-peak periods Guarantee service availability and support Reduce on-premises footprint and associated financial and environmental impact Move to outsourcing model to avoid large upfront costs associated with infrastructure purchase Expand services into Asia\n<strong>Technical Requirements -</strong> Assess key application for cloud suitability Modify applications for the cloud Move applications to a new infrastructure Leverage managed services wherever feasible Sunset 20% of capacity in existing data centers Decrease latency in Asia\n<strong>CEO Statement </strong><br> - JencoMart will continue to develop personal relationships with our customers as more people access the web. The future of our retail business is in the global market and the connection between online and in-store experiences. As a large, global company, we also have a responsibility to the environment through ‘green’ initiatives and policies.\n<strong>CTO Statement  </strong><br>- The challenges of operating data centers prevent focus on key technologies critical to our long-term success. Migrating our data services to a public cloud infrastructure will allow us to focus on big data and machine learning to improve our service to customers.\nCFO Statement - Since its founding, JencoMart has invested heavily in our data services infrastructure. However, because of changing market trends, we need to outsource our infrastructure to ensure our long-term success. This model will allow us to respond to increasing customer demand during peak periods and reduce costs."
  },
  {
    "id": 199,
    "topic": "Compute",
    "question": "For this question, refer to the JencoMart case study.\nA few days after JencoMart migrates the user credentials database to Google Cloud Platform and shuts down the old server, the new database server stops responding to SSH connections. It is still serving database requests to the application servers correctly.\nWhat three steps should you take to diagnose the problem? (Choose three.)",
    "options": {
      "A": "Delete the virtual machine (VM) and disks and create a new one",
      "B": "Delete the instance, attach the disk to a new VM, and investigate",
      "C": "Take a snapshot of the disk and connect to a new machine to investigate",
      "D": "Check inbound firewall rules for the network the machine is connected to",
      "E": "Connect the machine to another network with very simple firewall rules and investigate",
      "F": "Print the Serial Console output for the instance for troubleshooting, activate the interactive console, and investigate"
    },
    "correctAnswer": [
      "C",
      "D",
      "F"
    ],
    "explanation": "DB server is running but SSH is broken. Diagnostics steps: D) Check firewall rules: Ensure SSH (port 22) ingress is allowed from the expected source IPs (or IAP). F) Check Serial Console: Provides OS-level access/logs even if SSH daemon or networking is broken. Look for boot errors, SSHD status, or resource exhaustion. C) Snapshot and attach disk: If the instance is completely inaccessible, snapshot the boot disk, create a new disk from the snapshot, attach it to a working 'rescue' VM, and examine logs/configs offline.",
    "conditions": [
      "Migrated PostgreSQL credentials DB to GCP (GCE)",
      "New DB server unresponsive to SSH",
      "DB server still serving app requests",
      "Diagnose SSH issue"
    ],
    "caseStudyContext": "Introductory Info\n<strong>Company overview: </strong><br>- JencoMart is a global retailer with over 10,000 stores in 16 countries. The stores carry a range of goods, such as groceries, tires, and jewelry. One of the company’s core values is excellent customer service. In addition, they recently introduced an environmental policy to reduce their carbon output by 50% over the next 5 years.\nCompany background - JencoMart started as a general store in 1931, and has grown into one of the world's leading brands, known for great value and customer service. Over time, the company transitioned from only physical stores to a stores and online hybrid model, with 25% of sales online. Currently, JencoMart has little presence in Asia, but considers that market key for future growth.\n<strong>Solution Concept </strong><br> - JencoMart wants to migrate several critical applications to the cloud but has not completed a technical review to determine their suitability for the cloud and the engineering required for migration. They currently host all of these applications on infrastructure that is at its end of life and is no longer supported.\n<strong>Existing Technical Environment </strong><br> - JencoMart hosts all of its applications in 4 data centers: 3 in North American and 1 in Europe; most applications are dual-homed. JencoMart understands the dependencies and resource usage metrics of their on-premises architecture. Application: Customer loyalty portal LAMP (Linux, Apache, MySQL and PHP) application served from the two JencoMart-owned U.S. data centers.\nDatabase - Oracle Database stores user profiles - 20 TB - Complex table structure - Well maintained, clean data - Strong backup strategy PostgreSQL database stores user credentials - Single-homed in US West - No redundancy - Backed up every 12 hours - 100% uptime service level agreement (SLA) - Authenticates all users Compute - 30 machines in US West Coast, each machine has: - Twin, dual core CPUs - 32 GB of RAM - Twin 250 GB HDD (RAID 1) 20 machines in US East Coast, each machine has: - Single, dual-core CPU - 24 GB of RAM - Twin 250 GB HDD (RAID 1) Storage - Access to shared 100 TB SAN in each location Tape backup every week\n<strong>Business Requirements </strong><br> - Optimize for capacity during peak periods and value during off-peak periods Guarantee service availability and support Reduce on-premises footprint and associated financial and environmental impact Move to outsourcing model to avoid large upfront costs associated with infrastructure purchase Expand services into Asia\n<strong>Technical Requirements -</strong> Assess key application for cloud suitability Modify applications for the cloud Move applications to a new infrastructure Leverage managed services wherever feasible Sunset 20% of capacity in existing data centers Decrease latency in Asia\n<strong>CEO Statement </strong><br> - JencoMart will continue to develop personal relationships with our customers as more people access the web. The future of our retail business is in the global market and the connection between online and in-store experiences. As a large, global company, we also have a responsibility to the environment through ‘green’ initiatives and policies.\n<strong>CTO Statement  </strong><br>- The challenges of operating data centers prevent focus on key technologies critical to our long-term success. Migrating our data services to a public cloud infrastructure will allow us to focus on big data and machine learning to improve our service to customers.\nCFO Statement - Since its founding, JencoMart has invested heavily in our data services infrastructure. However, because of changing market trends, we need to outsource our infrastructure to ensure our long-term success. This model will allow us to respond to increasing customer demand during peak periods and reduce costs."
  },
  {
    "id": 200,
    "topic": "IAM & Security",
    "question": "For this question, refer to the JencoMart case study.\nJencoMart has decided to migrate user profile storage to Google Cloud Datastore and the application servers to Google Compute Engine (GCE). During the migration, the existing infrastructure will need access to Datastore to upload the data.\nWhat service account key-management strategy should you recommend?",
    "options": {
      "A": "Provision service account keys for the on-premises infrastructure and for the GCE virtual machines (VMs)",
      "B": "Authenticate the on-premises infrastructure with a user account and provision service account keys for the VMs",
      "C": "Provision service account keys for the on-premises infrastructure and use Google Cloud Platform (GCP) managed keys for the VMs",
      "D": "Deploy a custom authentication service on GCE/Google Kubernetes Engine (GKE) for the on-premises infrastructure and use GCP managed keys for the VMs"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "For GCE VMs accessing GCP services, the best practice is to use the VM's attached service account, which leverages GCP-managed keys obtained via the metadata server (no key files needed on the VM). For external systems like on-premises infrastructure, downloadable service account key files must be created and securely managed on-premises to authenticate API calls. Option C correctly describes this recommended strategy: keys for on-prem, managed identity for GCE VMs.",
    "conditions": [
      "Migrating user profiles to Datastore, app servers to GCE",
      "On-prem infra needs Datastore access during migration",
      "Recommend service account key strategy"
    ],
    "caseStudyContext": "Introductory Info\n<strong>Company overview: </strong><br>- JencoMart is a global retailer with over 10,000 stores in 16 countries. The stores carry a range of goods, such as groceries, tires, and jewelry. One of the company’s core values is excellent customer service. In addition, they recently introduced an environmental policy to reduce their carbon output by 50% over the next 5 years.\nCompany background - JencoMart started as a general store in 1931, and has grown into one of the world's leading brands, known for great value and customer service. Over time, the company transitioned from only physical stores to a stores and online hybrid model, with 25% of sales online. Currently, JencoMart has little presence in Asia, but considers that market key for future growth.\n<strong>Solution Concept </strong><br> - JencoMart wants to migrate several critical applications to the cloud but has not completed a technical review to determine their suitability for the cloud and the engineering required for migration. They currently host all of these applications on infrastructure that is at its end of life and is no longer supported.\n<strong>Existing Technical Environment </strong><br> - JencoMart hosts all of its applications in 4 data centers: 3 in North American and 1 in Europe; most applications are dual-homed. JencoMart understands the dependencies and resource usage metrics of their on-premises architecture. Application: Customer loyalty portal LAMP (Linux, Apache, MySQL and PHP) application served from the two JencoMart-owned U.S. data centers.\nDatabase - Oracle Database stores user profiles - 20 TB - Complex table structure - Well maintained, clean data - Strong backup strategy PostgreSQL database stores user credentials - Single-homed in US West - No redundancy - Backed up every 12 hours - 100% uptime service level agreement (SLA) - Authenticates all users Compute - 30 machines in US West Coast, each machine has: - Twin, dual core CPUs - 32 GB of RAM - Twin 250 GB HDD (RAID 1) 20 machines in US East Coast, each machine has: - Single, dual-core CPU - 24 GB of RAM - Twin 250 GB HDD (RAID 1) Storage - Access to shared 100 TB SAN in each location Tape backup every week\n<strong>Business Requirements </strong><br> - Optimize for capacity during peak periods and value during off-peak periods Guarantee service availability and support Reduce on-premises footprint and associated financial and environmental impact Move to outsourcing model to avoid large upfront costs associated with infrastructure purchase Expand services into Asia\n<strong>Technical Requirements -</strong> Assess key application for cloud suitability Modify applications for the cloud Move applications to a new infrastructure Leverage managed services wherever feasible Sunset 20% of capacity in existing data centers Decrease latency in Asia\n<strong>CEO Statement </strong><br> - JencoMart will continue to develop personal relationships with our customers as more people access the web. The future of our retail business is in the global market and the connection between online and in-store experiences. As a large, global company, we also have a responsibility to the environment through ‘green’ initiatives and policies.\n<strong>CTO Statement  </strong><br>- The challenges of operating data centers prevent focus on key technologies critical to our long-term success. Migrating our data services to a public cloud infrastructure will allow us to focus on big data and machine learning to improve our service to customers.\nCFO Statement - Since its founding, JencoMart has invested heavily in our data services infrastructure. However, because of changing market trends, we need to outsource our infrastructure to ensure our long-term success. This model will allow us to respond to increasing customer demand during peak periods and reduce costs."
  },
  {
    "id": 201,
    "topic": "Operations",
    "question": "For this question, refer to the JencoMart case study.\nJencoMart has built a version of their application on Google Cloud Platform that serves traffic to Asia. You want to measure success against the business and technical goals.\nWhich metrics should you track?",
    "options": {
      "A": "Error rates for requests from Asia",
      "B": "Latency difference between US and Asia",
      "C": "Total visits, error rates, and latency from Asia",
      "D": "Total visits and average latency for users from Asia",
      "E": "The number of character sets present in the database"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "The key goals related to the Asian deployment are: Business Goal: Expand services into Asia (measured by 'Total visits' from Asia). Technical Goal: Decrease latency in Asia (measured by 'average latency' for users from Asia). Option D directly tracks these two primary success metrics.",
    "conditions": [
      "Measure success of Asian deployment against business/technical goals",
      "Goals: Expand to Asia, Decrease latency in Asia"
    ],
    "caseStudyContext": "Introductory Info\n<strong>Company overview: </strong><br>- JencoMart is a global retailer with over 10,000 stores in 16 countries. The stores carry a range of goods, such as groceries, tires, and jewelry. One of the company’s core values is excellent customer service. In addition, they recently introduced an environmental policy to reduce their carbon output by 50% over the next 5 years.\nCompany background - JencoMart started as a general store in 1931, and has grown into one of the world's leading brands, known for great value and customer service. Over time, the company transitioned from only physical stores to a stores and online hybrid model, with 25% of sales online. Currently, JencoMart has little presence in Asia, but considers that market key for future growth.\n<strong>Solution Concept </strong><br> - JencoMart wants to migrate several critical applications to the cloud but has not completed a technical review to determine their suitability for the cloud and the engineering required for migration. They currently host all of these applications on infrastructure that is at its end of life and is no longer supported.\n<strong>Existing Technical Environment </strong><br> - JencoMart hosts all of its applications in 4 data centers: 3 in North American and 1 in Europe; most applications are dual-homed. JencoMart understands the dependencies and resource usage metrics of their on-premises architecture. Application: Customer loyalty portal LAMP (Linux, Apache, MySQL and PHP) application served from the two JencoMart-owned U.S. data centers.\nDatabase - Oracle Database stores user profiles - 20 TB - Complex table structure - Well maintained, clean data - Strong backup strategy PostgreSQL database stores user credentials - Single-homed in US West - No redundancy - Backed up every 12 hours - 100% uptime service level agreement (SLA) - Authenticates all users Compute - 30 machines in US West Coast, each machine has: - Twin, dual core CPUs - 32 GB of RAM - Twin 250 GB HDD (RAID 1) 20 machines in US East Coast, each machine has: - Single, dual-core CPU - 24 GB of RAM - Twin 250 GB HDD (RAID 1) Storage - Access to shared 100 TB SAN in each location Tape backup every week\n<strong>Business Requirements </strong><br> - Optimize for capacity during peak periods and value during off-peak periods Guarantee service availability and support Reduce on-premises footprint and associated financial and environmental impact Move to outsourcing model to avoid large upfront costs associated with infrastructure purchase Expand services into Asia\n<strong>Technical Requirements -</strong> Assess key application for cloud suitability Modify applications for the cloud Move applications to a new infrastructure Leverage managed services wherever feasible Sunset 20% of capacity in existing data centers Decrease latency in Asia\n<strong>CEO Statement </strong><br> - JencoMart will continue to develop personal relationships with our customers as more people access the web. The future of our retail business is in the global market and the connection between online and in-store experiences. As a large, global company, we also have a responsibility to the environment through ‘green’ initiatives and policies.\n<strong>CTO Statement  </strong><br>- The challenges of operating data centers prevent focus on key technologies critical to our long-term success. Migrating our data services to a public cloud infrastructure will allow us to focus on big data and machine learning to improve our service to customers.\nCFO Statement - Since its founding, JencoMart has invested heavily in our data services infrastructure. However, because of changing market trends, we need to outsource our infrastructure to ensure our long-term success. This model will allow us to respond to increasing customer demand during peak periods and reduce costs."
  },
  {
    "id": 202,
    "topic": "Migration",
    "question": "For this question, refer to the JencoMart case study.\nOn-premises infrastructure Google\n_— | ctoua\nRack & Storage\nManaged group\n—- [_—n\nU | Rack Edge router L Cloud VPN LW | _\n— |\n| sss |\nack\nThe migration of JencoMart's application to Google Cloud Platform (GCP) is progressing too slowly. The infrastructure is shown in the diagram.\nManaged group\nYou want to maximize throughput.\nWhat are three potential bottlenecks? (Choose three.)",
    "options": {
      "A": "A single VPN tunnel, which limits throughput",
      "B": "A tier of Google Cloud Storage that is not suited for this task",
      "C": "A copy command that is not suited to operate over long distances",
      "D": "Fewer virtual machines (VMs) in GCP than on-premises machines",
      "E": "A separate storage layer outside the VMs, which is not suited for this task",
      "F": "Complicated internet connectivity between the on-premises infrastructure and GCP"
    },
    "correctAnswer": [
      "A",
      "C",
      "F"
    ],
    "explanation": "Potential bottlenecks for slow migration over Cloud VPN: A) A single VPN tunnel has limited bandwidth capacity. F) Cloud VPN relies on the public internet, which can have variable performance, latency, and packet loss, limiting effective throughput. C) Standard file copy tools (like basic `cp` or `scp`) are often single-threaded and not optimized for high-latency networks, hindering transfer speed. Using parallel transfer tools (`gsutil -m`) is recommended.",
    "conditions": [
      "Application migration on-prem to GCP",
      "Migration is too slow",
      "Using Cloud VPN",
      "Identify potential throughput bottlenecks"
    ],
    "caseStudyContext": "Introductory Info\n<strong>Company overview: </strong><br>- JencoMart is a global retailer with over 10,000 stores in 16 countries. The stores carry a range of goods, such as groceries, tires, and jewelry. One of the company’s core values is excellent customer service. In addition, they recently introduced an environmental policy to reduce their carbon output by 50% over the next 5 years.\nCompany background - JencoMart started as a general store in 1931, and has grown into one of the world's leading brands, known for great value and customer service. Over time, the company transitioned from only physical stores to a stores and online hybrid model, with 25% of sales online. Currently, JencoMart has little presence in Asia, but considers that market key for future growth.\n<strong>Solution Concept </strong><br> - JencoMart wants to migrate several critical applications to the cloud but has not completed a technical review to determine their suitability for the cloud and the engineering required for migration. They currently host all of these applications on infrastructure that is at its end of life and is no longer supported.\n<strong>Existing Technical Environment </strong><br> - JencoMart hosts all of its applications in 4 data centers: 3 in North American and 1 in Europe; most applications are dual-homed. JencoMart understands the dependencies and resource usage metrics of their on-premises architecture. Application: Customer loyalty portal LAMP (Linux, Apache, MySQL and PHP) application served from the two JencoMart-owned U.S. data centers.\nDatabase - Oracle Database stores user profiles - 20 TB - Complex table structure - Well maintained, clean data - Strong backup strategy PostgreSQL database stores user credentials - Single-homed in US West - No redundancy - Backed up every 12 hours - 100% uptime service level agreement (SLA) - Authenticates all users Compute - 30 machines in US West Coast, each machine has: - Twin, dual core CPUs - 32 GB of RAM - Twin 250 GB HDD (RAID 1) 20 machines in US East Coast, each machine has: - Single, dual-core CPU - 24 GB of RAM - Twin 250 GB HDD (RAID 1) Storage - Access to shared 100 TB SAN in each location Tape backup every week\n<strong>Business Requirements </strong><br> - Optimize for capacity during peak periods and value during off-peak periods Guarantee service availability and support Reduce on-premises footprint and associated financial and environmental impact Move to outsourcing model to avoid large upfront costs associated with infrastructure purchase Expand services into Asia\n<strong>Technical Requirements -</strong> Assess key application for cloud suitability Modify applications for the cloud Move applications to a new infrastructure Leverage managed services wherever feasible Sunset 20% of capacity in existing data centers Decrease latency in Asia\n<strong>CEO Statement </strong><br> - JencoMart will continue to develop personal relationships with our customers as more people access the web. The future of our retail business is in the global market and the connection between online and in-store experiences. As a large, global company, we also have a responsibility to the environment through ‘green’ initiatives and policies.\n<strong>CTO Statement  </strong><br>- The challenges of operating data centers prevent focus on key technologies critical to our long-term success. Migrating our data services to a public cloud infrastructure will allow us to focus on big data and machine learning to improve our service to customers.\nCFO Statement - Since its founding, JencoMart has invested heavily in our data services infrastructure. However, because of changing market trends, we need to outsource our infrastructure to ensure our long-term success. This model will allow us to respond to increasing customer demand during peak periods and reduce costs."
  },
  {
    "id": 203,
    "topic": "Databases",
    "question": "For this question, refer to the JencoMart case study.\nJencoMart wants to move their User Profiles database to Google Cloud Platform.\nWhich Google Database should they use?",
    "options": {
      "A": "Cloud Spanner",
      "B": "Google BigQuery",
      "C": "Google Cloud SQL",
      "D": "Google Cloud Datastore"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "The User Profiles database is currently Oracle (20TB, complex structure). While Cloud SQL (C) or Cloud Spanner (A) could handle relational data, migrating a large, complex Oracle schema can be difficult. Cloud Datastore (Firestore in Datastore mode) (D) is a managed, scalable NoSQL document database often well-suited for storing user profiles, potentially simplifying the migration from a complex relational structure while providing scalability and leveraging managed services as per requirements. BigQuery (B) is for analytics.",
    "conditions": [
      "Migrate User Profiles database (currently Oracle 20TB)",
      "Leverage managed services"
    ],
    "caseStudyContext": "Introductory Info\n<strong>Company overview: </strong><br>- JencoMart is a global retailer with over 10,000 stores in 16 countries. The stores carry a range of goods, such as groceries, tires, and jewelry. One of the company’s core values is excellent customer service. In addition, they recently introduced an environmental policy to reduce their carbon output by 50% over the next 5 years.\nCompany background - JencoMart started as a general store in 1931, and has grown into one of the world's leading brands, known for great value and customer service. Over time, the company transitioned from only physical stores to a stores and online hybrid model, with 25% of sales online. Currently, JencoMart has little presence in Asia, but considers that market key for future growth.\n<strong>Solution Concept </strong><br> - JencoMart wants to migrate several critical applications to the cloud but has not completed a technical review to determine their suitability for the cloud and the engineering required for migration. They currently host all of these applications on infrastructure that is at its end of life and is no longer supported.\n<strong>Existing Technical Environment </strong><br> - JencoMart hosts all of its applications in 4 data centers: 3 in North American and 1 in Europe; most applications are dual-homed. JencoMart understands the dependencies and resource usage metrics of their on-premises architecture. Application: Customer loyalty portal LAMP (Linux, Apache, MySQL and PHP) application served from the two JencoMart-owned U.S. data centers.\nDatabase - Oracle Database stores user profiles - 20 TB - Complex table structure - Well maintained, clean data - Strong backup strategy PostgreSQL database stores user credentials - Single-homed in US West - No redundancy - Backed up every 12 hours - 100% uptime service level agreement (SLA) - Authenticates all users Compute - 30 machines in US West Coast, each machine has: - Twin, dual core CPUs - 32 GB of RAM - Twin 250 GB HDD (RAID 1) 20 machines in US East Coast, each machine has: - Single, dual-core CPU - 24 GB of RAM - Twin 250 GB HDD (RAID 1) Storage - Access to shared 100 TB SAN in each location Tape backup every week\n<strong>Business Requirements </strong><br> - Optimize for capacity during peak periods and value during off-peak periods Guarantee service availability and support Reduce on-premises footprint and associated financial and environmental impact Move to outsourcing model to avoid large upfront costs associated with infrastructure purchase Expand services into Asia\n<strong>Technical Requirements -</strong> Assess key application for cloud suitability Modify applications for the cloud Move applications to a new infrastructure Leverage managed services wherever feasible Sunset 20% of capacity in existing data centers Decrease latency in Asia\n<strong>CEO Statement </strong><br> - JencoMart will continue to develop personal relationships with our customers as more people access the web. The future of our retail business is in the global market and the connection between online and in-store experiences. As a large, global company, we also have a responsibility to the environment through ‘green’ initiatives and policies.\n<strong>CTO Statement  </strong><br>- The challenges of operating data centers prevent focus on key technologies critical to our long-term success. Migrating our data services to a public cloud infrastructure will allow us to focus on big data and machine learning to improve our service to customers.\nCFO Statement - Since its founding, JencoMart has invested heavily in our data services infrastructure. However, because of changing market trends, we need to outsource our infrastructure to ensure our long-term success. This model will allow us to respond to increasing customer demand during peak periods and reduce costs."
  },
  {
    "id": 204,
    "topic": "Security",
    "question": "For this question, refer to the Helicopter Racing League (HRL) case study.\nYour team is in charge of creating a payment card data vault for card numbers used to bill tens of thousands of viewers, merchandise consumers, and season ticket holders. You need to implement a custom card tokenization service that meets the following requirements:\n\n* It must provide low latency at minimal cost.\n* It must be able to identify duplicate credit cards and must not store plaintext card numbers.\n* It should support annual key rotation.\n\nWhich storage approach should you adopt for your tokenization service?",
    "options": {
      "A": "Store the card data in Secret Manager after running a query to identify duplicates.",
      "B": "Encrypt the card data with a deterministic algorithm stored in Firestore using Datastore mode.",
      "C": "Encrypt the card data with a deterministic algorithm and shard it across multiple Memorystore instances.",
      "D": "Use column-level encryption to store the data in Cloud SQL."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "To identify duplicates without storing plaintext, deterministic encryption (same input always yields same output) or hashing with a secret salt is needed. Firestore (in Datastore mode) provides a low-latency, scalable, and cost-effective NoSQL database for storing the mapping between the generated token (derived from the encrypted/hashed card number) and any necessary metadata (e.g., card type, expiration). The encryption key can be managed in KMS to support rotation. Secret Manager (A) is for secrets, not datasets. Memorystore (C) is volatile. Cloud SQL (D) is relational and potentially less cost-effective/scalable for simple token storage.",
    "conditions": [
      "Payment card tokenization service",
      "Low latency, minimal cost",
      "Identify duplicates, no plaintext storage",
      "Support annual key rotation"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Helicopter Racing League (HRL) is a global sports league for competitive helicopter racing. Each year HRL holds the world championship and several regional league competitions where teams compete to earn a spot in the world championship. HRL offers a paid service to stream the races all over the world with live telemetry and predictions throughout each race.\n<strong>Solution Concept </strong>: HRL wants to migrate their existing service to a new platform to expand their use of managed Al and ML services to facilitate race predictions. Additionally, as new fans engage with the sport, particularly in emerging regions, they want to move the serving of their content, both real-time and recorded, closer to their users.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> HRL is a public cloud-first company; the core of their mission-critical applications runs on their current public cloud provider. Video recording and editing is performed at the race tracks, and the content is encoded and transcoded, where needed, in the cloud. Enterprise-grade connectivity and local compute is provided by truck-mounted mobile data centers. Their race prediction services are hosted exclusively on their existing public cloud provider. Their <strong>Existing Technical Environment </strong><br> is as follows: Existing content is stored in an object storage service on their existing public cloud provider. Video encoding and transcoding is performed on VMs created for each job. Race predictions are performed using TensorFlow running on VMs in the current public cloud provider.\n<strong><strong>Business Requirements </strong>: </strong><br> HRL's owners want to expand their predictive capabilities and reduce latency for their viewers in emerging markets. Their requirements are: Support ability to expose the predictive models to partners. Increase predictive capabilities during and before races: Race results, Mechanical failures, Crowd sentiment. Increase telemetry and create additional insights. Measure fan engagement with new predictions. Enhance global availability and quality of the broadcasts. Increase the number of concurrent viewers. Minimize operational complexity. Ensure compliance with regulations. Create a merchandising revenue stream.\n<strong>Technical requirements: </strong><br> Maintain or increase prediction throughput and accuracy. Reduce viewer latency. Increase transcoding performance. Create real-time analytics of viewer consumption patterns and engagement. Create a data mart to enable processing of large volumes of race data.\n<strong>Executive statement: </strong><br> Our CEO, S. Hawke, wants to bring high-adrenaline racing to fans all around the world. We listen to our fans, and they want enhanced video streams that include predictions of events within the race (e.g., overtaking). Our current platform allows us to predict race outcomes but lacks the facility to support real-time predictions during races and the capacity to process season-long results."
  },
  {
    "id": 205,
    "topic": "Networking",
    "question": "For this question, refer to the Helicopter Racing League (HRL) case study.\nRecently HRL started a new regional racing league in Cape Town, South Africa. In an effort to give customers in Cape Town a better user experience, HRL has partnered with the Content Delivery Network provider, Fastly. HRL needs to allow traffic coming from all of the Fastly IP address ranges into their Virtual Private Cloud network (VPC network). You are a member of the HRL security team and you need to configure the update that will allow only the Fastly IP address ranges through the External HTTP(S) load balancer.\nWhich command should you use?",
    "options": {
      "A": "gcloud compute security-policies rules update 1000 \\\n--security-policy from-fastly \\\n--src-ip-ranges * \\\n--action “allow”",
      "B": "gcloud compute firewall rules update sourceiplist-fastly \\\n--priority 1000 \\\n--allow tcep:443",
      "C": "gcloud compute firewall rules update hlr-policy \\\n--priority 1000 \\\n--target-tags=sourceiplist-fastly \\\n--allow tcep:443",
      "D": "gcloud compute security-policies rules update 1000 \\\n--security-policy hlr-policy \\\n--expression “evaluatePreconfiguredExpr(‘sourceiplist-fastly’}” \\\n--action “allow”"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "To allow traffic *only* from specific IP ranges through an External HTTP(S) Load Balancer, you use Cloud Armor Security Policies attached to the load balancer's backend service(s). Option D correctly uses `gcloud compute security-policies rules update` to modify a rule within a policy (`hlr-policy`). It uses a preconfigured expression `evaluatePreconfiguredExpr` referencing a named IP list (`sourceiplist-fastly`, which would contain Fastly's IPs) as the match condition and sets the action to `allow`. A default deny rule at a lower priority would block other traffic. A allows all IPs. B/C configure VPC firewall rules, which operate at the instance level, not the load balancer.",
    "conditions": [
      "Partnered with CDN Fastly",
      "Allow traffic ONLY from Fastly IPs",
      "Traffic path: through External HTTP(S) Load Balancer",
      "Configure security update via gcloud"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Helicopter Racing League (HRL) is a global sports league for competitive helicopter racing. Each year HRL holds the world championship and several regional league competitions where teams compete to earn a spot in the world championship. HRL offers a paid service to stream the races all over the world with live telemetry and predictions throughout each race.\n<strong>Solution Concept </strong>: HRL wants to migrate their existing service to a new platform to expand their use of managed Al and ML services to facilitate race predictions. Additionally, as new fans engage with the sport, particularly in emerging regions, they want to move the serving of their content, both real-time and recorded, closer to their users.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> HRL is a public cloud-first company; the core of their mission-critical applications runs on their current public cloud provider. Video recording and editing is performed at the race tracks, and the content is encoded and transcoded, where needed, in the cloud. Enterprise-grade connectivity and local compute is provided by truck-mounted mobile data centers. Their race prediction services are hosted exclusively on their existing public cloud provider. Their <strong>Existing Technical Environment </strong><br> is as follows: Existing content is stored in an object storage service on their existing public cloud provider. Video encoding and transcoding is performed on VMs created for each job. Race predictions are performed using TensorFlow running on VMs in the current public cloud provider.\n<strong><strong>Business Requirements </strong>: </strong><br> HRL's owners want to expand their predictive capabilities and reduce latency for their viewers in emerging markets. Their requirements are: Support ability to expose the predictive models to partners. Increase predictive capabilities during and before races: Race results, Mechanical failures, Crowd sentiment. Increase telemetry and create additional insights. Measure fan engagement with new predictions. Enhance global availability and quality of the broadcasts. Increase the number of concurrent viewers. Minimize operational complexity. Ensure compliance with regulations. Create a merchandising revenue stream.\n<strong>Technical requirements: </strong><br> Maintain or increase prediction throughput and accuracy. Reduce viewer latency. Increase transcoding performance. Create real-time analytics of viewer consumption patterns and engagement. Create a data mart to enable processing of large volumes of race data.\n<strong>Executive statement: </strong><br> Our CEO, S. Hawke, wants to bring high-adrenaline racing to fans all around the world. We listen to our fans, and they want enhanced video streams that include predictions of events within the race (e.g., overtaking). Our current platform allows us to predict race outcomes but lacks the facility to support real-time predictions during races and the capacity to process season-long results."
  },
  {
    "id": 206,
    "topic": "Serverless",
    "question": "For this question, refer to the Helicopter Racing League (HRL) case study.\nThe HRL development team releases a new version of their predictive capability application every Tuesday evening at 3 a.m. UTC to a repository. The security team at HRL has developed an in-house penetration testing Cloud Function called Airwolf. The security team wants to run Airwolf against the predictive capability application as soon as it is released every Tuesday. You need to set up Airwolf to run at the recurring weekly cadence.\nWhat should you do?",
    "options": {
      "A": "Set up Cloud Tasks and a Cloud Storage bucket that triggers a Cloud Function.",
      "B": "Set up a Cloud Logging sink and a Cloud Storage bucket that triggers a Cloud Function.",
      "C": "Configure the deployment job to notify a Pub/Sub queue that triggers a Cloud Function.",
      "D": "Set up Identity and Access Management (IAM) and Confidential Computing to trigger a Cloud Function."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To trigger the security test function (Airwolf) immediately upon application release, an event-driven approach is best. Modifying the deployment job/pipeline to publish a message to a Pub/Sub topic upon successful completion (C) provides a clear signal. The Airwolf Cloud Function can then use a Pub/Sub trigger, listening to that topic, to execute automatically as soon as the release notification arrives. This is more direct and timely than scheduled tasks (A) or log-based triggers (B). IAM/Confidential Computing (D) are irrelevant.",
    "conditions": [
      "App released weekly (Tue 3 AM UTC)",
      "Run security test Cloud Function (Airwolf) immediately after release",
      "Set up trigger mechanism"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Helicopter Racing League (HRL) is a global sports league for competitive helicopter racing. Each year HRL holds the world championship and several regional league competitions where teams compete to earn a spot in the world championship. HRL offers a paid service to stream the races all over the world with live telemetry and predictions throughout each race.\n<strong>Solution Concept </strong>: HRL wants to migrate their existing service to a new platform to expand their use of managed Al and ML services to facilitate race predictions. Additionally, as new fans engage with the sport, particularly in emerging regions, they want to move the serving of their content, both real-time and recorded, closer to their users.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> HRL is a public cloud-first company; the core of their mission-critical applications runs on their current public cloud provider. Video recording and editing is performed at the race tracks, and the content is encoded and transcoded, where needed, in the cloud. Enterprise-grade connectivity and local compute is provided by truck-mounted mobile data centers. Their race prediction services are hosted exclusively on their existing public cloud provider. Their <strong>Existing Technical Environment </strong><br> is as follows: Existing content is stored in an object storage service on their existing public cloud provider. Video encoding and transcoding is performed on VMs created for each job. Race predictions are performed using TensorFlow running on VMs in the current public cloud provider.\n<strong><strong>Business Requirements </strong>: </strong><br> HRL's owners want to expand their predictive capabilities and reduce latency for their viewers in emerging markets. Their requirements are: Support ability to expose the predictive models to partners. Increase predictive capabilities during and before races: Race results, Mechanical failures, Crowd sentiment. Increase telemetry and create additional insights. Measure fan engagement with new predictions. Enhance global availability and quality of the broadcasts. Increase the number of concurrent viewers. Minimize operational complexity. Ensure compliance with regulations. Create a merchandising revenue stream.\n<strong>Technical requirements: </strong><br> Maintain or increase prediction throughput and accuracy. Reduce viewer latency. Increase transcoding performance. Create real-time analytics of viewer consumption patterns and engagement. Create a data mart to enable processing of large volumes of race data.\n<strong>Executive statement: </strong><br> Our CEO, S. Hawke, wants to bring high-adrenaline racing to fans all around the world. We listen to our fans, and they want enhanced video streams that include predictions of events within the race (e.g., overtaking). Our current platform allows us to predict race outcomes but lacks the facility to support real-time predictions during races and the capacity to process season-long results."
  },
  {
    "id": 207,
    "topic": "AI & ML",
    "question": "For this question, refer to the Helicopter Racing League (HRL) case study.\nHRL wants better prediction accuracy from their ML prediction models. They want you to use Google's Al Platform so HRL can understand and interpret the predictions.\nWhat should you do?",
    "options": {
      "A": "Use Explainable Al.",
      "B": "Use Vision Al.",
      "C": "Use Google Cloud's operations suite.",
      "D": "Use Jupyter Notebooks."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Explainable AI (XAI), integrated with Vertex AI (formerly AI Platform), provides tools and techniques (like feature attributions) to understand *why* an ML model made a specific prediction. This directly addresses HRL's requirement to understand and interpret their model's predictions.",
    "conditions": [
      "Use AI Platform (Vertex AI) for ML models",
      "Need to understand and interpret model predictions"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Helicopter Racing League (HRL) is a global sports league for competitive helicopter racing. Each year HRL holds the world championship and several regional league competitions where teams compete to earn a spot in the world championship. HRL offers a paid service to stream the races all over the world with live telemetry and predictions throughout each race.\n<strong>Solution Concept </strong>: HRL wants to migrate their existing service to a new platform to expand their use of managed Al and ML services to facilitate race predictions. Additionally, as new fans engage with the sport, particularly in emerging regions, they want to move the serving of their content, both real-time and recorded, closer to their users.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> HRL is a public cloud-first company; the core of their mission-critical applications runs on their current public cloud provider. Video recording and editing is performed at the race tracks, and the content is encoded and transcoded, where needed, in the cloud. Enterprise-grade connectivity and local compute is provided by truck-mounted mobile data centers. Their race prediction services are hosted exclusively on their existing public cloud provider. Their <strong>Existing Technical Environment </strong><br> is as follows: Existing content is stored in an object storage service on their existing public cloud provider. Video encoding and transcoding is performed on VMs created for each job. Race predictions are performed using TensorFlow running on VMs in the current public cloud provider.\n<strong><strong>Business Requirements </strong>: </strong><br> HRL's owners want to expand their predictive capabilities and reduce latency for their viewers in emerging markets. Their requirements are: Support ability to expose the predictive models to partners. Increase predictive capabilities during and before races: Race results, Mechanical failures, Crowd sentiment. Increase telemetry and create additional insights. Measure fan engagement with new predictions. Enhance global availability and quality of the broadcasts. Increase the number of concurrent viewers. Minimize operational complexity. Ensure compliance with regulations. Create a merchandising revenue stream.\n<strong>Technical requirements: </strong><br> Maintain or increase prediction throughput and accuracy. Reduce viewer latency. Increase transcoding performance. Create real-time analytics of viewer consumption patterns and engagement. Create a data mart to enable processing of large volumes of race data.\n<strong>Executive statement: </strong><br> Our CEO, S. Hawke, wants to bring high-adrenaline racing to fans all around the world. We listen to our fans, and they want enhanced video streams that include predictions of events within the race (e.g., overtaking). Our current platform allows us to predict race outcomes but lacks the facility to support real-time predictions during races and the capacity to process season-long results."
  },
  {
    "id": 208,
    "topic": "Data Analytics",
    "question": "For this question, refer to the Helicopter Racing League (HRL) case study.\nHRL is looking for a cost-effective approach for storing their race data such as telemetry. They want to keep all historical records, train models using only the previous season's data, and plan for data growth in terms of volume and information collected.\nYou need to propose a data solution.\nConsidering HRL <strong>Business Requirements </strong><br> and the goals expressed by CEO S. Hawke, what should you do?",
    "options": {
      "A": "Use Firestore for its scalable and flexible document-based database. Use collections to aggregate race data by season and event. a",
      "B": "Use Cloud Spanner for its scalability and ability to version schemas with zero downtime. Split race data using season as a primary key.",
      "C": "Use BigQuery for its scalability and ability to add columns to a schema. Partition race data based on season.",
      "D": "Use Cloud SQL for its ability to automatically manage storage increases and compatibility with MySQL. Use separate database instances for each season."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Requirements include storing historical race/telemetry data, handling growth, querying previous season's data for ML, and enabling large-volume processing (CEO goal). BigQuery is the most suitable GCP service: it's highly scalable for large volumes, supports schema evolution (adding columns), and allows efficient querying of specific time periods using partitioning (e.g., by date/time, then filtering for the previous season). Partitioning helps manage costs and query performance. Firestore (A), Spanner (B), and Cloud SQL (D) are less suited for large-scale analytics on historical telemetry data.",
    "conditions": [
      "Cost-effective storage for race/telemetry data",
      "Keep all historical records",
      "Train models on previous season's data",
      "Handle data growth (volume, new fields)",
      "Enable processing of large volumes (CEO goal)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Helicopter Racing League (HRL) is a global sports league for competitive helicopter racing. Each year HRL holds the world championship and several regional league competitions where teams compete to earn a spot in the world championship. HRL offers a paid service to stream the races all over the world with live telemetry and predictions throughout each race.\n<strong>Solution Concept </strong>: HRL wants to migrate their existing service to a new platform to expand their use of managed Al and ML services to facilitate race predictions. Additionally, as new fans engage with the sport, particularly in emerging regions, they want to move the serving of their content, both real-time and recorded, closer to their users.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> HRL is a public cloud-first company; the core of their mission-critical applications runs on their current public cloud provider. Video recording and editing is performed at the race tracks, and the content is encoded and transcoded, where needed, in the cloud. Enterprise-grade connectivity and local compute is provided by truck-mounted mobile data centers. Their race prediction services are hosted exclusively on their existing public cloud provider. Their <strong>Existing Technical Environment </strong><br> is as follows: Existing content is stored in an object storage service on their existing public cloud provider. Video encoding and transcoding is performed on VMs created for each job. Race predictions are performed using TensorFlow running on VMs in the current public cloud provider.\n<strong><strong>Business Requirements </strong>: </strong><br> HRL's owners want to expand their predictive capabilities and reduce latency for their viewers in emerging markets. Their requirements are: Support ability to expose the predictive models to partners. Increase predictive capabilities during and before races: Race results, Mechanical failures, Crowd sentiment. Increase telemetry and create additional insights. Measure fan engagement with new predictions. Enhance global availability and quality of the broadcasts. Increase the number of concurrent viewers. Minimize operational complexity. Ensure compliance with regulations. Create a merchandising revenue stream.\n<strong>Technical requirements: </strong><br> Maintain or increase prediction throughput and accuracy. Reduce viewer latency. Increase transcoding performance. Create real-time analytics of viewer consumption patterns and engagement. Create a data mart to enable processing of large volumes of race data.\n<strong>Executive statement: </strong><br> Our CEO, S. Hawke, wants to bring high-adrenaline racing to fans all around the world. We listen to our fans, and they want enhanced video streams that include predictions of events within the race (e.g., overtaking). Our current platform allows us to predict race outcomes but lacks the facility to support real-time predictions during races and the capacity to process season-long results."
  },
  {
    "id": 209,
    "topic": "Compute",
    "question": "For this question, refer to the Helicopter Racing League (HRL) case study.\nA recent finance audit of cloud infrastructure noted an exceptionally high number of Compute Engine instances are allocated to do video encoding and transcoding. You suspect that these Virtual Machines are zombie machines that were not deleted after their workloads completed. You need to quickly get a list of which VM instances are idle.\nWhat should you do?",
    "options": {
      "A": "Log into each Compute Engine instance and collect disk, CPU, memory, and network usage statistics for analysis.",
      "B": "Use the gcloud compute instances list to list the virtual machine instances that have the idle: true label set.",
      "C": "Use the gcloud recommender command to list the idle virtual machine instances.",
      "D": "From the Google Console, identify which Compute Engine instances in the managed instance groups are no longer responding to health check probes."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Google Cloud's Active Assist Recommender includes an 'Idle VM Recommender' that automatically identifies instances with low utilization over a recent period. The `gcloud recommender recommendations list` command, filtered for the appropriate recommender ID (`google.compute.instance.IdleResourceRecommender`), provides a quick and automated way to identify potentially idle VMs.",
    "conditions": [
      "High number of GCE instances for video encoding",
      "Suspect 'zombie' (idle) VMs not deleted post-job",
      "Need quick list of idle VMs"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>Helicopter Racing League (HRL) is a global sports league for competitive helicopter racing. Each year HRL holds the world championship and several regional league competitions where teams compete to earn a spot in the world championship. HRL offers a paid service to stream the races all over the world with live telemetry and predictions throughout each race.\n<strong>Solution Concept </strong>: HRL wants to migrate their existing service to a new platform to expand their use of managed Al and ML services to facilitate race predictions. Additionally, as new fans engage with the sport, particularly in emerging regions, they want to move the serving of their content, both real-time and recorded, closer to their users.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> HRL is a public cloud-first company; the core of their mission-critical applications runs on their current public cloud provider. Video recording and editing is performed at the race tracks, and the content is encoded and transcoded, where needed, in the cloud. Enterprise-grade connectivity and local compute is provided by truck-mounted mobile data centers. Their race prediction services are hosted exclusively on their existing public cloud provider. Their <strong>Existing Technical Environment </strong><br> is as follows: Existing content is stored in an object storage service on their existing public cloud provider. Video encoding and transcoding is performed on VMs created for each job. Race predictions are performed using TensorFlow running on VMs in the current public cloud provider.\n<strong><strong>Business Requirements </strong>: </strong><br> HRL's owners want to expand their predictive capabilities and reduce latency for their viewers in emerging markets. Their requirements are: Support ability to expose the predictive models to partners. Increase predictive capabilities during and before races: Race results, Mechanical failures, Crowd sentiment. Increase telemetry and create additional insights. Measure fan engagement with new predictions. Enhance global availability and quality of the broadcasts. Increase the number of concurrent viewers. Minimize operational complexity. Ensure compliance with regulations. Create a merchandising revenue stream.\n<strong>Technical requirements: </strong><br> Maintain or increase prediction throughput and accuracy. Reduce viewer latency. Increase transcoding performance. Create real-time analytics of viewer consumption patterns and engagement. Create a data mart to enable processing of large volumes of race data.\n<strong>Executive statement: </strong><br> Our CEO, S. Hawke, wants to bring high-adrenaline racing to fans all around the world. We listen to our fans, and they want enhanced video streams that include predictions of events within the race (e.g., overtaking). Our current platform allows us to predict race outcomes but lacks the facility to support real-time predictions during races and the capacity to process season-long results."
  },
  {
    "id": 210,
    "topic": "Security",
    "question": "For this question, refer to the EHR Healthcare case study.\nYou are responsible for ensuring that EHR's use of Google Cloud will pass an upcoming privacy compliance audit. What should you do? (Choose two.)",
    "options": {
      "A": "Verify EHR's product usage against the list of compliant products on the Google Cloud compliance page.",
      "B": "Advise EHR to execute a Business Associate Agreement (BAA) with Google Cloud.",
      "C": "Use Firebase Authentication for EHR’s user facing applications.",
      "D": "Implement Prometheus to detect and prevent security breaches on EHR's web-based applications.",
      "E": "Use GKE private clusters for all Kubernetes workloads."
    },
    "correctAnswer": [
      "A",
      "B"
    ],
    "explanation": "For privacy compliance (especially HIPAA in healthcare): A) Confirm that all GCP services handling sensitive data are included in Google's compliance scope (e.g., HIPAA-covered services list). B) Execute a Business Associate Agreement (BAA) with Google Cloud, which is a legal requirement outlining responsibilities for protecting patient data.",
    "conditions": [
      "Ensure GCP use passes privacy compliance audit (e.g., HIPAA)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>EHR Healthcare is a leading provider of electronic health record software to the medical industry. EHR Healthcare provides their software as a service to multi- national medical offices, hospitals, and insurance providers.\n<strong>Solution Concept </strong>: Due to rapid changes in the healthcare and insurance industry, EHR Healthcare's business has been growing exponentially year over year. They need to be able to scale their environment, adapt their disaster recovery plan, and roll out new continuous deployment capabilities to update their software at a fast pace. Google Cloud has been chosen to replace their current colocation facilities.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> EHR's software is currently hosted in multiple colocation facilities. The lease on one of the data centers is about to expire. Customer-facing applications are web-based, and many have recently been containerized to run on a group of Kubernetes clusters. Data is stored in a mixture of relational and NoSQL databases (MySQL, MS SQL Server, Redis, and MongoDB). EHR is hosting several legacy file- and API-based integrations with insurance providers on-premises. These systems are scheduled to be replaced over the next several years. There is no plan to upgrade or move these systems at the current time. Users are managed via Microsoft Active Directory. Monitoring is currently being done via various open source tools. Alerts are sent via email and are often ignored.\n<strong><strong>Business Requirements </strong>: </strong><br> On-board new insurance providers as quickly as possible. Provide a minimum 99.9% availability for all customer-facing systems. Provide centralized visibility and proactive action on system performance and usage. Increase ability to provide insights into healthcare trends. Reduce latency to all customers. Maintain regulatory compliance. Decrease infrastructure administration costs. Make predictions and generate reports on industry trends based on provider data.\n<strong>Technical requirements: </strong><br> Maintain legacy interfaces to insurance providers with connectivity to both on-premises systems and cloud providers. Provide a consistent way to manage customer-facing applications that are container-based. Provide a secure and high-performance connection between on-premises systems and Google Cloud. Provide consistent logging, log retention, monitoring, and alerting capabilities. Maintain and manage multiple container-based environments. Dynamically scale and provision new environments. Create interfaces to ingest and process data from new providers.\n<strong>Executive statement: </strong><br> Our on-premises strategy has worked for years but has required a major investment of time and money in training our team on distinctly different systems, managing similar but separate environments, and responding to outages. Many of these outages have been a result of misconfigured systems, inadequate capacity to manage spikes in traffic, and inconsistent monitoring practices. We want to use Google Cloud to leverage a scalable, resilient platform that can span multiple environments seamlessly and provide a consistent and stable user experience that positions us for future growth."
  },
  {
    "id": 211,
    "topic": "Security",
    "question": "For this question, refer to the EHR Healthcare case study.\nYou need to define the technical architecture for securely deploying workloads to Google Cloud. You also need to ensure that only verified containers are deployed using Google Cloud services.\nWhat should you do? (Choose two.)",
    "options": {
      "A": "Enable Binary Authorization on GKE, and sign containers as part of a CI/CD pipeline.",
      "B": "Configure Jenkins to utilize Kritis to cryptographically sign a container as part of a CI/CD pipeline.",
      "C": "Configure Container Registry to only allow trusted service accounts to create and deploy containers from the registry.",
      "D": "Configure Container Registry to use vulnerability scanning to confirm that there are no vulnerabilities before deploying the workload."
    },
    "correctAnswer": [
      "A",
      "D"
    ],
    "explanation": "To ensure only verified containers are deployed: A) Enable Binary Authorization to enforce policies requiring signed attestations before deployment. D) Use Container/Artifact Registry vulnerability scanning to identify issues; results inform the attestation process for Binary Authorization.",
    "conditions": [
      "Secure workload deployment",
      "Ensure only verified containers deployed",
      "Use GCP services"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>EHR Healthcare is a leading provider of electronic health record software to the medical industry. EHR Healthcare provides their software as a service to multi- national medical offices, hospitals, and insurance providers.\n<strong>Solution Concept </strong>: Due to rapid changes in the healthcare and insurance industry, EHR Healthcare's business has been growing exponentially year over year. They need to be able to scale their environment, adapt their disaster recovery plan, and roll out new continuous deployment capabilities to update their software at a fast pace. Google Cloud has been chosen to replace their current colocation facilities.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> EHR's software is currently hosted in multiple colocation facilities. The lease on one of the data centers is about to expire. Customer-facing applications are web-based, and many have recently been containerized to run on a group of Kubernetes clusters. Data is stored in a mixture of relational and NoSQL databases (MySQL, MS SQL Server, Redis, and MongoDB). EHR is hosting several legacy file- and API-based integrations with insurance providers on-premises. These systems are scheduled to be replaced over the next several years. There is no plan to upgrade or move these systems at the current time. Users are managed via Microsoft Active Directory. Monitoring is currently being done via various open source tools. Alerts are sent via email and are often ignored.\n<strong><strong>Business Requirements </strong>: </strong><br> On-board new insurance providers as quickly as possible. Provide a minimum 99.9% availability for all customer-facing systems. Provide centralized visibility and proactive action on system performance and usage. Increase ability to provide insights into healthcare trends. Reduce latency to all customers. Maintain regulatory compliance. Decrease infrastructure administration costs. Make predictions and generate reports on industry trends based on provider data.\n<strong>Technical requirements: </strong><br> Maintain legacy interfaces to insurance providers with connectivity to both on-premises systems and cloud providers. Provide a consistent way to manage customer-facing applications that are container-based. Provide a secure and high-performance connection between on-premises systems and Google Cloud. Provide consistent logging, log retention, monitoring, and alerting capabilities. Maintain and manage multiple container-based environments. Dynamically scale and provision new environments. Create interfaces to ingest and process data from new providers.\n<strong>Executive statement: </strong><br> Our on-premises strategy has worked for years but has required a major investment of time and money in training our team on distinctly different systems, managing similar but separate environments, and responding to outages. Many of these outages have been a result of misconfigured systems, inadequate capacity to manage spikes in traffic, and inconsistent monitoring practices. We want to use Google Cloud to leverage a scalable, resilient platform that can span multiple environments seamlessly and provide a consistent and stable user experience that positions us for future growth."
  },
  {
    "id": 212,
    "topic": "Networking",
    "question": "For this question, refer to the EHR Healthcare case study.\nYou need to upgrade the EHR connection to comply with their requirements. The new connection design must support business-critical needs and meet the same network and security policy requirements.\nWhat should you do?",
    "options": {
      "A": "Add a new Dedicated Interconnect connection.",
      "B": "Upgrade the bandwidth on the Dedicated Interconnect connection to 100 G.",
      "C": "Add three new Cloud VPN connections.",
      "D": "Add a new Carrier Peering connection."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Requirements include high performance, security, and 99.9% availability. Adding a second Dedicated Interconnect connection (A) provides redundancy and maintains high performance, crucial for business-critical needs and improving availability beyond what a single connection or VPN typically offers.",
    "conditions": [
      "Upgrade hybrid connection",
      "Support business-critical needs",
      "Meet network/security policies",
      "Requirements: High performance, secure, 99.9% availability"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>EHR Healthcare is a leading provider of electronic health record software to the medical industry. EHR Healthcare provides their software as a service to multi- national medical offices, hospitals, and insurance providers.\n<strong>Solution Concept </strong>: Due to rapid changes in the healthcare and insurance industry, EHR Healthcare's business has been growing exponentially year over year. They need to be able to scale their environment, adapt their disaster recovery plan, and roll out new continuous deployment capabilities to update their software at a fast pace. Google Cloud has been chosen to replace their current colocation facilities.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> EHR's software is currently hosted in multiple colocation facilities. The lease on one of the data centers is about to expire. Customer-facing applications are web-based, and many have recently been containerized to run on a group of Kubernetes clusters. Data is stored in a mixture of relational and NoSQL databases (MySQL, MS SQL Server, Redis, and MongoDB). EHR is hosting several legacy file- and API-based integrations with insurance providers on-premises. These systems are scheduled to be replaced over the next several years. There is no plan to upgrade or move these systems at the current time. Users are managed via Microsoft Active Directory. Monitoring is currently being done via various open source tools. Alerts are sent via email and are often ignored.\n<strong><strong>Business Requirements </strong>: </strong><br> On-board new insurance providers as quickly as possible. Provide a minimum 99.9% availability for all customer-facing systems. Provide centralized visibility and proactive action on system performance and usage. Increase ability to provide insights into healthcare trends. Reduce latency to all customers. Maintain regulatory compliance. Decrease infrastructure administration costs. Make predictions and generate reports on industry trends based on provider data.\n<strong>Technical requirements: </strong><br> Maintain legacy interfaces to insurance providers with connectivity to both on-premises systems and cloud providers. Provide a consistent way to manage customer-facing applications that are container-based. Provide a secure and high-performance connection between on-premises systems and Google Cloud. Provide consistent logging, log retention, monitoring, and alerting capabilities. Maintain and manage multiple container-based environments. Dynamically scale and provision new environments. Create interfaces to ingest and process data from new providers.\n<strong>Executive statement: </strong><br> Our on-premises strategy has worked for years but has required a major investment of time and money in training our team on distinctly different systems, managing similar but separate environments, and responding to outages. Many of these outages have been a result of misconfigured systems, inadequate capacity to manage spikes in traffic, and inconsistent monitoring practices. We want to use Google Cloud to leverage a scalable, resilient platform that can span multiple environments seamlessly and provide a consistent and stable user experience that positions us for future growth."
  },
  {
    "id": 213,
    "topic": "Networking",
    "question": "For this question, refer to the EHR Healthcare case study.\nYou need to define the technical architecture for hybrid connectivity between EHR's on-premises systems and Google Cloud. You want to follow Google's recommended practices for production-level applications.\nConsidering the EHR Healthcare business and technical requirements, what should you do?",
    "options": {
      "A": "Configure two Partner Interconnect connections in one metro (City), and make sure the Interconnect connections are placed in different metro zones.",
      "B": "Configure two VPN connections from on-premises to Google Cloud, and make sure the VPN devices on-premises are in separate racks.",
      "C": "Configure Direct Peering between EHR Healthcare and Google Cloud, and make sure you are peering at least two Google locations.",
      "D": "Configure two Dedicated Interconnect connections in one metro (City) and two connections in another metro, and make sure the Interconnect connections are placed in different metro zones."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "For maximum availability (targeting 99.99% SLA) for production hybrid connectivity, Google recommends the most resilient Dedicated Interconnect topology: four connections total, two in one metro (different zones) and two in a second metro (different zones). This protects against link, zone, and metro failures.",
    "conditions": [
      "Define hybrid connectivity architecture",
      "Follow Google recommended practices for production",
      "Requirements: High availability (99.9%), secure, high-performance"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>EHR Healthcare is a leading provider of electronic health record software to the medical industry. EHR Healthcare provides their software as a service to multi- national medical offices, hospitals, and insurance providers.\n<strong>Solution Concept </strong>: Due to rapid changes in the healthcare and insurance industry, EHR Healthcare's business has been growing exponentially year over year. They need to be able to scale their environment, adapt their disaster recovery plan, and roll out new continuous deployment capabilities to update their software at a fast pace. Google Cloud has been chosen to replace their current colocation facilities.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> EHR's software is currently hosted in multiple colocation facilities. The lease on one of the data centers is about to expire. Customer-facing applications are web-based, and many have recently been containerized to run on a group of Kubernetes clusters. Data is stored in a mixture of relational and NoSQL databases (MySQL, MS SQL Server, Redis, and MongoDB). EHR is hosting several legacy file- and API-based integrations with insurance providers on-premises. These systems are scheduled to be replaced over the next several years. There is no plan to upgrade or move these systems at the current time. Users are managed via Microsoft Active Directory. Monitoring is currently being done via various open source tools. Alerts are sent via email and are often ignored.\n<strong><strong>Business Requirements </strong>: </strong><br> On-board new insurance providers as quickly as possible. Provide a minimum 99.9% availability for all customer-facing systems. Provide centralized visibility and proactive action on system performance and usage. Increase ability to provide insights into healthcare trends. Reduce latency to all customers. Maintain regulatory compliance. Decrease infrastructure administration costs. Make predictions and generate reports on industry trends based on provider data.\n<strong>Technical requirements: </strong><br> Maintain legacy interfaces to insurance providers with connectivity to both on-premises systems and cloud providers. Provide a consistent way to manage customer-facing applications that are container-based. Provide a secure and high-performance connection between on-premises systems and Google Cloud. Provide consistent logging, log retention, monitoring, and alerting capabilities. Maintain and manage multiple container-based environments. Dynamically scale and provision new environments. Create interfaces to ingest and process data from new providers.\n<strong>Executive statement: </strong><br> Our on-premises strategy has worked for years but has required a major investment of time and money in training our team on distinctly different systems, managing similar but separate environments, and responding to outages. Many of these outages have been a result of misconfigured systems, inadequate capacity to manage spikes in traffic, and inconsistent monitoring practices. We want to use Google Cloud to leverage a scalable, resilient platform that can span multiple environments seamlessly and provide a consistent and stable user experience that positions us for future growth."
  },
  {
    "id": 214,
    "topic": "Messaging",
    "question": "For this question, refer to the EHR Healthcare case study.\nYou are a developer on the EHR customer portal team. Your team recently migrated the customer portal application to Google Cloud. The load has increased on the application servers, and now the application is logging many timeout errors. You recently incorporated Pub/Sub into the application architecture, and the application is not logging any Pub/Sub publishing errors. You want to improve publishing latency.\nWhat should you do?",
    "options": {
      "A": "Increase the Pub/Sub Total Timeout retry value.",
      "B": "Move from a Pub/Sub subscriber pull model to a push model.",
      "C": "Turn off Pub/Sub message batching.",
      "D": "Create a backup Pub/Sub message queue."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The application experiences timeouts, but Pub/Sub publishing itself isn't failing. Pub/Sub client libraries often batch messages by default to optimize throughput, which can introduce minor latency for individual publishes. If application timeouts are sensitive to this publishing latency, disabling batching (C) forces messages to be sent immediately, potentially resolving the upstream timeout issue, albeit at the cost of potentially lower throughput and higher API call volume.",
    "conditions": [
      "App migrated to GCP",
      "Increased load causes app timeouts",
      "Pub/Sub used, no publishing errors",
      "Goal: Improve Pub/Sub *publishing* latency"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>EHR Healthcare is a leading provider of electronic health record software to the medical industry. EHR Healthcare provides their software as a service to multi- national medical offices, hospitals, and insurance providers.\n<strong>Solution Concept </strong>: Due to rapid changes in the healthcare and insurance industry, EHR Healthcare's business has been growing exponentially year over year. They need to be able to scale their environment, adapt their disaster recovery plan, and roll out new continuous deployment capabilities to update their software at a fast pace. Google Cloud has been chosen to replace their current colocation facilities.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> EHR's software is currently hosted in multiple colocation facilities. The lease on one of the data centers is about to expire. Customer-facing applications are web-based, and many have recently been containerized to run on a group of Kubernetes clusters. Data is stored in a mixture of relational and NoSQL databases (MySQL, MS SQL Server, Redis, and MongoDB). EHR is hosting several legacy file- and API-based integrations with insurance providers on-premises. These systems are scheduled to be replaced over the next several years. There is no plan to upgrade or move these systems at the current time. Users are managed via Microsoft Active Directory. Monitoring is currently being done via various open source tools. Alerts are sent via email and are often ignored.\n<strong><strong>Business Requirements </strong>: </strong><br> On-board new insurance providers as quickly as possible. Provide a minimum 99.9% availability for all customer-facing systems. Provide centralized visibility and proactive action on system performance and usage. Increase ability to provide insights into healthcare trends. Reduce latency to all customers. Maintain regulatory compliance. Decrease infrastructure administration costs. Make predictions and generate reports on industry trends based on provider data.\n<strong>Technical requirements: </strong><br> Maintain legacy interfaces to insurance providers with connectivity to both on-premises systems and cloud providers. Provide a consistent way to manage customer-facing applications that are container-based. Provide a secure and high-performance connection between on-premises systems and Google Cloud. Provide consistent logging, log retention, monitoring, and alerting capabilities. Maintain and manage multiple container-based environments. Dynamically scale and provision new environments. Create interfaces to ingest and process data from new providers.\n<strong>Executive statement: </strong><br> Our on-premises strategy has worked for years but has required a major investment of time and money in training our team on distinctly different systems, managing similar but separate environments, and responding to outages. Many of these outages have been a result of misconfigured systems, inadequate capacity to manage spikes in traffic, and inconsistent monitoring practices. We want to use Google Cloud to leverage a scalable, resilient platform that can span multiple environments seamlessly and provide a consistent and stable user experience that positions us for future growth."
  },
  {
    "id": 215,
    "topic": "Networking",
    "question": "For this question, refer to the EHR Healthcare case study.\nIn the past, configuration errors put public IP addresses on backend servers that should not have been accessible from the Internet. You need to ensure that no one can put external IP addresses on backend Compute Engine instances and that external IP addresses can only be configured on frontend Compute Engine instances.\nWhat should you do?",
    "options": {
      "A": "Create an Organizational Policy with a constraint to allow external IP addresses only on the frontend Compute Engine instances.",
      "B": "Revoke the compute.networkAdmin role from all users in the project with front end instances. a",
      "C": "Create an Identity and Access Management (IAM) policy that maps the IT staff to the compute.networkAdmin role for the organization.",
      "D": "Create a custom Identity and Access Management (IAM) role named GCE_FRONTEND with the compute.addresses.create permission."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Organization Policies provide preventative controls. The `constraints/compute.vmExternalIpAccess` constraint can be used to deny external IPs for VMs by default at an organizational or folder level. You can then create exceptions or allow specific VMs (like frontends, possibly identified by tags or project location) to have external IPs, effectively enforcing the desired configuration (A). Relying on IAM roles (B, C, D) is less effective as someone with permission could still make a configuration error.",
    "conditions": [
      "Past issue: public IPs on backend servers",
      "Requirement: Prevent external IPs on backend GCE instances",
      "Requirement: Allow external IPs only on frontend GCE instances"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>EHR Healthcare is a leading provider of electronic health record software to the medical industry. EHR Healthcare provides their software as a service to multi- national medical offices, hospitals, and insurance providers.\n<strong>Solution Concept </strong>: Due to rapid changes in the healthcare and insurance industry, EHR Healthcare's business has been growing exponentially year over year. They need to be able to scale their environment, adapt their disaster recovery plan, and roll out new continuous deployment capabilities to update their software at a fast pace. Google Cloud has been chosen to replace their current colocation facilities.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> EHR's software is currently hosted in multiple colocation facilities. The lease on one of the data centers is about to expire. Customer-facing applications are web-based, and many have recently been containerized to run on a group of Kubernetes clusters. Data is stored in a mixture of relational and NoSQL databases (MySQL, MS SQL Server, Redis, and MongoDB). EHR is hosting several legacy file- and API-based integrations with insurance providers on-premises. These systems are scheduled to be replaced over the next several years. There is no plan to upgrade or move these systems at the current time. Users are managed via Microsoft Active Directory. Monitoring is currently being done via various open source tools. Alerts are sent via email and are often ignored.\n<strong><strong>Business Requirements </strong>: </strong><br> On-board new insurance providers as quickly as possible. Provide a minimum 99.9% availability for all customer-facing systems. Provide centralized visibility and proactive action on system performance and usage. Increase ability to provide insights into healthcare trends. Reduce latency to all customers. Maintain regulatory compliance. Decrease infrastructure administration costs. Make predictions and generate reports on industry trends based on provider data.\n<strong>Technical requirements: </strong><br> Maintain legacy interfaces to insurance providers with connectivity to both on-premises systems and cloud providers. Provide a consistent way to manage customer-facing applications that are container-based. Provide a secure and high-performance connection between on-premises systems and Google Cloud. Provide consistent logging, log retention, monitoring, and alerting capabilities. Maintain and manage multiple container-based environments. Dynamically scale and provision new environments. Create interfaces to ingest and process data from new providers.\n<strong>Executive statement: </strong><br> Our on-premises strategy has worked for years but has required a major investment of time and money in training our team on distinctly different systems, managing similar but separate environments, and responding to outages. Many of these outages have been a result of misconfigured systems, inadequate capacity to manage spikes in traffic, and inconsistent monitoring practices. We want to use Google Cloud to leverage a scalable, resilient platform that can span multiple environments seamlessly and provide a consistent and stable user experience that positions us for future growth."
  },
  {
    "id": 216,
    "topic": "Compute",
    "question": "For this question, refer to the EHR Healthcare case study.\nYou are responsible for designing the Google Cloud network architecture for Google Kubernetes Engine. You want to follow Google best practices.\nConsidering the EHR Healthcare business and technical requirements, what should you do to reduce the attack surface?",
    "options": {
      "A": "Use a private cluster with a private endpoint with master authorized networks configured.",
      "B": "Use a public cluster with firewall rules and Virtual Private Cloud (VPC) routes.",
      "C": "Use a private cluster with a public endpoint with master authorized networks configured.",
      "D": "Use a public cluster with master authorized networks enabled and firewall rules."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To maximally reduce the network attack surface for GKE, especially in sensitive environments like healthcare: Use a private cluster (nodes have no public IPs). Use a private endpoint for the control plane (master is only accessible via internal IPs). Configure master authorized networks to restrict access to the private endpoint to specific internal IP ranges (e.g., bastion hosts, internal network segments). Option A combines all these best practices.",
    "conditions": [
      "Design GKE network architecture",
      "Follow Google best practices",
      "Reduce attack surface",
      "EHR Healthcare context (implies high security needs)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>EHR Healthcare is a leading provider of electronic health record software to the medical industry. EHR Healthcare provides their software as a service to multi- national medical offices, hospitals, and insurance providers.\n<strong>Solution Concept </strong>: Due to rapid changes in the healthcare and insurance industry, EHR Healthcare's business has been growing exponentially year over year. They need to be able to scale their environment, adapt their disaster recovery plan, and roll out new continuous deployment capabilities to update their software at a fast pace. Google Cloud has been chosen to replace their current colocation facilities.\n<strong><strong>Existing Technical Environment </strong>: </strong><br> EHR's software is currently hosted in multiple colocation facilities. The lease on one of the data centers is about to expire. Customer-facing applications are web-based, and many have recently been containerized to run on a group of Kubernetes clusters. Data is stored in a mixture of relational and NoSQL databases (MySQL, MS SQL Server, Redis, and MongoDB). EHR is hosting several legacy file- and API-based integrations with insurance providers on-premises. These systems are scheduled to be replaced over the next several years. There is no plan to upgrade or move these systems at the current time. Users are managed via Microsoft Active Directory. Monitoring is currently being done via various open source tools. Alerts are sent via email and are often ignored.\n<strong><strong>Business Requirements </strong>: </strong><br> On-board new insurance providers as quickly as possible. Provide a minimum 99.9% availability for all customer-facing systems. Provide centralized visibility and proactive action on system performance and usage. Increase ability to provide insights into healthcare trends. Reduce latency to all customers. Maintain regulatory compliance. Decrease infrastructure administration costs. Make predictions and generate reports on industry trends based on provider data.\n<strong>Technical requirements: </strong><br> Maintain legacy interfaces to insurance providers with connectivity to both on-premises systems and cloud providers. Provide a consistent way to manage customer-facing applications that are container-based. Provide a secure and high-performance connection between on-premises systems and Google Cloud. Provide consistent logging, log retention, monitoring, and alerting capabilities. Maintain and manage multiple container-based environments. Dynamically scale and provision new environments. Create interfaces to ingest and process data from new providers.\n<strong>Executive statement: </strong><br> Our on-premises strategy has worked for years but has required a major investment of time and money in training our team on distinctly different systems, managing similar but separate environments, and responding to outages. Many of these outages have been a result of misconfigured systems, inadequate capacity to manage spikes in traffic, and inconsistent monitoring practices. We want to use Google Cloud to leverage a scalable, resilient platform that can span multiple environments seamlessly and provide a consistent and stable user experience that positions us for future growth."
  },
  {
    "id": 217,
    "topic": "DevOps",
    "question": "For this question, refer to the Mountkirk Games case study (v1 - listed above).\nMountkirk Games wants you to design their new testing strategy. How should the test coverage differ from their existing backends on the other platforms?",
    "options": {
      "A": "Tests should scale well beyond the prior approaches",
      "B": "Unit tests are no longer required, only end-to-end tests",
      "C": "Tests should be applied after the release is in the production environment",
      "D": "Tests should include directly testing the Google Cloud Platform (GCP) infrastructure"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Mountkirk Games' previous platform suffered from scaling issues. A key reason for moving to GCP is to leverage its scalability. Therefore, the new testing strategy must rigorously validate the application's ability to scale under load, going beyond the limits tested on the previous platform (A).",
    "conditions": [
      "Design new testing strategy for GCP",
      "Compare with previous testing",
      "Previous platform had scaling problems"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for the most popular mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform 1. Dynamically scale up or down based on game activity 2. Connect to a managed NoSQL database service 3. Run customize Linux distro. Requirements for Game Analytics Platform 1. Dynamically scale up or down based on game activity 2. Process incoming data on the fly directly from the game servers 3. Process data that arrives late because of slow mobile networks 4. Allow SQL queries to access at least 10 TB of historical data 5. Process files that are regularly uploaded by users’ mobile devices 6. Use only fully managed services.\n<strong>CEO Statement </strong><br> - Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users.\n<strong>CTO Statement  </strong><br>- Our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers.\nCFO Statement - We are not capturing enough user demographic data, usage metrics, and other KPls. As a result, we do not engage the right users, we are not confident that our marketing is targeting the right users, and we are not selling enough premium Blast-Ups inside the games, which dramatically impacts our revenue."
  },
  {
    "id": 218,
    "topic": "DevOps",
    "question": "For this question, refer to the Mountkirk Games case study (v1 - listed above).\nMountkirk Games has deployed their new backend on Google Cloud Platform (GCP). You want to create a through testing process for new versions of the backend before they are released to the public. You want the testing environment to scale in an economical way. How should you design the process?",
    "options": {
      "A": "Create a scalable environment in GCP for simulating production load",
      "B": "Use the existing infrastructure to test the GCP-based backend at scale",
      "C": "Build stress tests into each component of your application using resources internal to GCP to simulate load",
      "D": "Create a set of static environments in GCP to test different levels of load for example, high, medium, and low"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To effectively test a scalable cloud application before release, the testing environment should mirror production scale and elasticity. Creating a dedicated, scalable environment in GCP (A) allows simulating realistic peak loads economically by leveraging cloud resources on-demand (scale up for tests, scale down/off afterwards). Existing infra (B) likely cannot match GCP scale. Internal stress tests (C) are not comprehensive load tests. Static environments (D) are inefficient and costly.",
    "conditions": [
      "New backend deployed on GCP",
      "Need thorough pre-release testing",
      "Testing environment must scale economically"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for the most popular mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform 1. Dynamically scale up or down based on game activity 2. Connect to a managed NoSQL database service 3. Run customize Linux distro. Requirements for Game Analytics Platform 1. Dynamically scale up or down based on game activity 2. Process incoming data on the fly directly from the game servers 3. Process data that arrives late because of slow mobile networks 4. Allow SQL queries to access at least 10 TB of historical data 5. Process files that are regularly uploaded by users’ mobile devices 6. Use only fully managed services.\n<strong>CEO Statement </strong><br> - Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users.\n<strong>CTO Statement  </strong><br>- Our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers.\nCFO Statement - We are not capturing enough user demographic data, usage metrics, and other KPls. As a result, we do not engage the right users, we are not confident that our marketing is targeting the right users, and we are not selling enough premium Blast-Ups inside the games, which dramatically impacts our revenue."
  },
  {
    "id": 219,
    "topic": "DevOps",
    "question": "For this question, refer to the Mountkirk Games case study (v1 - listed above).\nMountkirk Games wants to set up a continuous delivery pipeline. Their architecture includes many small services that they want to be able to update and roll back quickly. Mountkirk Games has the following requirements:\n\n* Services are deployed redundantly across multiple regions in the US and Europe\n* Only frontend services are exposed on the public internet\n* They can provide a single frontend IP for their fleet of services\n* Deployment artifacts are immutable\n\nWhich set of products should they use?",
    "options": {
      "A": "Google Cloud Storage, Google Cloud Dataflow, Google Compute Engine",
      "B": "Google Cloud Storage, Google App Engine, Google Network Load Balancer",
      "C": "Google Kubernetes Registry, Google Container Engine, Google HTTP(S) Load Balancer",
      "D": "Google Cloud Functions, Google Cloud Pub/Sub, Google Cloud Deployment Manager"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Requirements point to a containerized microservices architecture deployed globally. GKE (Container Engine) supports multi-region clusters. Artifact Registry (formerly Container Registry) stores immutable container images. A Global HTTP(S) Load Balancer provides a single IP, handles routing to multiple regions, and allows exposing only frontend services. This combination (C) meets all requirements.",
    "conditions": [
      "CD pipeline for small services",
      "Quick updates/rollbacks",
      "Multi-region deployment (US, EU)",
      "Only frontend public",
      "Single frontend IP",
      "Immutable artifacts"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for the most popular mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform 1. Dynamically scale up or down based on game activity 2. Connect to a managed NoSQL database service 3. Run customize Linux distro. Requirements for Game Analytics Platform 1. Dynamically scale up or down based on game activity 2. Process incoming data on the fly directly from the game servers 3. Process data that arrives late because of slow mobile networks 4. Allow SQL queries to access at least 10 TB of historical data 5. Process files that are regularly uploaded by users’ mobile devices 6. Use only fully managed services.\n<strong>CEO Statement </strong><br> - Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users.\n<strong>CTO Statement  </strong><br>- Our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers.\nCFO Statement - We are not capturing enough user demographic data, usage metrics, and other KPls. As a result, we do not engage the right users, we are not confident that our marketing is targeting the right users, and we are not selling enough premium Blast-Ups inside the games, which dramatically impacts our revenue."
  },
  {
    "id": 220,
    "topic": "Compute",
    "question": "For this question, refer to the Mountkirk Games case study (v1 - listed above).\nMountkirk Games’ gaming servers are not automatically scaling properly. Last month, they rolled out a new feature, which suddenly became very popular. A record number of users are trying to use the service, but many of them are getting 503 errors and very slow response times.\nWhat should they investigate first?",
    "options": {
      "A": "Verify that the database is online",
      "B": "Verify that the project quota hasn't been exceeded",
      "C": "Verify that the new feature code did not introduce any performance bugs",
      "D": "Verify that the load-testing team is not running their tool against production"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "When autoscaling fails during a sudden load increase, hitting resource quotas (like CPU limits, instance limits per region, load balancer limits) is a very common cause. Before diving into code performance (C) or database issues (A), checking project quotas (B) is often the quickest way to identify why the infrastructure cannot scale out further to meet demand.",
    "conditions": [
      "Autoscaled game servers failing to scale",
      "Sudden popularity spike",
      "Symptoms: 503 errors, slow responses",
      "Investigate first step"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for the most popular mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform 1. Dynamically scale up or down based on game activity 2. Connect to a managed NoSQL database service 3. Run customize Linux distro. Requirements for Game Analytics Platform 1. Dynamically scale up or down based on game activity 2. Process incoming data on the fly directly from the game servers 3. Process data that arrives late because of slow mobile networks 4. Allow SQL queries to access at least 10 TB of historical data 5. Process files that are regularly uploaded by users’ mobile devices 6. Use only fully managed services.\n<strong>CEO Statement </strong><br> - Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users.\n<strong>CTO Statement  </strong><br>- Our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers.\nCFO Statement - We are not capturing enough user demographic data, usage metrics, and other KPls. As a result, we do not engage the right users, we are not confident that our marketing is targeting the right users, and we are not selling enough premium Blast-Ups inside the games, which dramatically impacts our revenue."
  },
  {
    "id": 221,
    "topic": "IAM & Security",
    "question": "For this question, refer to the Mountkirk Games case study (v1 - listed above).\nMountkirk Games needs to create a repeatable and configurable mechanism for deploying isolated application environments. Developers and testers can access each other's environments and resources, but they cannot access staging or production resources. The staging environment needs access to some services from production.\nWhat should you do to isolate development environments from staging and production?",
    "options": {
      "A": "Create a project for development and test and another for staging and production",
      "B": "Create a network for development and test and another for staging and production",
      "C": "Create one subnetwork for development and another for staging and production",
      "D": "Create one project for development, a second for staging and a third for production"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Using separate GCP Projects for each environment (Development, Staging, Production) provides the strongest isolation for resources and IAM policies. This allows granting appropriate access within Dev/Test, restricting access to Staging/Prod, and carefully granting Staging access to specific Production services via cross-project IAM or network configurations.",
    "conditions": [
      "Deploy isolated environments (Dev, Test, Staging, Prod)",
      "Dev/Testers access each other, not Staging/Prod",
      "Staging needs access to some Prod services"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for the most popular mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform 1. Dynamically scale up or down based on game activity 2. Connect to a managed NoSQL database service 3. Run customize Linux distro. Requirements for Game Analytics Platform 1. Dynamically scale up or down based on game activity 2. Process incoming data on the fly directly from the game servers 3. Process data that arrives late because of slow mobile networks 4. Allow SQL queries to access at least 10 TB of historical data 5. Process files that are regularly uploaded by users’ mobile devices 6. Use only fully managed services.\n<strong>CEO Statement </strong><br> - Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users.\n<strong>CTO Statement  </strong><br>- Our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers.\nCFO Statement - We are not capturing enough user demographic data, usage metrics, and other KPls. As a result, we do not engage the right users, we are not confident that our marketing is targeting the right users, and we are not selling enough premium Blast-Ups inside the games, which dramatically impacts our revenue."
  },
  {
    "id": 222,
    "topic": "Data Processing",
    "question": "For this question, refer to the Mountkirk Games case study (v1 - listed above).\nMountkirk Games wants to set up a real-time analytics platform for their new game. The new platform must meet their technical requirements.\nWhich combination of Google technologies will meet all of their requirements?",
    "options": {
      "A": "Kubernetes Engine, Cloud Pub/Sub, and Cloud SQL",
      "B": "Cloud Dataflow, Cloud Storage, Cloud Pub/Sub, and BigQuery",
      "C": "Cloud SQL, Cloud Storage, Cloud Pub/Sub, and Cloud Dataflow",
      "D": "Cloud Dataproc, Cloud Pub/Sub, Cloud SQL, and Cloud Dataflow",
      "E": "Cloud Pub/Sub, Compute Engine, Cloud Storage, and Cloud Dataproc"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Analyzing Game Analytics Platform requirements: 1. Scale: Pub/Sub, Dataflow, GCS, BQ all scale. 2. Process on the fly: Pub/Sub + Dataflow. 3. Late data: Dataflow. 4. SQL on 10TB+: BigQuery. 5. Process uploaded files: Dataflow + GCS. 6. Managed: All listed in B are managed. Therefore, Cloud Pub/Sub (ingestion), Cloud Dataflow (processing stream/batch/late data), Cloud Storage (file uploads), and BigQuery (analytics DB) meet all requirements (B).",
    "conditions": [
      "Set up real-time analytics platform",
      "Meet Game Analytics Platform technical requirements (v1)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for the most popular mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform 1. Dynamically scale up or down based on game activity 2. Connect to a managed NoSQL database service 3. Run customize Linux distro. Requirements for Game Analytics Platform 1. Dynamically scale up or down based on game activity 2. Process incoming data on the fly directly from the game servers 3. Process data that arrives late because of slow mobile networks 4. Allow SQL queries to access at least 10 TB of historical data 5. Process files that are regularly uploaded by users’ mobile devices 6. Use only fully managed services.\n<strong>CEO Statement </strong><br> - Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users.\n<strong>CTO Statement  </strong><br>- Our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers.\nCFO Statement - We are not capturing enough user demographic data, usage metrics, and other KPls. As a result, we do not engage the right users, we are not confident that our marketing is targeting the right users, and we are not selling enough premium Blast-Ups inside the games, which dramatically impacts our revenue."
  },
  {
    "id": 223,
    "topic": "Migration",
    "question": "For this question, refer to the Mountkirk Games case study (v2 - listed above).\nMountkirk Games wants to migrate from their current analytics and statistics reporting model to one that meets their technical requirements on Google Cloud Platform.\nWhich two steps should be part of their migration plan? (Choose two.)",
    "options": {
      "A": "Evaluate the impact of migrating their current batch ETL code to Cloud Dataflow.",
      "B": "Write a schema migration plan to denormalize data for better performance in BigQuery.",
      "C": "Draw an architecture diagram that shows how to move from a single MySQL database to a MySQL cluster.",
      "D": "Load 10 TB of analytics data from a previous game into a Cloud SQL instance, and run test queries against the full dataset to confirm that they complete successfully.",
      "E": "Integrate Cloud Armor to defend against possible SQL injection attacks in analytics files uploaded to Cloud Storage."
    },
    "correctAnswer": [
      "A",
      "B"
    ],
    "explanation": "The current model is ETL to MySQL. The target should leverage GCP managed services meeting analytics requirements (likely Pub/Sub -> Dataflow -> BigQuery). Key migration steps include: A) Assessing the existing ETL logic and planning its migration/rewrite for Cloud Dataflow. B) Designing a BigQuery schema, likely involving denormalization (from the presumed relational MySQL schema) to optimize analytical query performance.",
    "conditions": [
      "Migrate current analytics (ETL -> MySQL)",
      "Target: Meet technical requirements on GCP (v2)",
      "Identify two migration plan steps"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers, MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics, run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform Dynamically scale up or down based on game activity. Connect to a transactional database service to manage user profiles and game state. Store game activity in a timeseries database service for future analysis. As the system scales, ensure that data is not lost due to processing backlogs. Run hardened Linux distro. Requirements for Game Analytics Platform Dynamically scale up or down based on game activity. Process incoming data on the fly directly from the game servers. Process data that arrives late because of slow mobile networks. Allow queries to access at least 10 TB of historical data. Process files that are regularly uploaded by users' mobile devices.\n<strong>Executive Statement -</strong> Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users. Additionally, our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers."
  }, {
    "id": 224,
    "topic": "Compute",
    "question": "For this question, refer to the Mountkirk Games case study (v2 - listed above).\nYou need to analyze and define the technical architecture for the compute workloads for your company, Mountkirk Games.\nConsidering the Mountkirk Games business and technical requirements, what should you do?",
    "options": {
      "A": "Create network load balancers. Use preemptible Compute Engine instances.",
      "B": "Create network load balancers. Use non-preemptible Compute Engine instances.",
      "C": "Create a global load balancer with managed instance groups and autoscaling policies. Use preemptible Compute Engine instances.",
      "D": "Create a global load balancer with managed instance groups and autoscaling policies. Use non-preemptible Compute Engine instances."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "<strong>Business Requirements </strong><br> include global footprint, improved uptime (downtime = lost players), and reduced latency. Technical requirements include dynamic scaling. This points to using a Global Load Balancer (for global reach and latency reduction) fronting Managed Instance Groups (MIGs) with autoscaling policies (for dynamic scaling). Since downtime is critical ('downtime is loss of players'), non-preemptible instances (D) are required for the production game backend to ensure availability. Preemptible instances (A, C) can be terminated with short notice, unsuitable for the primary game servers. Network Load Balancers (A, B) are regional, not global.",
    "conditions": [
      "Define compute workload architecture",
      "<strong><strong>Business Requirements </strong>: </strong><br> global footprint, improve uptime, reduce latency",
      "<strong>Technical requirements: </strong><br> dynamically scale up or down based on game activity, run hardened Linux distro"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers, MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics, run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform Dynamically scale up or down based on game activity. Connect to a transactional database service to manage user profiles and game state. Store game activity in a timeseries database service for future analysis. As the system scales, ensure that data is not lost due to processing backlogs. Run hardened Linux distro. Requirements for Game Analytics Platform Dynamically scale up or down based on game activity. Process incoming data on the fly directly from the game servers. Process data that arrives late because of slow mobile networks. Allow queries to access at least 10 TB of historical data. Process files that are regularly uploaded by users' mobile devices.\n<strong>Executive Statement -</strong> Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users. Additionally, our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers."
  },
  {
    "id": 225,
    "topic": "DevOps",
    "question": "For this question, refer to the Mountkirk Games case study (v2 - listed above).\nMountkirk Games wants you to design their solution for the future in order to take advantage of cloud and technology improvements as they become available.\nWhich two steps should they take? (Choose two.)",
    "options": {
      "A": "Store as much analytics and game activity data as financially feasible today so it can be used to train machine learning models to predict user behavior in the future.",
      "B": "Begin packaging their game backend artifacts in container images and running them on Google Kubernetes Engine to improve the ability to scale up or down based on game activity.",
      "C": "Set up a CI/CD pipeline using Jenkins and Spinnaker to automate canary deployments and improve development velocity.",
      "D": "Adopt a schema versioning tool to reduce downtime when adding new game features that require storing additional player data in the database.",
      "E": "Implement a weekly rolling maintenance process for the Linux virtual machines so they can apply critical kernel patches and package updates and reduce the risk of 0-day vulnerabilities."
    },
    "correctAnswer": [
      "B",
      "C"
    ],
    "explanation": "Future-proofing involves adopting modern, flexible technologies and practices. B: Containerizing applications with Docker and using an orchestrator like GKE provides portability, improves scalability, and aligns with cloud-native patterns, making it easier to adopt future cloud technologies. C: Implementing a robust CI/CD pipeline with automated deployment strategies (like canary using Spinnaker or other tools) improves development velocity, reliability, and the ability to quickly adopt and release changes.",
    "conditions": [
      "Design solution for the future",
      "Take advantage of future cloud/tech improvements"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers, MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics, run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform Dynamically scale up or down based on game activity. Connect to a transactional database service to manage user profiles and game state. Store game activity in a timeseries database service for future analysis. As the system scales, ensure that data is not lost due to processing backlogs. Run hardened Linux distro. Requirements for Game Analytics Platform Dynamically scale up or down based on game activity. Process incoming data on the fly directly from the game servers. Process data that arrives late because of slow mobile networks. Allow queries to access at least 10 TB of historical data. Process files that are regularly uploaded by users' mobile devices.\n<strong>Executive Statement -</strong> Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users. Additionally, our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers."
  },
  {
    "id": 226,
    "topic": "DevOps",
    "question": "For this question, refer to the Mountkirk Games case study (v2 - listed above).\nMountkirk Games wants you to design a way to test the analytics platform's resilience to changes in mobile network latency.\nWhat should you do?",
    "options": {
      "A": "Deploy failure injection software to the game analytics platform that can inject additional latency to mobile client analytics traffic.",
      "B": "Build a test client that can be run from a mobile phone emulator on a Compute Engine virtual machine, and run multiple copies in Google Cloud Platform regions all over the world to generate realistic traffic.",
      "C": "Add the ability to introduce a random amount of delay before beginning to process analytics files uploaded from mobile devices.",
      "D": "Create an opt-in beta of the game that runs on players' mobile devices and collects response times from analytics endpoints running in Google Cloud Platform regions all over the world."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The analytics platform needs to handle data arriving late due to mobile network latency. To test this resilience, simulating the *effect* of latency (delayed arrival of data) on the *processing* side is key. Option C, introducing a random delay before processing uploaded files, directly mimics this condition and tests if the platform correctly handles potentially out-of-order or delayed data inputs.",
    "conditions": [
      "Test analytics platform resilience to mobile network latency variations",
      "Analytics platform processes uploaded files and handles late data"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers, MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics, run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform Dynamically scale up or down based on game activity. Connect to a transactional database service to manage user profiles and game state. Store game activity in a timeseries database service for future analysis. As the system scales, ensure that data is not lost due to processing backlogs. Run hardened Linux distro. Requirements for Game Analytics Platform Dynamically scale up or down based on game activity. Process incoming data on the fly directly from the game servers. Process data that arrives late because of slow mobile networks. Allow queries to access at least 10 TB of historical data. Process files that are regularly uploaded by users' mobile devices.\n<strong>Executive Statement -</strong> Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users. Additionally, our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers."
  },
  {
    "id": 227,
    "topic": "Databases",
    "question": "For this question, refer to the Mountkirk Games case study (v2 - listed above).\nYou need to analyze and define the technical architecture for the database workloads for your company, Mountkirk Games.\nConsidering the business and technical requirements, what should you do?",
    "options": {
      "A": "Use Cloud SQL for time series data, and use Cloud Bigtable for historical data queries.",
      "B": "Use Cloud SQL to replace MySQL, and use Cloud Spanner for historical data queries.",
      "C": "Use Cloud Bigtable to replace MySQL, and use BigQuery for historical data queries.",
      "D": "Use Cloud Bigtable for time series data, use Cloud Spanner for transactional data, and use BigQuery for historical data queries."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Mapping the technical requirements (v2) to GCP databases: Transactional database for user profiles/game state -> Cloud Spanner (scalable, relational). Time series database for game activity -> Cloud Bigtable (optimized for time series). SQL queries on 10TB+ historical data -> BigQuery (data warehouse for large-scale analytics). Option D correctly assigns each workload to the appropriate managed service.",
    "conditions": [
      "Define database architecture",
      "Technical Requirements (Backend): Transactional DB, Timeseries DB",
      "Technical Requirements (Analytics): SQL queries on 10TB+ historical data"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers, MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics, run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform Dynamically scale up or down based on game activity. Connect to a transactional database service to manage user profiles and game state. Store game activity in a timeseries database service for future analysis. As the system scales, ensure that data is not lost due to processing backlogs. Run hardened Linux distro. Requirements for Game Analytics Platform Dynamically scale up or down based on game activity. Process incoming data on the fly directly from the game servers. Process data that arrives late because of slow mobile networks. Allow queries to access at least 10 TB of historical data. Process files that are regularly uploaded by users' mobile devices.\n<strong>Executive Statement -</strong> Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users. Additionally, our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers."
  },
  {
    "id": 228,
    "topic": "Databases",
    "question": "For this question, refer to the Mountkirk Games case study (v2 - listed above).\nWhich managed storage option meets Mountkirk's technical requirement for storing game activity in a time series database service?",
    "options": {
      "A": "Cloud Bigtable",
      "B": "Cloud Spanner",
      "C": "BigQuery",
      "D": "Cloud Datastore"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Technical Requirement T-BE-3 for the Game Backend Platform explicitly states: 'Store game activity in a timeseries database service for future analysis'. Cloud Bigtable is Google Cloud's managed NoSQL wide-column database service specifically optimized for time-series data.",
    "conditions": [
      "Identify managed storage option",
      "Requirement: Store game activity in a time series database service"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers, MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics, run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform Dynamically scale up or down based on game activity. Connect to a transactional database service to manage user profiles and game state. Store game activity in a timeseries database service for future analysis. As the system scales, ensure that data is not lost due to processing backlogs. Run hardened Linux distro. Requirements for Game Analytics Platform Dynamically scale up or down based on game activity. Process incoming data on the fly directly from the game servers. Process data that arrives late because of slow mobile networks. Allow queries to access at least 10 TB of historical data. Process files that are regularly uploaded by users' mobile devices.\n<strong>Executive Statement -</strong> Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users. Additionally, our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers."
  },
  {
    "id": 229,
    "topic": "Compute",
    "question": "For this question, refer to the Mountkirk Games case study (v2 - listed above).\nYou are in charge of the new Game Backend Platform architecture. The game communicates with the backend over a REST API.\nYou want to follow Google-recommended practices. How should you design the backend?",
    "options": {
      "A": "Create an instance template for the backend. For every region, deploy it on a multi-zone managed instance group. Use an L4 load balancer",
      "B": "Create an instance template for the backend. For every region, deploy it on a single-zone managed instance group. Use an L4 load balancer",
      "C": "Create an instance template for the backend. For every region, deploy it on a multi-zone managed instance group. Use an L7 load balancer",
      "D": "Create an instance template for the backend. For every region, deploy it on a single-zone managed instance group. Use an L7 load balancer"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Recommended practice for a scalable and resilient REST API backend on Compute Engine involves: using Instance Templates for consistency, deploying across multiple zones within a region using Multi-zone Managed Instance Groups (MIGs) for high availability, and using an L7 HTTP(S) Load Balancer for intelligent routing, SSL termination, and global distribution capabilities suitable for REST APIs. Option C combines these elements.",
    "conditions": [
      "Design Game Backend Platform architecture (GCE based per v1/v2 concept)",
      "Communicates via REST API",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They build all of their games using some server-side integration. Historically, they have used cloud providers to lease physical servers. Due to the unexpected popularity of some of their games, they have had problems scaling their global audience, application servers, MySQL databases, and analytics tools. Their current model is to write game statistics to files and send them through an ETL tool that loads them into a centralized MySQL database for reporting.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new game, which they expect to be very popular. They plan to deploy the game's backend on Google Compute Engine so they can capture streaming metrics, run intensive analytics, and take advantage of its autoscaling server environment and integrate with a managed NoSQL database.\n<strong>Business Requirements </strong><br> - Increase to a global footprint. Improve uptime downtime is loss of players. Increase efficiency of the cloud resources we use. Reduce latency to all customers.\n<strong>Technical Requirements -</strong> Requirements for Game Backend Platform Dynamically scale up or down based on game activity. Connect to a transactional database service to manage user profiles and game state. Store game activity in a timeseries database service for future analysis. As the system scales, ensure that data is not lost due to processing backlogs. Run hardened Linux distro. Requirements for Game Analytics Platform Dynamically scale up or down based on game activity. Process incoming data on the fly directly from the game servers. Process data that arrives late because of slow mobile networks. Allow queries to access at least 10 TB of historical data. Process files that are regularly uploaded by users' mobile devices.\n<strong>Executive Statement -</strong> Our last successful game did not scale well with our previous cloud provider, resulting in lower user adoption and affecting the game's reputation. Our investors want more key performance indicators (KPIs) to evaluate the speed and stability of the game, as well as other metrics that provide deeper insight into usage patterns so we can adapt the game to target users. Additionally, our current technology stack cannot provide the scale we need, so we want to replace MySQL and move to an environment that provides autoscaling, low latency load balancing, and frees us up from managing physical servers."
  },
  {
    "id": 230,
    "topic": "Storage",
    "question": "For this question, refer to the Mountkirk Games case study (v3 - listed above).\nYou need to optimize batch file transfers into Cloud Storage for Mountkirk Games’ new Google Cloud solution. The batch files contain game statistics that need to be staged in Cloud Storage and be processed by an extract transform load (ETL) tool.\nWhat should you do?",
    "options": {
      "A": "Use gsutil to batch move files in sequence.",
      "B": "Use gsutil to batch copy the files in parallel.",
      "C": "Use gsutil to extract the files as the first part of ETL.",
      "D": "Use gsutil to load the files as the last part of ETL."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "To optimize the transfer of multiple batch files into Cloud Storage, use parallel uploads. The `gsutil -m cp` command enables multi-threaded/multi-process copying (B), significantly speeding up the transfer compared to sequential uploads (A). `gsutil` is for the transfer/staging step; the ETL processing happens afterward (C and D are incorrect descriptions of gsutil's role).",
    "conditions": [
      "Optimize batch file transfers into Cloud Storage",
      "Files contain game statistics for staging",
      "Files will be processed by ETL tool"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong>Existing Technical Environment </strong><br> - The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong>Business Requirements </strong><br> - Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical Requirements -</strong> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive Statement -</strong> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 231,
    "topic": "IAM & Security",
    "question": "For this question, refer to the Mountkirk Games case study (v3 - listed above).\nYou are implementing Firestore for Mountkirk Games. Mountkirk Games wants to give a new game programmatic access to a legacy game's Firestore database.\nAccess should be as restricted as possible.\nWhat should you do?",
    "options": {
      "A": "Create a service account (SA) in the legacy game's Google Cloud project, add a second SA in the new game's IAM page, and then give the Organization Admin role to both SAs.",
      "B": "Create a service account (SA) in the legacy game's Google Cloud project, give the SA the Organization Admin role, and then give it the Firebase Admin role in both projects.",
      "C": "Create a service account (SA) in the legacy game's Google Cloud project, add this SA in the new game's IAM page, and then give it the Firebase Admin role in both projects.",
      "D": "Create a service account (SA) in the legacy game's Google Cloud project, give it the Firebase Admin role, and then migrate the new game to the legacy game's project."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "To grant cross-project access following least privilege: Create a dedicated Service Account (SA) in the legacy project (where Firestore resides). Grant this SA the minimum required role (e.g., a specific Firestore Reader/Writer role, or Firebase Admin if broader access is needed) *on the legacy project*. In the new game project's IAM settings, grant the service account running the new game application the permission to impersonate the legacy SA (e.g., grant the `roles/iam.serviceAccountUser` role on the legacy SA to the new game's SA). Option C is the closest, though slightly imprecise: the SA is created in legacy, granted Firebase Admin role there, and the new game's service account needs permission to *use* the legacy SA, not necessarily adding the legacy SA directly to the new project's IAM page.",
    "conditions": [
      "New game needs programmatic access to legacy game's Firestore",
      "Least privilege access required"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong>Existing Technical Environment </strong><br> - The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong>Business Requirements </strong><br> - Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical Requirements -</strong> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive Statement -</strong> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 232,
    "topic": "IAM & Security",
    "question": "For this question, refer to the Mountkirk Games case study (v3 - listed above).\nMountkirk Games wants to limit the physical location of resources to their operating Google Cloud regions.\nWhat should you do?",
    "options": {
      "A": "Configure an organizational policy which constrains where resources can be deployed.",
      "B": "Configure IAM conditions to limit what resources can be configured.",
      "C": "Configure the quotas for resources in the regions not being used to 0.",
      "D": "Configure a custom alert in Cloud Monitoring so you can disable resources as they are created in other regions."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Organization Policies provide centralized, preventative control over resource usage. The `constraints/gcp.resourceLocations` constraint allows administrators to define a list of allowed Google Cloud locations (regions or multi-regions) where resources can be created within the scope of the policy (Organization, Folder, or Project). This directly enforces the requirement.",
    "conditions": [
      "Limit physical location of GCP resources to specific operating regions"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong>Existing Technical Environment </strong><br> - The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong>Business Requirements </strong><br> - Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical Requirements -</strong> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive Statement -</strong> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 233,
    "topic": "Networking",
    "question": "For this question, refer to the Mountkirk Games case study (v3 - listed above).\nYou need to implement a network ingress for a new game that meets the defined business and technical requirements. Mountkirk Games wants each regional game instance to be located in multiple Google Cloud regions.\nWhat should you do?",
    "options": {
      "A": "Configure a global load balancer connected to a managed instance group running Compute Engine instances.",
      "B": "Configure kubemci with a global load balancer and Google Kubernetes Engine.",
      "C": "Configure a global load balancer with Google Kubernetes Engine.",
      "D": "Configure Ingress for Anthos with a global load balancer and Google Kubernetes Engine."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "The <strong>Solution Concept </strong><br> specifies GKE and a global load balancer for multi-region deployment. Ingress for Anthos (or Multi Cluster Ingress) is the standard way to manage a single ingress configuration that controls a global HTTP(S) load balancer distributing traffic across GKE clusters in multiple regions. This meets the technical requirements for dynamic scaling, low latency, and multi-region support on GKE.",
    "conditions": [
      "Implement network ingress for new game",
      "Use GKE (per <strong>Solution Concept </strong><br>)",
      "Deploy in multiple GCP regions",
      "Minimize latency, optimize scaling (Business/Technical Reqs)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong>Existing Technical Environment </strong><br> - The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong>Business Requirements </strong><br> - Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical Requirements -</strong> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive Statement -</strong> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 234,
    "topic": "Operations",
    "question": "For this question, refer to the Mountkirk Games case study (v3 - listed above).\nYour development teams release new versions of games running on Google Kubernetes Engine (GKE) daily. You want to create service level indicators (SLIs) to evaluate the quality of the new versions from the user's perspective.\nWhat should you do?",
    "options": {
      "A": "Create CPU Utilization and Request Latency as service level indicators.",
      "B": "Create GKE CPU Utilization and Memory Utilization as service level indicators.",
      "C": "Create Request Latency and Error Rate as service level indicators.",
      "D": "Create Server Uptime and Error Rate as service level indicators."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "SLIs should reflect the user experience. For online games and applications, Request Latency (how long users wait) and Error Rate (how often requests fail or succeed) are fundamental indicators of perceived quality and reliability. CPU/Memory (A, B) are resource metrics. Server Uptime (D) is important but less granular than request-based metrics.",
    "conditions": [
      "Games running on GKE with daily releases",
      "Create SLIs to evaluate quality from user perspective"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong>Existing Technical Environment </strong><br> - The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong>Business Requirements </strong><br> - Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical Requirements -</strong> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive Statement -</strong> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 235,
    "topic": "Security",
    "question": "For this question, refer to the Mountkirk Games case study (v3 - listed above).\nMountkirk Games wants you to secure the connectivity from the new gaming application platform to Google Cloud. You want to streamline the process and follow Google-recommended practices.\nWhat should you do?",
    "options": {
      "A": "Configure Workload Identity and service accounts to be used by the application platform.",
      "B": "Use Kubernetes Secrets, which are obfuscated by default. Configure these Secrets to be used by the application platform.",
      "C": "Configure Kubernetes Secrets to store the secret, enable Application-Layer Secrets Encryption, and use Cloud Key Management Service (Cloud KMS) to manage the encryption keys. Configure these Secrets to be used by the application platform.",
      "D": "Configure HashiCorp Vault on Compute Engine, and use customer managed encryption keys and Cloud Key Management Service (Cloud KMS) to manage the encryption keys. Configure these Secrets to be used by the application platform."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Workload Identity is the Google-recommended and most secure way for applications running in GKE (the application platform) to authenticate to Google Cloud services. It associates Kubernetes service accounts with Google service accounts, allowing pods to use the Google service account's permissions without needing to handle key files. This streamlines authentication and adheres to best practices.",
    "conditions": [
      "Secure GKE application platform connectivity to GCP services",
      "Streamline the process",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong>Existing Technical Environment </strong><br> - The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong>Business Requirements </strong><br> - Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical Requirements -</strong> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive Statement -</strong> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 236,
    "topic": "DevOps",
    "question": "For this question, refer to the Mountkirk Games case study (v3 - listed above).\nYour development team has created a mobile game app. You want to test the new mobile app on Android and iOS devices with a variety of configurations.\nYou need to ensure that testing is efficient and cost-effective.\nWhat should you do?",
    "options": {
      "A": "Upload your mobile app to the Firebase Test Lab, and test the mobile app on Android and iOS devices.",
      "B": "Create Android and iOS VMs on Google Cloud, install the mobile app on the VMs, and test the mobile app.",
      "C": "Create Android and iOS containers on Google Kubernetes Engine (GKE), install the mobile app on the containers, and test the mobile app.",
      "D": "Upload your mobile app with different configurations to Firebase Hosting and test each configuration."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Firebase Test Lab provides cloud-based infrastructure to test Android and iOS applications across a wide range of physical and virtual devices and configurations automatically. This is the most efficient and cost-effective way to achieve broad device coverage compared to manual testing or building custom environments.",
    "conditions": [
      "Test new mobile game app (Android & iOS)",
      "Test on various configurations",
      "Efficient and cost-effective"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Mountkirk Games makes online, session-based, multiplayer games for mobile platforms. They have recently started expanding to other platforms after successfully migrating their on-premises environments to Google Cloud. Their most recent endeavor is to create a retro-style first-person shooter (FPS) game that allows hundreds of simultaneous players to join a geo-specific digital arena from multiple platforms and locations. A real-time digital banner will display a global leaderboard of all the top players across every active arena.\n<strong>Solution Concept </strong><br> - Mountkirk Games is building a new multiplayer game that they expect to be very popular. They plan to deploy the game's backend on Google Kubernetes Engine so they can scale rapidly and use Google's global load balancer to route players to the closest regional game arenas. In order to keep the global leader board in sync, they plan to use a multi-region Spanner cluster.\n<strong>Existing Technical Environment </strong><br> - The existing environment was recently migrated to Google Cloud, and five games came across using lift-and-shift virtual machine migrations, with a few minor exceptions. Each new game exists in an isolated Google Cloud project nested below a folder that maintains most of the permissions and network policies. Legacy games with low traffic have been consolidated into a single project. There are also separate environments for development and testing.\n<strong>Business Requirements </strong><br> - Support multiple gaming platforms. Support multiple regions. Support rapid iteration of game features. Minimize latency. Optimize for dynamic scaling. Use managed services and pooled resources. Minimize costs.\n<strong>Technical Requirements -</strong> Dynamically scale based on game activity. Publish scoring data on a near real-time global leaderboard. Store game activity logs in structured files for future analysis. Use GPU processing to render graphics server-side for multi-platform support. Support eventual migration of legacy games to this new platform.\n<strong>Executive Statement -</strong> Our last game was the first time we used Google Cloud, and it was a tremendous success. We were able to analyze player behavior and game telemetry in ways that we never could before. This success allowed us to bet on a full migration to the cloud and to start building all-new games using cloud-native design principles. Our new game is our most ambitious to date and will open up doors for us to support more gaming platforms beyond mobile. Latency is our top priority, although cost management is the next most important challenge. As with our first cloud-based game, we have grown to expect the cloud to enable advanced analytics capabilities so we can rapidly iterate on our deployments of bug fixes and new functionality."
  },
  {
    "id": 237,
    "topic": "Data Analytics",
    "question": "For this question, refer to the TerramEarth case study (v1 - listed above).\nTerramEarth's CTO wants to use the raw data from connected vehicles to help identify approximately when a vehicle in the field will have a catastrophic failure.\nYou want to allow analysts to centrally query the vehicle data.\nWhich architecture should you recommend?",
    "options": {
      "A": "[Image depicting FTP -> GCLB -> GKE -> PubSub -> Dataflow -> BigQuery -> Analysts]",
      "B": "[Image depicting FTP -> App Engine Flex -> PubSub -> Dataflow -> BigQuery -> Analysts]",
      "C": "[Image depicting FTP -> GCLB -> GKE -> PubSub -> Dataflow -> Cloud SQL -> Analysts]",
      "D": "[Image depicting FTP -> App Engine Flex -> PubSub -> Dataflow -> Cloud SQL -> Analysts]"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The architecture needs to ingest data (shown via FTP, ideally streaming), buffer it (Pub/Sub), process it (Dataflow), and store it for large-scale central querying by analysts (BigQuery). Option A depicts this flow using GKE as the ingestion compute layer and BigQuery as the analytics data warehouse, suitable for predictive analysis on large datasets. Cloud SQL (C, D) is not appropriate for this scale of analytics.",
    "conditions": [
      "Use raw vehicle data for failure prediction",
      "Allow central querying by analysts"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries: about 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\nCompany background - TerramEarth was formed in 1946, when several small, family owned companies combined to retool after World War Il. The company cares about their employees and customers and considers them to be extended members of their family. TerramEarth is proud of their ability to innovate on their core products and find new markets as their customers’ needs change. For the past 20 years, trends in the industry have been largely toward increasing productivity by using larger vehicles with a human operator.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second with 22 hours of operation per day, Terram Earth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - FTP Data Servers warehouse. TerramEarth's existing architecture is composed of Linux-based systems that reside in a data center. These systems gzip CSV files from the field and upload via FTP, transform and aggregate them, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week, without increasing the cost of carrying surplus inventory. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>CEO Statement </strong><br> - We have been successful in capitalizing on the trend toward larger vehicles to increase the productivity of our customers. Technological change is occurring rapidly, and TerramEarth has taken advantage of connected devices technology to provide our customers with better services, such as our intelligent farming equipment. With this technology, we have been able to increase farmers’ yields by 25%, by using past trends to adjust how our vehicles operate. These advances have led to the rapid growth of our agricultural product line, which we expect will generate 50% of our revenues by 2020.\n<strong>CTO Statement  </strong><br>- Our competitive advantage has always been in the manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. Unfortunately, our CEO doesn't take technology obsolescence seriously and he considers the many new companies in our industry to be niche players. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 238,
    "topic": "API Management",
    "question": "For this question, refer to the TerramEarth case study (v1 - listed above).\nThe TerramEarth development team wants to create an API to meet the company's Business Requirements. You want the development team to focus their development effort on business value versus creating a custom framework.\nWhich method should they use?",
    "options": {
      "A": "Use Google App Engine with Google Cloud Endpoint Focus on an API for dealers and partners.",
      "B": "Use Google App Engine with a JAX-RS Jersey Java-based framewor Focus on an API for the public.",
      "C": "Use Google App Engine with the Swagger (open API Specification) framewor Focus on an API for the public.",
      "D": "Use Google Container Engine with a Django Python containe Focus on an API for the public.",
      "E": "Use Google Container Engine with a Tomcat container with the Swagger (Open API Specification) framewor Focus on an API for dealers and partners."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "<strong>Business Requirements </strong><br> include supporting dealers and partners. To minimize framework development, use managed services. App Engine provides a managed platform. Cloud Endpoints provides an API management framework handling authentication, quotas, monitoring etc., built on OpenAPI (Swagger). Combining App Engine + Cloud Endpoints allows focus on the API logic for dealers/partners (A).",
    "conditions": [
      "Create API to meet <strong>Business Requirements </strong><br> (support dealers/partners)",
      "Minimize custom framework development"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries: about 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\nCompany background - TerramEarth was formed in 1946, when several small, family owned companies combined to retool after World War Il. The company cares about their employees and customers and considers them to be extended members of their family. TerramEarth is proud of their ability to innovate on their core products and find new markets as their customers’ needs change. For the past 20 years, trends in the industry have been largely toward increasing productivity by using larger vehicles with a human operator.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second with 22 hours of operation per day, Terram Earth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - FTP Data Servers warehouse. TerramEarth's existing architecture is composed of Linux-based systems that reside in a data center. These systems gzip CSV files from the field and upload via FTP, transform and aggregate them, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week, without increasing the cost of carrying surplus inventory. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>CEO Statement </strong><br> - We have been successful in capitalizing on the trend toward larger vehicles to increase the productivity of our customers. Technological change is occurring rapidly, and TerramEarth has taken advantage of connected devices technology to provide our customers with better services, such as our intelligent farming equipment. With this technology, we have been able to increase farmers’ yields by 25%, by using past trends to adjust how our vehicles operate. These advances have led to the rapid growth of our agricultural product line, which we expect will generate 50% of our revenues by 2020.\n<strong>CTO Statement  </strong><br>- Our competitive advantage has always been in the manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. Unfortunately, our CEO doesn't take technology obsolescence seriously and he considers the many new companies in our industry to be niche players. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 239,
    "topic": "API Management",
    "question": "For this question, refer to the TerramEarth case study (v1 - listed above).\nYour development team has created a structured API to retrieve vehicle data. They want to allow third parties to develop tools for dealerships that use this vehicle event data.\nYou want to support delegated authorization against this data.\nWhat should you do?",
    "options": {
      "A": "Build or leverage an OAuth-compatible access control system",
      "B": "Build SAML 2.0 SSO compatibility into your authentication system",
      "C": "Restrict data access based on the source IP address of the partner systems",
      "D": "Create secondary credentials for each dealer that can be given to the trusted third party"
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Delegated authorization, where a user (dealer) grants a third-party application limited access to their resources (vehicle data API) without sharing credentials, is the standard use case for OAuth 2.0. Implementing or leveraging an OAuth-compatible system (A) allows dealers to authorize specific tools.",
    "conditions": [
      "API retrieves vehicle data",
      "Allow 3rd parties to build tools for dealerships using the API",
      "Support delegated authorization (dealer authorizes tool)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries: about 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\nCompany background - TerramEarth was formed in 1946, when several small, family owned companies combined to retool after World War Il. The company cares about their employees and customers and considers them to be extended members of their family. TerramEarth is proud of their ability to innovate on their core products and find new markets as their customers’ needs change. For the past 20 years, trends in the industry have been largely toward increasing productivity by using larger vehicles with a human operator.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second with 22 hours of operation per day, Terram Earth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - FTP Data Servers warehouse. TerramEarth's existing architecture is composed of Linux-based systems that reside in a data center. These systems gzip CSV files from the field and upload via FTP, transform and aggregate them, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week, without increasing the cost of carrying surplus inventory. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>CEO Statement </strong><br> - We have been successful in capitalizing on the trend toward larger vehicles to increase the productivity of our customers. Technological change is occurring rapidly, and TerramEarth has taken advantage of connected devices technology to provide our customers with better services, such as our intelligent farming equipment. With this technology, we have been able to increase farmers’ yields by 25%, by using past trends to adjust how our vehicles operate. These advances have led to the rapid growth of our agricultural product line, which we expect will generate 50% of our revenues by 2020.\n<strong>CTO Statement  </strong><br>- Our competitive advantage has always been in the manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. Unfortunately, our CEO doesn't take technology obsolescence seriously and he considers the many new companies in our industry to be niche players. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 240,
    "topic": "Data Processing",
    "question": "For this question, refer to the TerramEarth case study (v1 - listed above).\nTerramEarth plans to connect all 20 million vehicles in the field to the cloud. This increases the volume to 20 million 600 byte records a second for 40 TB an hour.\nHow should you design the data ingestion?",
    "options": {
      "A": "Vehicles write data directly to GCS.",
      "B": "Vehicles write data directly to Google Cloud Pub/Sub.",
      "C": "Vehicles stream data directly to Google BigQuery.",
      "D": "Vehicles continue to write data using the existing system (FTP)."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Ingesting 20 million records/sec requires a highly scalable, durable service. Cloud Pub/Sub is designed for this scale, acting as a global ingestion buffer for streaming data before it's processed downstream. Direct writes to GCS (A) or BigQuery (C) have lower throughput limits and are less suitable for this velocity. FTP (D) is inadequate.",
    "conditions": [
      "Connect 20 million vehicles",
      "Ingestion rate: 20M records/sec (~40TB/hr)",
      "Design data ingestion"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries: about 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\nCompany background - TerramEarth was formed in 1946, when several small, family owned companies combined to retool after World War Il. The company cares about their employees and customers and considers them to be extended members of their family. TerramEarth is proud of their ability to innovate on their core products and find new markets as their customers’ needs change. For the past 20 years, trends in the industry have been largely toward increasing productivity by using larger vehicles with a human operator.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second with 22 hours of operation per day, Terram Earth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - FTP Data Servers warehouse. TerramEarth's existing architecture is composed of Linux-based systems that reside in a data center. These systems gzip CSV files from the field and upload via FTP, transform and aggregate them, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week, without increasing the cost of carrying surplus inventory. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>CEO Statement </strong><br> - We have been successful in capitalizing on the trend toward larger vehicles to increase the productivity of our customers. Technological change is occurring rapidly, and TerramEarth has taken advantage of connected devices technology to provide our customers with better services, such as our intelligent farming equipment. With this technology, we have been able to increase farmers’ yields by 25%, by using past trends to adjust how our vehicles operate. These advances have led to the rapid growth of our agricultural product line, which we expect will generate 50% of our revenues by 2020.\n<strong>CTO Statement  </strong><br>- Our competitive advantage has always been in the manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. Unfortunately, our CEO doesn't take technology obsolescence seriously and he considers the many new companies in our industry to be niche players. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 241,
    "topic": "Migration",
    "question": "For this question, refer to the TerramEarth case study (v1 - listed above).\nYou analyzed TerramEarth's business requirement to reduce downtime, and found that they can achieve a majority of time saving by reducing customer's wait time for parts. You decided to focus on reduction of the 3 weeks aggregate reporting time.\nWhich modifications to the company's processes should you recommend?",
    "options": {
      "A": "Migrate from CSV to binary format, migrate from FTP to SFTP transport, and develop machine learning analysis of metrics",
      "B": "Migrate from FTP to streaming transport, migrate from CSV to binary format, and develop machine learning analysis of metrics",
      "C": "Increase fleet cellular connectivity to 80%, migrate from FTP to streaming transport, and develop machine learning analysis of metrics",
      "D": "Migrate from FTP to SFTP transport, develop machine learning analysis of metrics, and increase dealer local inventory by a fixed factor"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The 3-week reporting delay is due to batch FTP processing of data from a limited number of connected vehicles. To reduce this delay significantly: 1) Increase the number of connected vehicles (increase cellular connectivity) to get more data faster. 2) Replace batch FTP with a real-time streaming transport (like IoT Core to Pub/Sub). 3) Use this faster data stream for ML analysis to predict parts needs sooner. Option C combines these necessary changes.",
    "conditions": [
      "Goal: Reduce 3-week reporting time",
      "Current process: Batch FTP of CSV from limited connected vehicles",
      "Recommend process modifications"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries: about 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\nCompany background - TerramEarth was formed in 1946, when several small, family owned companies combined to retool after World War Il. The company cares about their employees and customers and considers them to be extended members of their family. TerramEarth is proud of their ability to innovate on their core products and find new markets as their customers’ needs change. For the past 20 years, trends in the industry have been largely toward increasing productivity by using larger vehicles with a human operator.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second with 22 hours of operation per day, Terram Earth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - FTP Data Servers warehouse. TerramEarth's existing architecture is composed of Linux-based systems that reside in a data center. These systems gzip CSV files from the field and upload via FTP, transform and aggregate them, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week, without increasing the cost of carrying surplus inventory. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>CEO Statement </strong><br> - We have been successful in capitalizing on the trend toward larger vehicles to increase the productivity of our customers. Technological change is occurring rapidly, and TerramEarth has taken advantage of connected devices technology to provide our customers with better services, such as our intelligent farming equipment. With this technology, we have been able to increase farmers’ yields by 25%, by using past trends to adjust how our vehicles operate. These advances have led to the rapid growth of our agricultural product line, which we expect will generate 50% of our revenues by 2020.\n<strong>CTO Statement  </strong><br>- Our competitive advantage has always been in the manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. Unfortunately, our CEO doesn't take technology obsolescence seriously and he considers the many new companies in our industry to be niche players. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 242,
    "topic": "Case Study Analysis",
    "question": "For this question refer to the TerramEarth case study (v1 - listed above).\nWhich of TerramEarth’s legacy enterprise processes will experience significant change as a result of increased Google Cloud Platform adoption?",
    "options": {
      "A": "Opex/capex allocation, LAN changes, capacity planning",
      "B": "Capacity planning, TCO calculations, opex/capex allocation",
      "C": "Capacity planning, utilization measurement, data center expansion",
      "D": "Data Center expansion, TCO calculations, utilization measurement"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Moving from on-premises data centers to GCP fundamentally changes: Capacity planning (from hardware procurement cycles to on-demand provisioning/autoscaling), TCO calculations (new cost models, factoring in managed services and operational savings), and Opex/Capex allocation (shift from upfront capital investment to ongoing operational spending). These three areas (B) undergo the most significant transformation.",
    "conditions": [
      "Identify legacy enterprise processes significantly changed by GCP adoption"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries: about 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\nCompany background - TerramEarth was formed in 1946, when several small, family owned companies combined to retool after World War Il. The company cares about their employees and customers and considers them to be extended members of their family. TerramEarth is proud of their ability to innovate on their core products and find new markets as their customers’ needs change. For the past 20 years, trends in the industry have been largely toward increasing productivity by using larger vehicles with a human operator.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second with 22 hours of operation per day, Terram Earth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - FTP Data Servers warehouse. TerramEarth's existing architecture is composed of Linux-based systems that reside in a data center. These systems gzip CSV files from the field and upload via FTP, transform and aggregate them, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week, without increasing the cost of carrying surplus inventory. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>CEO Statement </strong><br> - We have been successful in capitalizing on the trend toward larger vehicles to increase the productivity of our customers. Technological change is occurring rapidly, and TerramEarth has taken advantage of connected devices technology to provide our customers with better services, such as our intelligent farming equipment. With this technology, we have been able to increase farmers’ yields by 25%, by using past trends to adjust how our vehicles operate. These advances have led to the rapid growth of our agricultural product line, which we expect will generate 50% of our revenues by 2020.\n<strong>CTO Statement  </strong><br>- Our competitive advantage has always been in the manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. Unfortunately, our CEO doesn't take technology obsolescence seriously and he considers the many new companies in our industry to be niche players. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 243,
    "topic": "Data Processing",
    "question": "For this question, refer to the TerramEarth case study (v1 - listed above).\nTo speed up data retrieval, more vehicles will be upgraded to cellular connections and be able to transmit data to the ETL process. The current FTP process is error-prone and restarts the data transfer from the start of the file when connections fail, which happens often.\nYou want to improve the reliability of the solution and minimize data transfer time on the cellular connections.\nWhat should you do?",
    "options": {
      "A": "Use one Google Container Engine cluster of FTP servers. Save the data to a Multi-Regional bucket. Run the ETL process using data in the bucket",
      "B": "Use multiple Google Container Engine clusters running FTP servers located in different regions. Save the data to Multi-Regional buckets in US, EU, and Asia. Run the ETL process using the data in the bucket",
      "C": "Directly transfer the files to different Google Cloud Multi-Regional Storage bucket locations in US, EU, and Asia using Google APIs over HTTP(S). Run the ETL process using the data in the bucket",
      "D": "Directly transfer the files to a different Google Cloud Regional Storage bucket location in US, EU, and Asia using Google APIs over HTTP(S). Run the ETL process to retrieve the data from each Regional bucket"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "FTP is unreliable over cellular. Using Google Cloud Storage APIs directly via HTTP(S) allows for resumable uploads, significantly improving reliability. Targeting Multi-Regional buckets provides higher availability and potentially lower latency for uploads from globally distributed vehicles compared to Regional buckets (D). The ETL process can then access the data from these buckets. Continuing to use FTP servers (A, B) doesn't solve the core reliability issue.",
    "conditions": [
      "Increase cellular vehicle connectivity",
      "Current FTP process unreliable (restarts on failure)",
      "Improve reliability",
      "Minimize transfer time over cellular"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries: about 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\nCompany background - TerramEarth was formed in 1946, when several small, family owned companies combined to retool after World War Il. The company cares about their employees and customers and considers them to be extended members of their family. TerramEarth is proud of their ability to innovate on their core products and find new markets as their customers’ needs change. For the past 20 years, trends in the industry have been largely toward increasing productivity by using larger vehicles with a human operator.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second with 22 hours of operation per day, Terram Earth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - FTP Data Servers warehouse. TerramEarth's existing architecture is composed of Linux-based systems that reside in a data center. These systems gzip CSV files from the field and upload via FTP, transform and aggregate them, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week, without increasing the cost of carrying surplus inventory. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>CEO Statement </strong><br> - We have been successful in capitalizing on the trend toward larger vehicles to increase the productivity of our customers. Technological change is occurring rapidly, and TerramEarth has taken advantage of connected devices technology to provide our customers with better services, such as our intelligent farming equipment. With this technology, we have been able to increase farmers’ yields by 25%, by using past trends to adjust how our vehicles operate. These advances have led to the rapid growth of our agricultural product line, which we expect will generate 50% of our revenues by 2020.\n<strong>CTO Statement  </strong><br>- Our competitive advantage has always been in the manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. Unfortunately, our CEO doesn't take technology obsolescence seriously and he considers the many new companies in our industry to be niche players. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 244,
    "topic": "Data Processing",
    "question": "For this question, refer to the TerramEarth case study (v1 - listed above).\nTerramEarth's 20 million vehicles are scattered around the world. Based on the vehicle's location, its telemetry data is stored in a Google Cloud Storage (GCS) regional bucket (US, Europe, or Asia). The CTO has asked you to run a report on the raw telemetry data to determine why vehicles are breaking down after 100 K miles.\nYou want to run this job on all the data.\nWhat is the most cost-effective way to run this job?",
    "options": {
      "A": "Move all the data into 1 zone, then launch a Cloud Dataproc cluster to run the job",
      "B": "Move all the data into 1 region, then launch a Google Cloud Dataproc cluster to run the job",
      "C": "Launch a cluster in each region to preprocess and compress the raw data, then move the data into a multi-region bucket and use a Dataproc cluster to finish the job",
      "D": "Launch a cluster in each region to preprocess and compress the raw data, then move the data into a region bucket and use a Cloud Dataproc cluster to finish the job"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "To minimize cross-region network egress costs (a major cost driver), process data as close to where it resides as possible. Launch regional Dataproc clusters to preprocess/compress/filter the data within each region (US, EU, Asia). Then, move the much smaller, preprocessed results to a single *regional* bucket (co-located with the final Dataproc cluster) for the final aggregation step. This approach (D) minimizes expensive inter-regional data movement compared to moving all raw data first (A, B) or using a potentially more expensive multi-regional bucket for intermediate data (C).",
    "conditions": [
      "Data stored in regional GCS buckets (US, EU, Asia)",
      "Need to run report (using Dataproc) on all data",
      "Goal: Most cost-effective"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries: about 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\nCompany background - TerramEarth was formed in 1946, when several small, family owned companies combined to retool after World War Il. The company cares about their employees and customers and considers them to be extended members of their family. TerramEarth is proud of their ability to innovate on their core products and find new markets as their customers’ needs change. For the past 20 years, trends in the industry have been largely toward increasing productivity by using larger vehicles with a human operator.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second with 22 hours of operation per day, Terram Earth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - FTP Data Servers warehouse. TerramEarth's existing architecture is composed of Linux-based systems that reside in a data center. These systems gzip CSV files from the field and upload via FTP, transform and aggregate them, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week, without increasing the cost of carrying surplus inventory. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>CEO Statement </strong><br> - We have been successful in capitalizing on the trend toward larger vehicles to increase the productivity of our customers. Technological change is occurring rapidly, and TerramEarth has taken advantage of connected devices technology to provide our customers with better services, such as our intelligent farming equipment. With this technology, we have been able to increase farmers’ yields by 25%, by using past trends to adjust how our vehicles operate. These advances have led to the rapid growth of our agricultural product line, which we expect will generate 50% of our revenues by 2020.\n<strong>CTO Statement  </strong><br>- Our competitive advantage has always been in the manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. Unfortunately, our CEO doesn't take technology obsolescence seriously and he considers the many new companies in our industry to be niche players. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 245,
    "topic": "Storage",
    "question": "For this question, refer to the TerramEarth case study (v1 - listed above).\nTerramEarth has equipped all connected trucks with servers and sensors to collect telemetry data. Next year they want to use the data to train machine learning models. They want to store this data in the cloud while reducing costs.\nWhat should they do?",
    "options": {
      "A": "Have the vehicle's computer compress the data in hourly snapshots, and store it in a Google Cloud Storage (GCS) Nearline bucket",
      "B": "Push the telemetry data in real-time to a streaming dataflow job that compresses the data, and store it in Google BigQuery",
      "C": "Push the telemetry data in real-time to a streaming dataflow job that compresses the data, and store it in Cloud Bigtable",
      "D": "Have the vehicle's computer compress the data in hourly snapshots, and store it in a GCS Coldline bucket"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Data needed 'next year' implies infrequent access until then. Cost reduction is key. Cloud Storage Coldline offers the lowest storage cost for data accessed less than annually. Compressing data and storing it as snapshots (e.g., hourly) in Coldline (D) is the most cost-effective archival strategy. Nearline (A) is more expensive. Real-time streaming to BigQuery (B) or Bigtable (C) is costly and unnecessary given the delayed usage pattern.",
    "conditions": [
      "Store telemetry data from connected trucks",
      "Data used for ML training next year",
      "Reduce storage costs"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries: about 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\nCompany background - TerramEarth was formed in 1946, when several small, family owned companies combined to retool after World War Il. The company cares about their employees and customers and considers them to be extended members of their family. TerramEarth is proud of their ability to innovate on their core products and find new markets as their customers’ needs change. For the past 20 years, trends in the industry have been largely toward increasing productivity by using larger vehicles with a human operator.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second with 22 hours of operation per day, Terram Earth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - FTP Data Servers warehouse. TerramEarth's existing architecture is composed of Linux-based systems that reside in a data center. These systems gzip CSV files from the field and upload via FTP, transform and aggregate them, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week, without increasing the cost of carrying surplus inventory. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>CEO Statement </strong><br> - We have been successful in capitalizing on the trend toward larger vehicles to increase the productivity of our customers. Technological change is occurring rapidly, and TerramEarth has taken advantage of connected devices technology to provide our customers with better services, such as our intelligent farming equipment. With this technology, we have been able to increase farmers’ yields by 25%, by using past trends to adjust how our vehicles operate. These advances have led to the rapid growth of our agricultural product line, which we expect will generate 50% of our revenues by 2020.\n<strong>CTO Statement  </strong><br>- Our competitive advantage has always been in the manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. Unfortunately, our CEO doesn't take technology obsolescence seriously and he considers the many new companies in our industry to be niche players. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 246,
    "topic": "Security",
    "question": "For this question, refer to the TerramEarth case study (v1 - listed above).\nYour agricultural division is experimenting with fully autonomous vehicles.\nYou want your architecture to promote strong security during vehicle operation.\nWhich two architectures should you consider? (Choose two.)",
    "options": {
      "A": "Treat every micro service call between modules on the vehicle as untrusted.",
      "B": "Require IPv6 for connectivity to ensure a secure address space.",
      "C": "Use a trusted platform module (TPM) and verify firmware and binaries on boot.",
      "D": "Use a functional programming language to isolate code execution cycles.",
      "E": "Use multiple connectivity subsystems for redundancy.",
      "F": "Enclose the vehicle's drive electronics in a Faraday cage to isolate chips."
    },
    "correctAnswer": [
      "A",
      "C"
    ],
    "explanation": "Strong security for autonomous vehicles involves multiple layers. A: A zero-trust approach within the vehicle, authenticating/authorizing inter-module communication, limits lateral movement if a component is compromised. C: A TPM provides hardware-based secure boot and integrity verification, ensuring the system starts and runs with trusted software.",
    "conditions": [
      "Architecture for autonomous vehicles",
      "Promote strong security"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries: about 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\nCompany background - TerramEarth was formed in 1946, when several small, family owned companies combined to retool after World War Il. The company cares about their employees and customers and considers them to be extended members of their family. TerramEarth is proud of their ability to innovate on their core products and find new markets as their customers’ needs change. For the past 20 years, trends in the industry have been largely toward increasing productivity by using larger vehicles with a human operator.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second with 22 hours of operation per day, Terram Earth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - FTP Data Servers warehouse. TerramEarth's existing architecture is composed of Linux-based systems that reside in a data center. These systems gzip CSV files from the field and upload via FTP, transform and aggregate them, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week, without increasing the cost of carrying surplus inventory. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>CEO Statement </strong><br> - We have been successful in capitalizing on the trend toward larger vehicles to increase the productivity of our customers. Technological change is occurring rapidly, and TerramEarth has taken advantage of connected devices technology to provide our customers with better services, such as our intelligent farming equipment. With this technology, we have been able to increase farmers’ yields by 25%, by using past trends to adjust how our vehicles operate. These advances have led to the rapid growth of our agricultural product line, which we expect will generate 50% of our revenues by 2020.\n<strong>CTO Statement  </strong><br>- Our competitive advantage has always been in the manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. Unfortunately, our CEO doesn't take technology obsolescence seriously and he considers the many new companies in our industry to be niche players. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 247,
    "topic": "AI & ML",
    "question": "For this question, refer to the TerramEarth case study (v1 - listed above).\nOperational parameters such as oil pressure are adjustable on each of TerramEarth's vehicles to increase their efficiency, depending on their environmental conditions.\nYour primary goal is to increase the operating efficiency of all 20 million cellular and unconnected vehicles in the field\nHow can you accomplish this goal?",
    "options": {
      "A": "Have you engineers inspect the data for patterns, and then create an algorithm with rules that make operational adjustments automaticall",
      "B": "Capture all operating data, train machine learning models that identify ideal operations, and run locally to make operational adjustments automatically",
      "C": "Implement a Google Cloud Dataflow streaming job with a sliding window, and use Google Cloud Messaging (GCM) to make operational adjustments automatically",
      "D": "Capture all operating data, train machine learning models that identify ideal operations, and host in Google Cloud Machine Learning (ML) Platform to make operational adjustments automatically"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "To optimize efficiency for *all* vehicles (including unconnected ones), the adjustment logic must run *locally* on the vehicle. The best approach is to collect data, train ML models in the cloud to learn optimal parameters based on conditions, and then deploy these trained models onto the vehicles (B). The local models can then make real-time adjustments based on sensor readings. Cloud-based adjustments (C, D) won't work for unconnected vehicles.",
    "conditions": [
      "Adjustable operational parameters on vehicles",
      "Goal: Increase efficiency of ALL 20M vehicles (connected & unconnected)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries: about 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\nCompany background - TerramEarth was formed in 1946, when several small, family owned companies combined to retool after World War Il. The company cares about their employees and customers and considers them to be extended members of their family. TerramEarth is proud of their ability to innovate on their core products and find new markets as their customers’ needs change. For the past 20 years, trends in the industry have been largely toward increasing productivity by using larger vehicles with a human operator.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second with 22 hours of operation per day, Terram Earth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - FTP Data Servers warehouse. TerramEarth's existing architecture is composed of Linux-based systems that reside in a data center. These systems gzip CSV files from the field and upload via FTP, transform and aggregate them, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week, without increasing the cost of carrying surplus inventory. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>CEO Statement </strong><br> - We have been successful in capitalizing on the trend toward larger vehicles to increase the productivity of our customers. Technological change is occurring rapidly, and TerramEarth has taken advantage of connected devices technology to provide our customers with better services, such as our intelligent farming equipment. With this technology, we have been able to increase farmers’ yields by 25%, by using past trends to adjust how our vehicles operate. These advances have led to the rapid growth of our agricultural product line, which we expect will generate 50% of our revenues by 2020.\n<strong>CTO Statement  </strong><br>- Our competitive advantage has always been in the manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. Unfortunately, our CEO doesn't take technology obsolescence seriously and he considers the many new companies in our industry to be niche players. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 248,
    "topic": "Storage",
    "question": "For this question, refer to the TerramEarth case study (v2 - listed above).\nTo be compliant with European GDPR regulation, TerramEarth is required to delete data generated from its European customers after a period of 36 months when it contains personal data.\nIn the new architecture, this data will be stored in both Cloud Storage and BigQuery.\nWhat should you do?",
    "options": {
      "A": "Create a BigQuery table for the European data, and set the table retention period to 36 months. For Cloud Storage, use gsutil to enable lifecycle management using a DELETE action with an Age condition of 36 months.",
      "B": "Create a BigQuery table for the European data, and set the table retention period to 36 months. For Cloud Storage, use gsutil to create a SetStorageClass to NONE action when with an Age condition of 36 months.",
      "C": "Create a BigQuery time-partitioned table for the European data, and set the partition expiration period to 36 months. For Cloud Storage, use gsutil to enable lifecycle management using a DELETE action with an Age condition of 36 months.",
      "D": "Create a BigQuery time-partitioned table for the European data, and set the partition expiration period to 36 months. For Cloud Storage, use gsutil to create a SetStorageClass to NONE action with an Age condition of 36 months."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "For BigQuery, use time-partitioned tables and set the partition expiration to 36 months; this automatically deletes data older than the retention period. For Cloud Storage, use Object Lifecycle Management with a DELETE action triggered by an Age condition of 36 months (approx. 1095 days). Option C correctly combines these two automated deletion mechanisms.",
    "conditions": [
      "GDPR compliance: Delete EU customer personal data after 36 months",
      "Data stored in Cloud Storage and BigQuery"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. About 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second, with 22 hours of operation per day, TerramEarth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's existing architecture is composed of Linux and Windows-based systems that reside in a single U.S, west coast based data center. These systems gzip CSV files from the field and upload via FTP, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>Technical Requirements -</strong> Expand beyond a single datacenter to decrease latency to the American midwest and east coast. Create a backup strategy. Increase security of data transfer from equipment to the datacenter. Improve data in the data warehouse. Use customer and equipment data to anticipate customer needs. Application 1: Data ingest - A custom Python application reads uploaded datafiles from a single server, writes to the data warehouse. Compute: Windows Server 2008 R2 - 16 CPUs - 128 GB of RAM - 10 TB local HDD storage. Application 2: Reporting - An off the shelf application that business analysts use to run a daily report to see what equipment needs repair. Only 2 analysts of a team of 10 | west coast, 5 east coast) can connect to the reporting application at a time. Compute: Off the shelf application. License tied to number of physical CPUs - Windows Server 2008 R2 - 16 CPUs - 32 GB of RAM - 500 GB HDD. Data warehouse: A single PostgreSQL server - RedHat Linux - 64 CPUs - 128 GB of RAM - 4x 6TB HDD in RAID 0.\n<strong>Executive Statement -</strong> Our competitive advantage has always been in our manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 249,
    "topic": "Storage",
    "question": "For this question, refer to the TerramEarth case study (v2 - listed above).\nTerramEarth has decided to store data files in Cloud Storage. You need to configure Cloud Storage lifecycle rules to store 1 year of data and minimize file storage cost.\nWhich two actions should you take?",
    "options": {
      "A": "Create a Cloud Storage lifecycle rule with Age: 30, Storage Class: Standard, and Action: Set to Coldline, and create a second GCS life-cycle rule with Age: 365, Storage Class: Coldline, and Action: Delete.",
      "B": "Create a Cloud Storage lifecycle rule with Age: 30, Storage Class: Coldline, and Action: Set to Nearline, and create a second GCS life-cycle rule with Age: 91, Storage Class: Coldline, and Action: Set to Nearline.",
      "C": "Create a Cloud Storage lifecycle rule with Age: 90, Storage Class: Standard, and Action: Set to Nearline, and create a second GCS life-cycle rule with Age: 91, Storage Class: Nearline, and Action: Set to Coldline.",
      "D": "Create a Cloud Storage lifecycle rule with Age: 30, Storage Class: Standard, and Action: Set to Coldline, and create a second GCS life-cycle rule with Age: 365, Storage Class: Nearline, and Action: Delete."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To minimize cost for 1-year storage: Transition data to cheaper classes as it ages and becomes less accessed, then delete after 1 year (365 days). Coldline offers very low storage cost for data accessed infrequently. Transitioning from Standard directly to Coldline after 30 days (A) minimizes storage cost faster than using an intermediate Nearline step (C), assuming access drops off significantly after the first month. Both A and C correctly implement the Delete action at 365 days. Option A is likely the most cost-effective by moving to the cheapest archival class sooner.",
    "conditions": [
      "Store files in GCS for 1 year",
      "Minimize storage cost using lifecycle rules"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. About 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second, with 22 hours of operation per day, TerramEarth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's existing architecture is composed of Linux and Windows-based systems that reside in a single U.S, west coast based data center. These systems gzip CSV files from the field and upload via FTP, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>Technical Requirements -</strong> Expand beyond a single datacenter to decrease latency to the American midwest and east coast. Create a backup strategy. Increase security of data transfer from equipment to the datacenter. Improve data in the data warehouse. Use customer and equipment data to anticipate customer needs. Application 1: Data ingest - A custom Python application reads uploaded datafiles from a single server, writes to the data warehouse. Compute: Windows Server 2008 R2 - 16 CPUs - 128 GB of RAM - 10 TB local HDD storage. Application 2: Reporting - An off the shelf application that business analysts use to run a daily report to see what equipment needs repair. Only 2 analysts of a team of 10 | west coast, 5 east coast) can connect to the reporting application at a time. Compute: Off the shelf application. License tied to number of physical CPUs - Windows Server 2008 R2 - 16 CPUs - 32 GB of RAM - 500 GB HDD. Data warehouse: A single PostgreSQL server - RedHat Linux - 64 CPUs - 128 GB of RAM - 4x 6TB HDD in RAID 0.\n<strong>Executive Statement -</strong> Our competitive advantage has always been in our manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 250,
    "topic": "Data Analytics",
    "question": "For this question, refer to the TerramEarth case study (v2 - listed above).\nYou need to implement a reliable, scalable GCP solution for the data warehouse for your company, TerramEarth.\nConsidering the TerramEarth business and technical requirements, what should you do?",
    "options": {
      "A": "Replace the existing data warehouse with BigQuery. Use table partitioning.",
      "B": "Replace the existing data warehouse with a Compute Engine instance with 96 CPUs.",
      "C": "Replace the existing data warehouse with BigQuery. Use federated data sources.",
      "D": "Replace the existing data warehouse with a Compute Engine instance with 96 CPUs. Add an additional Compute Engine preemptible instance with 32 CPUs."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "TerramEarth needs to replace its single PostgreSQL data warehouse with a scalable solution to handle large volumes of telemetry data (~9TB/day initially) and support analytics ('improve data in the data warehouse', 'use data to anticipate needs'). BigQuery is GCP's managed, serverless, highly scalable data warehouse. Replacing PostgreSQL with BigQuery and using time partitioning (A) provides the necessary scalability, query performance, and manageability for this use case.",
    "conditions": [
      "Implement reliable, scalable DWH",
      "Replace single PostgreSQL server",
      "Handle large, growing telemetry data",
      "Support analytics"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. About 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second, with 22 hours of operation per day, TerramEarth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's existing architecture is composed of Linux and Windows-based systems that reside in a single U.S, west coast based data center. These systems gzip CSV files from the field and upload via FTP, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>Technical Requirements -</strong> Expand beyond a single datacenter to decrease latency to the American midwest and east coast. Create a backup strategy. Increase security of data transfer from equipment to the datacenter. Improve data in the data warehouse. Use customer and equipment data to anticipate customer needs. Application 1: Data ingest - A custom Python application reads uploaded datafiles from a single server, writes to the data warehouse. Compute: Windows Server 2008 R2 - 16 CPUs - 128 GB of RAM - 10 TB local HDD storage. Application 2: Reporting - An off the shelf application that business analysts use to run a daily report to see what equipment needs repair. Only 2 analysts of a team of 10 | west coast, 5 east coast) can connect to the reporting application at a time. Compute: Off the shelf application. License tied to number of physical CPUs - Windows Server 2008 R2 - 16 CPUs - 32 GB of RAM - 500 GB HDD. Data warehouse: A single PostgreSQL server - RedHat Linux - 64 CPUs - 128 GB of RAM - 4x 6TB HDD in RAID 0.\n<strong>Executive Statement -</strong> Our competitive advantage has always been in our manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 251,
    "topic": "Data Processing",
    "question": "For this question, refer to the TerramEarth case study (v2 - listed above).\nA new architecture that writes all incoming data to BigQuery has been introduced. You notice that the data is dirty, and want to ensure data quality on an automated daily basis while managing cost.\nWhat should you do?",
    "options": {
      "A": "Set up a streaming Cloud Dataflow job, receiving data by the ingestion process. Clean the data in a Cloud Dataflow pipeline.",
      "B": "Create a Cloud Function that reads data from BigQuery and cleans it. Trigger the Cloud Function from a Compute Engine instance.",
      "C": "Create a SQL statement on the data in BigQuery, and save it as a view, Run the view daily, and save the result to a new table,",
      "D": "Use Cloud Dataprep and configure the BigQuery tables as the source. Schedule a daily job to clean the data."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Cloud Dataprep is a visual data preparation tool designed for cleaning and transforming data with minimal coding. It integrates directly with BigQuery. You can define cleaning steps (recipes) in Dataprep using the BigQuery table as a source and then schedule a recurring (daily) job to apply these transformations and write the cleaned data back to BigQuery (or another destination). This provides an automated daily cleaning process.",
    "conditions": [
      "Incoming data landed in BigQuery",
      "Data is dirty",
      "Need automated daily data quality process",
      "Manage cost"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. About 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second, with 22 hours of operation per day, TerramEarth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's existing architecture is composed of Linux and Windows-based systems that reside in a single U.S, west coast based data center. These systems gzip CSV files from the field and upload via FTP, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>Technical Requirements -</strong> Expand beyond a single datacenter to decrease latency to the American midwest and east coast. Create a backup strategy. Increase security of data transfer from equipment to the datacenter. Improve data in the data warehouse. Use customer and equipment data to anticipate customer needs. Application 1: Data ingest - A custom Python application reads uploaded datafiles from a single server, writes to the data warehouse. Compute: Windows Server 2008 R2 - 16 CPUs - 128 GB of RAM - 10 TB local HDD storage. Application 2: Reporting - An off the shelf application that business analysts use to run a daily report to see what equipment needs repair. Only 2 analysts of a team of 10 | west coast, 5 east coast) can connect to the reporting application at a time. Compute: Off the shelf application. License tied to number of physical CPUs - Windows Server 2008 R2 - 16 CPUs - 32 GB of RAM - 500 GB HDD. Data warehouse: A single PostgreSQL server - RedHat Linux - 64 CPUs - 128 GB of RAM - 4x 6TB HDD in RAID 0.\n<strong>Executive Statement -</strong> Our competitive advantage has always been in our manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 252,
    "topic": "Data Processing",
    "question": "For this question, refer to the TerramEarth case study (v2 - listed above).\nConsidering the technical requirements, how should you reduce the unplanned vehicle downtime in GCP?",
    "options": {
      "A": "Use BigQuery as the data warehouse. Connect all vehicles to the network and stream data into BigQuery using Cloud Pub/Sub and Cloud Dataflow. Use Google Data Studio for analysis and reporting.",
      "B": "Use BigQuery as the data warehouse. Connect all vehicles to the network and upload gzip files to a Multi-Regional Cloud Storage bucket using gcloud. Use Google Data Studio for analysis and reporting.",
      "C": "Use Cloud Dataproc Hive as the data warehouse. Upload gzip files to a Multi-Regional Cloud Storage bucket. Upload this data into BigQuery using gcloud. Use Google Data Studio for analysis and reporting.",
      "D": "Use Cloud Dataproc Hive as the data warehouse. Directly stream data into partitioned Hive tables. Use Pig scripts to analyze data."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Reducing downtime requires faster insights than the current 3-week old reports. This means moving from batch FTP uploads to real-time streaming and analysis. Option A proposes connecting vehicles (implies improving connectivity beyond the initial 200k), streaming data via Pub/Sub (ingestion buffer), processing with Dataflow (streaming ETL/analysis), storing in BigQuery (scalable analytics DWH), and using Data Studio for reporting/dashboards. This architecture enables near real-time analysis needed to anticipate failures and reduce downtime.",
    "conditions": [
      "Reduce unplanned vehicle downtime (< 1 week goal)",
      "Leverage GCP",
      "Consider technical requirements (improve DWH, anticipate needs, secure transfer, etc.)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. About 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second, with 22 hours of operation per day, TerramEarth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's existing architecture is composed of Linux and Windows-based systems that reside in a single U.S, west coast based data center. These systems gzip CSV files from the field and upload via FTP, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>Technical Requirements -</strong> Expand beyond a single datacenter to decrease latency to the American midwest and east coast. Create a backup strategy. Increase security of data transfer from equipment to the datacenter. Improve data in the data warehouse. Use customer and equipment data to anticipate customer needs. Application 1: Data ingest - A custom Python application reads uploaded datafiles from a single server, writes to the data warehouse. Compute: Windows Server 2008 R2 - 16 CPUs - 128 GB of RAM - 10 TB local HDD storage. Application 2: Reporting - An off the shelf application that business analysts use to run a daily report to see what equipment needs repair. Only 2 analysts of a team of 10 | west coast, 5 east coast) can connect to the reporting application at a time. Compute: Off the shelf application. License tied to number of physical CPUs - Windows Server 2008 R2 - 16 CPUs - 32 GB of RAM - 500 GB HDD. Data warehouse: A single PostgreSQL server - RedHat Linux - 64 CPUs - 128 GB of RAM - 4x 6TB HDD in RAID 0.\n<strong>Executive Statement -</strong> Our competitive advantage has always been in our manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 253,
    "topic": "IoT",
    "question": "For this question, refer to the TerramEarth case study (v2 - listed above).\nYou are asked to design a new architecture for the ingestion of the data of the 200,000 vehicles that are connected to a cellular network.\nYou want to follow Google-recommended practices.\nConsidering the technical requirements, which components should you use for the ingestion of the data?",
    "options": {
      "A": "Google Kubernetes Engine with an SSL Ingress",
      "B": "Cloud loT Core with public/private key pairs",
      "C": "Compute Engine with project-wide SSH keys",
      "D": "Compute Engine with specific SSH keys"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Cloud IoT Core is the Google Cloud managed service specifically designed for securely connecting, managing, and ingesting data from millions of globally distributed IoT devices (like connected vehicles). It handles device registration, authentication (e.g., using secure key pairs), communication protocols (MQTT/HTTP), and integrates seamlessly with Pub/Sub for downstream processing. This aligns with the technical requirement to increase security of data transfer and leverages a managed service.",
    "conditions": [
      "Design ingestion architecture for 200k connected vehicles",
      "Follow Google recommended practices",
      "Consider technical requirements (security, scalability implied)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. About 80% of their business is from mining and 20% from agriculture. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 20 million TerramEarth vehicles in operation that collect 120 fields of data per second. Data is stored locally on the vehicle and can be accessed for analysis when a vehicle is serviced. The data is downloaded via a maintenance port. This same port can be used to adjust operational parameters, allowing the vehicles to be upgraded in the field with new computing modules. Approximately 200,000 vehicles are connected to a cellular network, allowing TerramEarth to collect data directly. At a rate of 120 fields of data per second, with 22 hours of operation per day, TerramEarth collects a total of about 9 TB/day from these connected vehicles.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's existing architecture is composed of Linux and Windows-based systems that reside in a single U.S, west coast based data center. These systems gzip CSV files from the field and upload via FTP, and place the data in their data warehouse. Because this process takes time, aggregated reports are based on data that is 3 weeks old. With this data, TerramEarth has been able to preemptively stock replacement parts and reduce unplanned downtime of their vehicles by 60%. However, because the data is stale, some customers are without their vehicles for up to 4 weeks while they wait for replacement parts.\n<strong>Business Requirements </strong><br> - Decrease unplanned vehicle downtime to less than 1 week. Support the dealer network with more data on how their customers use their equipment to better position new products and services. Have the ability to partner with different companies – especially with seed and fertilizer suppliers in the fast-growing agricultural business – to create compelling joint offerings for their customers.\n<strong>Technical Requirements -</strong> Expand beyond a single datacenter to decrease latency to the American midwest and east coast. Create a backup strategy. Increase security of data transfer from equipment to the datacenter. Improve data in the data warehouse. Use customer and equipment data to anticipate customer needs. Application 1: Data ingest - A custom Python application reads uploaded datafiles from a single server, writes to the data warehouse. Compute: Windows Server 2008 R2 - 16 CPUs - 128 GB of RAM - 10 TB local HDD storage. Application 2: Reporting - An off the shelf application that business analysts use to run a daily report to see what equipment needs repair. Only 2 analysts of a team of 10 | west coast, 5 east coast) can connect to the reporting application at a time. Compute: Off the shelf application. License tied to number of physical CPUs - Windows Server 2008 R2 - 16 CPUs - 32 GB of RAM - 500 GB HDD. Data warehouse: A single PostgreSQL server - RedHat Linux - 64 CPUs - 128 GB of RAM - 4x 6TB HDD in RAID 0.\n<strong>Executive Statement -</strong> Our competitive advantage has always been in our manufacturing process, with our ability to build better vehicles for lower cost than our competitors. However, new products with different approaches are constantly being developed, and I'm concerned that we lack the skills to undergo the next wave of transformations in our industry. My goals are to build our skills while addressing immediate market needs through incremental innovations."
  },
  {
    "id": 254,
    "topic": "Serverless",
    "question": "For this question, refer to the TerramEarth case study (v3 - listed above).\nYou start to build a new application that uses a few Cloud Functions for the backend. One use case requires a Cloud Function func_display to invoke another Cloud Function func_query.\nYou want func_query only to accept invocations from func_display. You also want to follow Google's recommended best practices.\nWhat should you do?",
    "options": {
      "A": "Create a token and pass it in as an environment variable to func_display. When invoking func_query, include the token in the request. Pass the same token to func_query and reject the invocation if the tokens are different.",
      "B": "Make func_query ‘Require authentication.’ Create a unique service account and associate it to func_display. Grant the service account invoker role for func_query. Create an id token in func_display and include the token to the request when invoking func_query.",
      "C": "Make func_query ‘Require authentication’ and only accept internal traffic. Create those two functions in the same VPC. Create an ingress firewall rule for func_query to only allow traffic from func_display.",
      "D": "Create those two functions in the same project and VPC. Make func_query only accept internal traffic. Create an ingress firewall for func_query to only allow traffic from func_display. Also, make sure both functions use the same service account."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "The recommended secure method for function-to-function invocation is using IAM: Make the target function (`func_query`) private ('Require authentication'). Create a dedicated service account for the caller (`func_display`). Grant this service account the `roles/cloudfunctions.invoker` role *on* `func_query`. The caller (`func_display`) then generates an OIDC identity token for its service account and includes it in the `Authorization: Bearer` header when calling `func_query`. GCP verifies the token and permissions. This avoids shared secrets (A) and complex network configurations (C, D).",
    "conditions": [
      "Cloud Function `func_display` invokes `func_query`",
      "`func_query` only accepts calls from `func_display`",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong>Business Requirements </strong><br> - Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical Requirements -</strong> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally Manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive Statement -</strong> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 255,
    "topic": "Serverless",
    "question": "For this question, refer to the TerramEarth case study (v3 - listed above).\nYou have broken down a legacy monolithic application into a few containerized RESTful microservices.\nYou want to run those microservices on Cloud Run. You also want to make sure the services are highly available with low latency to your customers.\nWhat should you do?",
    "options": {
      "A": "Deploy Cloud Run services to multiple availability zones. Create Cloud Endpoints that point to the services. Create a global HTTP(S) Load Balancing instance and attach the Cloud Endpoints to its backend.",
      "B": "Deploy Cloud Run services to multiple regions. Create serverless network endpoint groups pointing to the services. Add the serverless NEGs to a backend service that is used by a global HTTP(S) Load Balancing instance.",
      "C": "Deploy Cloud Run services to multiple regions. In Cloud DNS, create a latency-based DNS name that points to the services.",
      "D": "Deploy Cloud Run services to multiple availability zones. Create a TCP/IP global load balancer. Add the Cloud Run Endpoints to its backend service."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "For high availability and global low latency with Cloud Run: Deploy the service to multiple GCP regions. Use Serverless Network Endpoint Groups (NEGs) to represent the Cloud Run service in each region. Configure a Global HTTP(S) Load Balancer with a backend service that uses these serverless NEGs. The load balancer will route users to the nearest healthy Cloud Run region.",
    "conditions": [
      "Containerized RESTful microservices",
      "Deploy on Cloud Run",
      "Ensure high availability and low latency"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong>Business Requirements </strong><br> - Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical Requirements -</strong> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally Manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive Statement -</strong> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 256,
    "topic": "Security",
    "question": "For this question, refer to the TerramEarth case study (v3 - listed above).\nYou are migrating a Linux-based application from your private data center to Google Cloud. The TerramEarth security team sent you several recent Linux vulnerabilities published by Common Vulnerabilities and Exposures (CVE).\nYou need assistance in understanding how these vulnerabilities could impact your migration.\nWhat should you do? (Choose two.)",
    "options": {
      "A": "Open a support case regarding the CVE and chat with the support engineer.",
      "B": "Read the CVEs from the Google Cloud Status Dashboard to understand the impact.",
      "C": "Read the CVEs from the Google Cloud Platform Security Bulletins to understand the impact.",
      "D": "Post a question regarding the CVE in Stack Overflow to get an explanation.",
      "E": "Post a question regarding the CVE in a Google Cloud discussion group to get an explanation."
    },
    "correctAnswer": [
      "A",
      "C"
    ],
    "explanation": "To understand the impact of CVEs on GCP: C) Check the official Google Cloud Security Bulletins, which detail vulnerabilities affecting GCP services and images. A) For specific questions about impact on your particular migrated application or configuration, opening a GCP support case provides direct access to expert assistance.",
    "conditions": [
      "Migrating Linux app to GCP",
      "Received list of Linux CVEs",
      "Need help understanding impact on migration"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong>Business Requirements </strong><br> - Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical Requirements -</strong> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally Manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive Statement -</strong> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 257,
    "topic": "Operations",
    "question": "For this question, refer to the TerramEarth case study (v3 - listed above).\nTerramEarth has a legacy web application that you cannot migrate to cloud. However, you still want to build a cloud-native way to monitor the application. If the application goes down, you want the URL to point to a \"Site is unavailable\" page as soon as possible. You also want your Ops team to receive a notification for the issue. You need to build a reliable solution for minimum cost.\nWhat should you do?",
    "options": {
      "A": "Create a scheduled job in Cloud Run to invoke a container every minute. The container will check the application URL. If the application is down, switch the URL to the \"Site is unavailable” page, and notify the Ops team.",
      "B": "Create a cron job on a Compute Engine VM that runs every minute. The cron job invokes a Python program to check the application URL. If the application is down, switch the URL to the \"Site is unavailable\" page, and notify the Ops team.",
      "C": "Create a Cloud Monitoring uptime check to validate the application URL. If it fails, put a message in a Pub/Sub queue that triggers a Cloud Function to switch the URL to the \"Site is unavailable\" page, and notify the Ops team.",
      "D": "Use Cloud Error Reporting to check the application URL. If the application is down, switch the URL to the \"Site is unavailable\" page, and notify the Ops team."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Use Cloud Monitoring Uptime Checks for reliable, low-cost external endpoint monitoring. Configure an alerting policy based on the uptime check failure. This policy can trigger notifications (email, PagerDuty, etc.) for the Ops team and simultaneously publish a message to Pub/Sub. A Cloud Function triggered by the Pub/Sub message can then perform the automated failover action (e.g., update DNS or load balancer). This uses managed services effectively (C).",
    "conditions": [
      "Monitor legacy web app (cannot migrate)",
      "On failure: Redirect URL to static page ASAP, notify Ops team",
      "Reliable, minimum cost solution"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong>Business Requirements </strong><br> - Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical Requirements -</strong> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally Manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive Statement -</strong> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 258,
    "topic": "DevOps",
    "question": "For this question, refer to the TerramEarth case study (v3 - listed above).\nYou are building a microservice-based application for TerramEarth. The application is based on Docker containers. You want to follow Google-recommended practices to build the application continuously and store the build artifacts.\nWhat should you do?",
    "options": {
      "A": "Configure a trigger in Cloud Build for new source changes. Invoke Cloud Build to build container images for each microservice, and tag them using the code commit hash. Push the images to the Container Registry.",
      "B": "Configure a trigger in Cloud Build for new source changes. The trigger invokes build jobs and build container images for the microservices. Tag the images with a version number, and push them to Cloud Storage.",
      "C": "Create a Scheduler job to check the repo every minute. For any new change, invoke Cloud Build to build container images for the microservices. Tag the images using the current timestamp, and push them to the Container Registry.",
      "D": "Configure a trigger in Cloud Build for new source changes. Invoke Cloud Build to build one container image, and tag the image with the tag ‘latest.’ Push the image to the Container Registry."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Recommended CI practice for containerized microservices: Use Cloud Build triggered by source code changes. Have Cloud Build build the Docker image for each affected microservice. Tag the image immutably, using the Git commit hash for traceability. Push the tagged image to Artifact Registry (formerly Container Registry). Option A follows these steps.",
    "conditions": [
      "Build microservice application (Docker containers)",
      "Continuous build",
      "Store build artifacts",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong>Business Requirements </strong><br> - Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical Requirements -</strong> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally Manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive Statement -</strong> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 259,
    "topic": "Storage",
    "question": "For this question, refer to the TerramEarth case study (v3 - listed above).\nTerramEarth has about 1 petabyte (PB) of vehicle testing data in a private data center. You want to move the data to Cloud Storage for your machine learning team. Currently, a 1-Gbps interconnect link is available for you. The machine learning team wants to start using the data in a month.\nWhat should you do?",
    "options": {
      "A": "Request Transfer Appliances from Google Cloud, export the data to appliances, and return the appliances to Google Cloud.",
      "B": "Configure the Storage Transfer service from Google Cloud to send the data from your data center to Cloud Storage.",
      "C": "Make sure there are no other users consuming the 1Gbps link, and use multi-thread transfer to upload the data to Cloud Storage.",
      "D": "Export files to an encrypted USB device, send the device to Google Cloud, and request an import of the data to Cloud Storage."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Transferring 1 PB over a 1 Gbps link would take ~90-100 days, far exceeding the 1-month deadline. For large offline data transfers (petabyte scale), Google's Transfer Appliance (A) is the recommended solution. Data is copied to the physical appliance on-premises and shipped to Google for fast ingestion into Cloud Storage.",
    "conditions": [
      "Move 1 PB data from private DC to Cloud Storage",
      "1 Gbps interconnect available",
      "Data needed within 1 month"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- TerramEarth manufactures heavy equipment for the mining and agricultural industries. They currently have over 500 dealers and service centers in 100 countries. Their mission is to build products that make their customers more productive.\n<strong>Solution Concept </strong><br> - There are 2 million TerramEarth vehicles in operation currently, and we see 20% yearly growth. Vehicles collect telemetry data from many sensors during operation. A small subset of critical data is transmitted from the vehicles in real time to facilitate fleet management. The rest of the sensor data is collected, compressed, and uploaded daily when the vehicles return to home base. Each vehicle usually generates 200 to 500 megabytes of data per day.\n<strong>Existing Technical Environment </strong><br> - TerramEarth's vehicle data aggregation and analysis infrastructure resides in Google Cloud and serves clients from all around the world. A growing amount of sensor data is captured from their two main manufacturing plants and sent to private data centers that contain their legacy inventory and logistics management systems. The private data centers have multiple network interconnects configured to Google Cloud. The web frontend for dealers and customers is running in Google Cloud and allows access to stock management and analytics.\n<strong>Business Requirements </strong><br> - Predict and detect vehicle malfunction and rapidly ship parts to dealerships for just-in-time repair where possible. Decrease cloud operational costs and adapt to seasonality. Increase speed and reliability of development workflow. Allow remote developers to be productive without compromising code or data security. Create a flexible and scalable platform for developers to create custom API services for dealers and partners.\n<strong>Technical Requirements -</strong> Create a new abstraction layer for HTTP API access to their legacy systems to enable a gradual move into the cloud without disrupting operations. Modernize all CI/CD pipelines to allow developers to deploy container-based workloads in highly scalable environments. Allow developers to run experiments without compromising security and governance requirements. Create a self-service portal for internal and partner developers to create new projects, request resources for data analytics jobs, and centrally Manage access to the API endpoints. Use cloud-native solutions for keys and secrets management and optimize for identity-based access. Improve and standardize tools necessary for application and network monitoring and troubleshooting.\n<strong>Executive Statement -</strong> Our competitive advantage has always been our focus on the customer, with our ability to provide excellent customer service and minimize vehicle downtimes. After moving multiple systems into Google Cloud, we are seeking new ways to provide best-in-class online fleet management services to our customers and improve operations of our dealerships. Our 5-year strategic plan is to create a partner ecosystem of new products by enabling access to our data, increasing autonomous operation capabilities of our vehicles, and creating a path to move the remaining legacy systems to the cloud."
  },
  {
    "id": 260,
    "topic": "Compute",
    "question": "You have an application that will run on Compute Engine. You need to design an architecture that takes into account a disaster recovery plan that requires your application to fail over to another region in case of a regional outage. What should you do?",
    "options": {
      "A": "Deploy the application on two Compute Engine instances in the same project but in a different region. Use the first instance to serve traffic, and use the HTTP load balancing service to fail over to the standby instance in case of a disaster.",
      "B": "Deploy the application on a Compute Engine instance. Use the instance to serve traffic, and use the HTTP load balancing service to fail over to an instance on your premises in case of a disaster.",
      "C": "Deploy the application on two Compute Engine instance groups, each in the same project but in a different region. Use the first instance group to serve traffic, and use the HTTP load balancing service to fail over to the standby instance group in case of a disaster.",
      "D": "Deploy the application on two Compute Engine instance groups, each in separate project and a different region. Use the first instance group to server traffic, and use the HTTP load balancing service to fail over to the standby instance in case of a disaster."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "For regional DR, deploy independent instances of the application in separate regions using Managed Instance Groups (MIGs) for scalability and availability within each region. Use a Global HTTP(S) Load Balancer, which can direct traffic to the primary region's MIG and automatically fail over to the secondary region's MIG if the primary becomes unavailable. Option C describes this standard multi-region deployment with global load balancing.",
    "conditions": [
      "Application on GCE",
      "DR plan requires regional failover"
    ],
    "caseStudyContext": null
  },
  {
    "id": 261,
    "topic": "Storage",
    "question": "For this question, refer to the Dress4Win case study (v1 - listed above).\nAt Dress4Win, an operations engineer wants to create a tow-cost solution to remotely archive copies of database backup files.\nThe database files are compressed tar files stored in their current data center.\nHow should he proceed?",
    "options": {
      "A": "Create a cron script using gsutil to copy the files to a Coldline Storage bucket.",
      "B": "Create a cron script using gsutil to copy the files to a Regional Storage bucket.",
      "C": "Create a Cloud Storage Transfer Service Job to copy the files to a Coldline Storage bucket.",
      "D": "Create a Cloud Storage Transfer Service job to copy the files to a Regional Storage bucket."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Goal is low-cost archival of on-prem backup files. Cloud Storage Coldline provides the lowest storage cost for infrequent access. `gsutil` run via a cron job is the standard way to automate uploads from on-prem to GCS.",
    "conditions": [
      "Low-cost archival",
      "Archive on-prem DB backups (tar files)",
      "Remote archive (to cloud)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a website and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a premium app model. The company has grown from a few servers in the founder's garage to several hundred servers and appliances in a collocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is considering moving their development and test environments. They are also considering building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. Databases: MySQL - user data, inventory, static data, Redis - metadata, social graph, caching. Application servers: Tomcat - Java micro-services, Nginx - static content, Apache Beam - Batch processing. Storage appliances: iSCSI for VM hosts, Fiber channel SAN - MySQL databases, NAS - image storage, logs, backups. Apache Hadoop/Spark servers: Data analysis, Real-time trending calculations. MQ servers: Messaging, Social notifications, Events. Miscellaneous servers: Jenkins, monitoring, bastion hosts, security scanners.\n<strong>Business Requirements </strong><br> - Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and Identity and Access Management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud. Migrate fully to the cloud if all other requirements are met.\n<strong>Technical Requirements -</strong> Evaluate and choose an automation framework for provisioning resources in cloud. Support failover of the production environment to cloud during an emergency. Identify production services that can migrate to cloud to save capacity. Use managed services whenever possible. Encrypt data on the wire and at rest. Support multiple VPN connections between the production data center and cloud environment.\n<strong>CEO Statement </strong><br> - Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a new competitor could use a public cloud platform to offset their up-front investment and freeing them to focus on developing better features.\n<strong>CTO Statement  </strong><br>- We have invested heavily in the current infrastructure, but much of the equipment is approaching the end of its useful life. We are consistently waiting weeks for new gear to be racked before we can start new projects. Our traffic patterns are highest in the mornings and weekend evenings: during other times, 80% of our capacity is sitting idle.\nCFO Statement - Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years puts a cloud strategy between 30 to 50% lower than our current model."
  },
  {
    "id": 262,
    "topic": "Compute",
    "question": "For this question, refer to the Dress4Win case study (v1 - listed above).\nDress4Win has asked you to recommend machine types they should deploy their application servers to.\nHow should you proceed?",
    "options": {
      "A": "Perform a mapping of the on-premises physical hardware cores and RAM to the nearest machine types in the cloud.",
      "B": "Recommend that Dress4Win deploy application servers to machine types that offer the highest RAM to CPU ratio available.",
      "C": "Recommend that Dress4Win deploy into production with the smallest instances available, monitor them over time, and scale the machine type up until the desired performance is reached.",
      "D": "Identify the number of virtual cores and RAM associated with the application server virtual machines align them to a custom machine type in the cloud, monitor performance, and scale the machine types up until the desired performance is reached."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "The case study provides specs for the existing web servers (4 core, 32GB RAM). The best approach is to start with a similar GCE machine type (standard or potentially a custom machine type for exact match), deploy the application, install monitoring agents, run under load, and then use monitoring data and Rightsizing Recommendations to adjust the machine type for optimal performance and cost.",
    "conditions": [
      "Recommend GCE machine types for web app servers",
      "Existing specs: 4 core, 32GB RAM",
      "Analyze and optimize architecture for performance"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a website and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a premium app model. The company has grown from a few servers in the founder's garage to several hundred servers and appliances in a collocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is considering moving their development and test environments. They are also considering building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. Databases: MySQL - user data, inventory, static data, Redis - metadata, social graph, caching. Application servers: Tomcat - Java micro-services, Nginx - static content (Four core CPUs, 32 GB of RAM), Apache Beam - Batch processing. Storage appliances: iSCSI for VM hosts, Fiber channel SAN - MySQL databases, NAS - image storage, logs, backups. Apache Hadoop/Spark servers: Data analysis, Real-time trending calculations. MQ servers: Messaging, Social notifications, Events. Miscellaneous servers: Jenkins, monitoring, bastion hosts, security scanners.\n<strong>Business Requirements </strong><br> - Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and Identity and Access Management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud. Migrate fully to the cloud if all other requirements are met.\n<strong>Technical Requirements -</strong> Evaluate and choose an automation framework for provisioning resources in cloud. Support failover of the production environment to cloud during an emergency. Identify production services that can migrate to cloud to save capacity. Use managed services whenever possible. Encrypt data on the wire and at rest. Support multiple VPN connections between the production data center and cloud environment.\n<strong>CEO Statement </strong><br> - Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a new competitor could use a public cloud platform to offset their up-front investment and freeing them to focus on developing better features.\n<strong>CTO Statement  </strong><br>- We have invested heavily in the current infrastructure, but much of the equipment is approaching the end of its useful life. We are consistently waiting weeks for new gear to be racked before we can start new projects. Our traffic patterns are highest in the mornings and weekend evenings: during other times, 80% of our capacity is sitting idle.\nCFO Statement - Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years puts a cloud strategy between 30 to 50% lower than our current model."
  },
  {
    "id": 263,
    "topic": "Operations",
    "question": "For this question, refer to the Dress4Win case study (v1 - listed above).\nAs part of Dress4Win's plans to migrate to the cloud, they want to be able to set up a managed logging and monitoring system so they can handle spikes in their traffic load.\nThey want to ensure that:\n\n* The infrastructure can be notified when it needs to scale up and down to handle the ebb and flow of usage throughout the day\n* Their administrators are notified automatically when their application reports errors.\n* They can filter their aggregated logs down in order to debug one piece of the application across many hosts\n\nWhich Google StackDriver features should they use?",
    "options": {
      "A": "Logging, Alerts, Insights, Debug",
      "B": "Monitoring, Trace, Debug, Logging",
      "C": "Monitoring, Logging, Alerts, Error Reporting",
      "D": "Monitoring, Logging, Debug, Error Reporting"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Mapping requirements to Cloud Operations (Stackdriver) features: Scaling needs rely on Monitoring metrics. Admin error notifications use Alerts and Error Reporting. Log filtering/debugging uses Logging. Option C covers these required components.",
    "conditions": [
      "Set up managed logging/monitoring",
      "Handle traffic spikes (scaling)",
      "Notify infra for scaling",
      "Notify admins on app errors",
      "Filter aggregated logs for debugging"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a website and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a premium app model. The company has grown from a few servers in the founder's garage to several hundred servers and appliances in a collocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is considering moving their development and test environments. They are also considering building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. Databases: MySQL - user data, inventory, static data, Redis - metadata, social graph, caching. Application servers: Tomcat - Java micro-services, Nginx - static content, Apache Beam - Batch processing. Storage appliances: iSCSI for VM hosts, Fiber channel SAN - MySQL databases, NAS - image storage, logs, backups. Apache Hadoop/Spark servers: Data analysis, Real-time trending calculations. MQ servers: Messaging, Social notifications, Events. Miscellaneous servers: Jenkins, monitoring, bastion hosts, security scanners.\n<strong>Business Requirements </strong><br> - Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and Identity and Access Management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud. Migrate fully to the cloud if all other requirements are met.\n<strong>Technical Requirements -</strong> Evaluate and choose an automation framework for provisioning resources in cloud. Support failover of the production environment to cloud during an emergency. Identify production services that can migrate to cloud to save capacity. Use managed services whenever possible. Encrypt data on the wire and at rest. Support multiple VPN connections between the production data center and cloud environment.\n<strong>CEO Statement </strong><br> - Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a new competitor could use a public cloud platform to offset their up-front investment and freeing them to focus on developing better features.\n<strong>CTO Statement  </strong><br>- We have invested heavily in the current infrastructure, but much of the equipment is approaching the end of its useful life. We are consistently waiting weeks for new gear to be racked before we can start new projects. Our traffic patterns are highest in the mornings and weekend evenings: during other times, 80% of our capacity is sitting idle.\nCFO Statement - Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years puts a cloud strategy between 30 to 50% lower than our current model."
  },
  {
    "id": 264,
    "topic": "Migration",
    "question": "For this question, refer to the Dress4Win case study (v1 - listed above).\nDress4Win would like to become familiar with deploying applications to the cloud by successfully deploying some applications quickly, as is.\nThey have asked for your recommendation.\nWhat should you advise?",
    "options": {
      "A": "Identify self-contained applications with external dependencies as a first move to the cloud.",
      "B": "Identify enterprise applications with internal dependencies and recommend these as a first move to the cloud.",
      "C": "Suggest moving their in-house databases to the cloud and continue serving requests to on-premise applications.",
      "D": "Recommend moving their message queuing servers to the cloud and continue handling requests to on-premise applications."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "For a quick, 'as-is' familiarization migration, choose applications that are relatively self-contained with minimal, well-defined external dependencies (A). This minimizes complexity and risk. Migrating complex apps with many internal dependencies (B) or stateful components like databases (C) or message queues (D) first often introduces significant challenges and latency issues.",
    "conditions": [
      "Goal: Familiarization via quick, as-is deployment",
      "Recommend first applications to migrate"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a website and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a premium app model. The company has grown from a few servers in the founder's garage to several hundred servers and appliances in a collocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is considering moving their development and test environments. They are also considering building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. Databases: MySQL - user data, inventory, static data, Redis - metadata, social graph, caching. Application servers: Tomcat - Java micro-services, Nginx - static content, Apache Beam - Batch processing. Storage appliances: iSCSI for VM hosts, Fiber channel SAN - MySQL databases, NAS - image storage, logs, backups. Apache Hadoop/Spark servers: Data analysis, Real-time trending calculations. MQ servers: Messaging, Social notifications, Events. Miscellaneous servers: Jenkins, monitoring, bastion hosts, security scanners.\n<strong>Business Requirements </strong><br> - Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and Identity and Access Management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud. Migrate fully to the cloud if all other requirements are met.\n<strong>Technical Requirements -</strong> Evaluate and choose an automation framework for provisioning resources in cloud. Support failover of the production environment to cloud during an emergency. Identify production services that can migrate to cloud to save capacity. Use managed services whenever possible. Encrypt data on the wire and at rest. Support multiple VPN connections between the production data center and cloud environment.\n<strong>CEO Statement </strong><br> - Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a new competitor could use a public cloud platform to offset their up-front investment and freeing them to focus on developing better features.\n<strong>CTO Statement  </strong><br>- We have invested heavily in the current infrastructure, but much of the equipment is approaching the end of its useful life. We are consistently waiting weeks for new gear to be racked before we can start new projects. Our traffic patterns are highest in the mornings and weekend evenings: during other times, 80% of our capacity is sitting idle.\nCFO Statement - Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years puts a cloud strategy between 30 to 50% lower than our current model."
  },
  {
    "id": 265,
    "topic": "Databases",
    "question": "For this question, refer to the Dress4Win case study (v1 - listed above).\nDress4Win has asked you for advice on how to migrate their on-premises MySQL deployment to the cloud.\nThey want to minimize downtime and performance impact to their on-premises solution during the migration.\nWhich approach should you recommend?",
    "options": {
      "A": "Create a dump of the on-premises MySQL master server, and then shut it down, upload it to the cloud environment, and load into a new MySQL cluster.",
      "B": "Setup a MySQL replica server/slave in the cloud environment, and configure it for asynchronous replication from the MySQL master server on-premises until cutover.",
      "C": "Create a new MySQL cluster in the cloud, configure applications to begin writing to both on premises and cloud MySQL masters, and destroy the original cluster at cutover.",
      "D": "Create a dump of the MySQL replica server into the cloud environment, load it into: Google Cloud Datastore, and configure applications to read/write to Cloud Datastore at cutover."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Setting up the cloud database (e.g., Cloud SQL) as a replica of the on-premises master (B) allows continuous data synchronization with minimal impact on the source. During cutover, stop writes, wait for replication lag to reach zero, promote the cloud replica, and redirect applications. This significantly minimizes downtime compared to dump/restore (A) or complex dual-write setups (C). Migrating to Datastore (D) is not a like-for-like MySQL migration.",
    "conditions": [
      "Migrate on-prem MySQL to cloud",
      "Minimize downtime",
      "Minimize performance impact on source"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a website and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a premium app model. The company has grown from a few servers in the founder's garage to several hundred servers and appliances in a collocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is considering moving their development and test environments. They are also considering building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. Databases: MySQL - user data, inventory, static data (MySQL 5.7), Redis - metadata, social graph, caching. Application servers: Tomcat - Java micro-services, Nginx - static content, Apache Beam - Batch processing. Storage appliances: iSCSI for VM hosts, Fiber channel SAN - MySQL databases, NAS - image storage, logs, backups. Apache Hadoop/Spark servers: Data analysis, Real-time trending calculations. MQ servers: Messaging, Social notifications, Events. Miscellaneous servers: Jenkins, monitoring, bastion hosts, security scanners.\n<strong>Business Requirements </strong><br> - Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and Identity and Access Management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud. Migrate fully to the cloud if all other requirements are met.\n<strong>Technical Requirements -</strong> Evaluate and choose an automation framework for provisioning resources in cloud. Support failover of the production environment to cloud during an emergency. Identify production services that can migrate to cloud to save capacity. Use managed services whenever possible. Encrypt data on the wire and at rest. Support multiple VPN connections between the production data center and cloud environment.\n<strong>CEO Statement </strong><br> - Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a new competitor could use a public cloud platform to offset their up-front investment and freeing them to focus on developing better features.\n<strong>CTO Statement  </strong><br>- We have invested heavily in the current infrastructure, but much of the equipment is approaching the end of its useful life. We are consistently waiting weeks for new gear to be racked before we can start new projects. Our traffic patterns are highest in the mornings and weekend evenings: during other times, 80% of our capacity is sitting idle.\nCFO Statement - Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years puts a cloud strategy between 30 to 50% lower than our current model."
  },
  {
    "id": 266,
    "topic": "Operations",
    "question": "For this question, refer to the Dress4Win case study (v1 - listed above).\nDress4Win has configured a new uptime check with Google Stackdriver for several of their legacy services. The Stackdriver dashboard is not reporting the services as healthy.\nWhat should they do?",
    "options": {
      "A": "Install the Stackdriver agent on all of the legacy web servers.",
      "B": "In the Cloud Platform Console download the list of the uptime servers' IP addresses and create an inbound firewall rule",
      "C": "Configure their load balancer to pass through the User-Agent HTTP header when the value matches GoogleStackdriverMonitoring-UptimeChecks (https:// cloud.google.com/monitoring)",
      "D": "Configure their legacy web servers to allow requests that contain user-Agent HTTP header when the value matches GoogleStackdriverMonitoring-UptimeChecks (https://cloud.google.com/monitoring)"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Cloud Monitoring (Stackdriver) Uptime Checks originate from globally distributed Google IP addresses. If the legacy services are behind a firewall, that firewall must be configured to allow inbound traffic from the specific IP ranges used by the uptime checkers. Google publishes these IP ranges, which need to be added to the firewall allow-list (B).",
    "conditions": [
      "Configured Stackdriver Uptime Check for legacy services",
      "Dashboard shows services unhealthy",
      "Troubleshoot uptime check failure"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a website and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a premium app model. The company has grown from a few servers in the founder's garage to several hundred servers and appliances in a collocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is considering moving their development and test environments. They are also considering building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. Databases: MySQL - user data, inventory, static data, Redis - metadata, social graph, caching. Application servers: Tomcat - Java micro-services, Nginx - static content, Apache Beam - Batch processing. Storage appliances: iSCSI for VM hosts, Fiber channel SAN - MySQL databases, NAS - image storage, logs, backups. Apache Hadoop/Spark servers: Data analysis, Real-time trending calculations. MQ servers: Messaging, Social notifications, Events. Miscellaneous servers: Jenkins, monitoring, bastion hosts, security scanners.\n<strong>Business Requirements </strong><br> - Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and Identity and Access Management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud. Migrate fully to the cloud if all other requirements are met.\n<strong>Technical Requirements -</strong> Evaluate and choose an automation framework for provisioning resources in cloud. Support failover of the production environment to cloud during an emergency. Identify production services that can migrate to cloud to save capacity. Use managed services whenever possible. Encrypt data on the wire and at rest. Support multiple VPN connections between the production data center and cloud environment.\n<strong>CEO Statement </strong><br> - Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a new competitor could use a public cloud platform to offset their up-front investment and freeing them to focus on developing better features.\n<strong>CTO Statement  </strong><br>- We have invested heavily in the current infrastructure, but much of the equipment is approaching the end of its useful life. We are consistently waiting weeks for new gear to be racked before we can start new projects. Our traffic patterns are highest in the mornings and weekend evenings: during other times, 80% of our capacity is sitting idle.\nCFO Statement - Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years puts a cloud strategy between 30 to 50% lower than our current model."
  },
  {
    "id": 267,
    "topic": "Storage",
    "question": "For this question, refer to the Dress4Win case study (v1 - listed above).\nAs part of their new application experience, Dress4Win allows customers to upload images of themselves.\nThe customer has exclusive control over who may view these images.\nCustomers should be able to upload images with minimal latency and also be shown their images quickly on the main application page when they log in.\nWhich configuration should Dress4Win use?",
    "options": {
      "A": "Store image files in a Google Cloud Storage bucket. Use Google Cloud Datastore to maintain metadata that maps each customer's ID and their image files.",
      "B": "Store image files in a Google Cloud Storage bucket. Add custom metadata to the uploaded images in Cloud Storage that contains the customer's unique ID.",
      "C": "Use a distributed file system to store customers’ images. As storage needs increase, add more persistent disks and/or nodes. Assign each customer a unique ID, which sets each file's owner attribute, ensuring privacy of images.",
      "D": "Use a distributed file system to store customers’ images. As storage needs increase, add more persistent disks and/or nodes. Use a Google Cloud SQL database to maintain metadata that maps each customer's ID to their image files."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Cloud Storage is ideal for storing image files scalably. To quickly retrieve a specific user's images on login, store metadata (mapping user ID to image object names/URLs) in a low-latency database like Cloud Datastore (Firestore in Datastore mode). Querying Datastore by user ID is fast. Relying on GCS metadata (B) requires listing objects, which is inefficient for this use case. Distributed file systems (C, D) add complexity and cost.",
    "conditions": [
      "Customers upload images",
      "Customer controls viewing permissions",
      "Minimal latency for uploads",
      "Quick display of user's images on login"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a website and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a premium app model. The company has grown from a few servers in the founder's garage to several hundred servers and appliances in a collocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is considering moving their development and test environments. They are also considering building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. Databases: MySQL - user data, inventory, static data, Redis - metadata, social graph, caching. Application servers: Tomcat - Java micro-services, Nginx - static content, Apache Beam - Batch processing. Storage appliances: iSCSI for VM hosts, Fiber channel SAN - MySQL databases, NAS - image storage, logs, backups. Apache Hadoop/Spark servers: Data analysis, Real-time trending calculations. MQ servers: Messaging, Social notifications, Events. Miscellaneous servers: Jenkins, monitoring, bastion hosts, security scanners.\n<strong>Business Requirements </strong><br> - Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and Identity and Access Management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud. Migrate fully to the cloud if all other requirements are met.\n<strong>Technical Requirements -</strong> Evaluate and choose an automation framework for provisioning resources in cloud. Support failover of the production environment to cloud during an emergency. Identify production services that can migrate to cloud to save capacity. Use managed services whenever possible. Encrypt data on the wire and at rest. Support multiple VPN connections between the production data center and cloud environment.\n<strong>CEO Statement </strong><br> - Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a new competitor could use a public cloud platform to offset their up-front investment and freeing them to focus on developing better features.\n<strong>CTO Statement  </strong><br>- We have invested heavily in the current infrastructure, but much of the equipment is approaching the end of its useful life. We are consistently waiting weeks for new gear to be racked before we can start new projects. Our traffic patterns are highest in the mornings and weekend evenings: during other times, 80% of our capacity is sitting idle.\nCFO Statement - Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years puts a cloud strategy between 30 to 50% lower than our current model."
  },
  {
    "id": 268,
    "topic": "DevOps",
    "question": "For this question, refer to the Dress4Win case study (v1 - listed above).\nDress4Win has end-to-end tests covering 100% of their endpoints.\nThey want to ensure that the move to the cloud does not introduce any new bugs.\nWhich additional testing methods should the developers employ to prevent an outage?",
    "options": {
      "A": "They should enable Google Stackdriver Debugger on the application code to show errors in the code.",
      "B": "They should add additional unit tests and production scale load tests on their cloud staging environment.",
      "C": "They should run the end-to-end tests in the cloud staging environment to determine if the code is working as intended.",
      "D": "They should add canary tests so developers can measure how much of an impact the new release causes to latency."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Existing end-to-end tests (run in staging - C) verify functionality but not component-level correctness or performance under load. Adding unit tests ensures individual code units work correctly after migration/changes. Adding production-scale load tests verifies performance and scalability in the new cloud environment, identifying bottlenecks or bugs missed by functional tests (B).",
    "conditions": [
      "Existing end-to-end tests",
      "Migrating to cloud",
      "Goal: Prevent new bugs/outages",
      "Need additional testing methods"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a website and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a premium app model. The company has grown from a few servers in the founder's garage to several hundred servers and appliances in a collocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is considering moving their development and test environments. They are also considering building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. Databases: MySQL - user data, inventory, static data, Redis - metadata, social graph, caching. Application servers: Tomcat - Java micro-services, Nginx - static content, Apache Beam - Batch processing. Storage appliances: iSCSI for VM hosts, Fiber channel SAN - MySQL databases, NAS - image storage, logs, backups. Apache Hadoop/Spark servers: Data analysis, Real-time trending calculations. MQ servers: Messaging, Social notifications, Events. Miscellaneous servers: Jenkins, monitoring, bastion hosts, security scanners.\n<strong>Business Requirements </strong><br> - Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and Identity and Access Management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud. Migrate fully to the cloud if all other requirements are met.\n<strong>Technical Requirements -</strong> Evaluate and choose an automation framework for provisioning resources in cloud. Support failover of the production environment to cloud during an emergency. Identify production services that can migrate to cloud to save capacity. Use managed services whenever possible. Encrypt data on the wire and at rest. Support multiple VPN connections between the production data center and cloud environment.\n<strong>CEO Statement </strong><br> - Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a new competitor could use a public cloud platform to offset their up-front investment and freeing them to focus on developing better features.\n<strong>CTO Statement  </strong><br>- We have invested heavily in the current infrastructure, but much of the equipment is approaching the end of its useful life. We are consistently waiting weeks for new gear to be racked before we can start new projects. Our traffic patterns are highest in the mornings and weekend evenings: during other times, 80% of our capacity is sitting idle.\nCFO Statement - Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years puts a cloud strategy between 30 to 50% lower than our current model."
  },
  {
    "id": 269,
    "topic": "Storage",
    "question": "For this question, refer to the Dress4Win case study (v1 - listed above).\nYou want to ensure Dress4Win's sales and tax records remain available for infrequent viewing by auditors for at least 10 years.\nCost optimization is your top priority.\nWhich cloud services should you choose?",
    "options": {
      "A": "Google Cloud Storage Coldline to store the data, and gsutil to access the data.",
      "B": "Google Cloud Storage Nearline to store the data, and gsutil to access the data.",
      "C": "Google Bigtable with US or EU as location to store the data, and gcloud to access the data.",
      "D": "BigQuery to store the data, and a web server cluster in a managed instance group to access the data. Google Cloud SQL mirrored across two distinct regions to store the data, and a Redis cluster in a managed instance group to access the data."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Long-term (10 years) storage for infrequent access (auditors) with cost as the top priority points to Cloud Storage Coldline. It offers the lowest storage cost, suitable for archival data accessed less than once a year. `gsutil` is the standard tool for accessing GCS data.",
    "conditions": [
      "Store sales/tax records >= 10 years",
      "Infrequent viewing (auditors)",
      "Top priority: Cost optimization"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a website and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a premium app model. The company has grown from a few servers in the founder's garage to several hundred servers and appliances in a collocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is considering moving their development and test environments. They are also considering building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. Databases: MySQL - user data, inventory, static data, Redis - metadata, social graph, caching. Application servers: Tomcat - Java micro-services, Nginx - static content, Apache Beam - Batch processing. Storage appliances: iSCSI for VM hosts, Fiber channel SAN - MySQL databases, NAS - image storage, logs, backups. Apache Hadoop/Spark servers: Data analysis, Real-time trending calculations. MQ servers: Messaging, Social notifications, Events. Miscellaneous servers: Jenkins, monitoring, bastion hosts, security scanners.\n<strong>Business Requirements </strong><br> - Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and Identity and Access Management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud. Migrate fully to the cloud if all other requirements are met.\n<strong>Technical Requirements -</strong> Evaluate and choose an automation framework for provisioning resources in cloud. Support failover of the production environment to cloud during an emergency. Identify production services that can migrate to cloud to save capacity. Use managed services whenever possible. Encrypt data on the wire and at rest. Support multiple VPN connections between the production data center and cloud environment.\n<strong>CEO Statement </strong><br> - Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a new competitor could use a public cloud platform to offset their up-front investment and freeing them to focus on developing better features.\n<strong>CTO Statement  </strong><br>- We have invested heavily in the current infrastructure, but much of the equipment is approaching the end of its useful life. We are consistently waiting weeks for new gear to be racked before we can start new projects. Our traffic patterns are highest in the mornings and weekend evenings: during other times, 80% of our capacity is sitting idle.\nCFO Statement - Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years puts a cloud strategy between 30 to 50% lower than our current model."
  },
  {
    "id": 270,
    "topic": "Networking",
    "question": "For this question, refer to the Dress4Win case study (v1 - listed above).\nThe current Dress4Win system architecture has high latency to some customers because it is located in one data center.\nAs part of a future evaluation and optimizing for performance in the cloud, Dresss4Win wants to distribute its system architecture to multiple locations when using Google cloud platform.\nWhich approach should they use?",
    "options": {
      "A": "Use regional managed instance groups and a global load balancer to increase performance because the regional managed instance groups can grow instances in each region separately based on traffic.",
      "B": "Use a global load balancer with a set of virtual machines that forward the requests to a closer group of virtual machines managed by your operations team.",
      "C": "Use regional managed instance groups and a global load balancer to increase reliability by providing automatic failover between zones in different regions.",
      "D": "Use a global load balancer with a set of virtual machines that forward the requests to a closer group of virtual machines as part of a separate managed instance groups."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To reduce global latency, deploy application instances in multiple regions close to users using Regional MIGs. Use a Global Load Balancer to route users to the nearest healthy regional MIG. This setup (A) optimizes performance by reducing network distance and allows each region to scale independently based on local traffic.",
    "conditions": [
      "Current high latency due to single DC",
      "Distribute architecture to multiple GCP locations",
      "Optimize for performance (reduce latency)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a website and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a premium app model. The company has grown from a few servers in the founder's garage to several hundred servers and appliances in a collocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is considering moving their development and test environments. They are also considering building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. Databases: MySQL - user data, inventory, static data, Redis - metadata, social graph, caching. Application servers: Tomcat - Java micro-services, Nginx - static content, Apache Beam - Batch processing. Storage appliances: iSCSI for VM hosts, Fiber channel SAN - MySQL databases, NAS - image storage, logs, backups. Apache Hadoop/Spark servers: Data analysis, Real-time trending calculations. MQ servers: Messaging, Social notifications, Events. Miscellaneous servers: Jenkins, monitoring, bastion hosts, security scanners.\n<strong>Business Requirements </strong><br> - Build a reliable and reproducible environment with scaled parity of production. Improve security by defining and adhering to a set of security and Identity and Access Management (IAM) best practices for cloud. Improve business agility and speed of innovation through rapid provisioning of new resources. Analyze and optimize architecture for performance in the cloud. Migrate fully to the cloud if all other requirements are met.\n<strong>Technical Requirements -</strong> Evaluate and choose an automation framework for provisioning resources in cloud. Support failover of the production environment to cloud during an emergency. Identify production services that can migrate to cloud to save capacity. Use managed services whenever possible. Encrypt data on the wire and at rest. Support multiple VPN connections between the production data center and cloud environment.\n<strong>CEO Statement </strong><br> - Our investors are concerned about our ability to scale and contain costs with our current infrastructure. They are also concerned that a new competitor could use a public cloud platform to offset their up-front investment and freeing them to focus on developing better features.\n<strong>CTO Statement  </strong><br>- We have invested heavily in the current infrastructure, but much of the equipment is approaching the end of its useful life. We are consistently waiting weeks for new gear to be racked before we can start new projects. Our traffic patterns are highest in the mornings and weekend evenings: during other times, 80% of our capacity is sitting idle.\nCFO Statement - Our capital expenditure is now exceeding our quarterly projections. Migrating to the cloud will likely cause an initial increase in spending, but we expect to fully transition before our next hardware refresh cycle. Our total cost of ownership (TCO) analysis over the next 5 years puts a cloud strategy between 30 to 50% lower than our current model."
  },
  {
    "id": 271,
    "topic": "Migration",
    "question": "For this question, refer to the Dress4Win case study (v2 - listed above).\nDress4Win is expected to grow to 10 times its size in 1 year with a corresponding growth in data and traffic that mirrors the existing patterns of usage.\nThe CIO has set the target of migrating production infrastructure to the cloud within the next 6 months.\nHow will you configure the solution to scale for this growth without making major application changes and still maximize the ROI?",
    "options": {
      "A": "Migrate the web application layer to App Engine, and MySQL to Cloud Datastore, and NAS to Cloud Storage. Deploy RabbitMQ, and deploy Hadoop servers using Deployment Manager.",
      "B": "Migrate RabbitMQ to Cloud Pub/Sub, Hadoop to BigQuery, and NAS to Compute Engine with Persistent Disk storage. Deploy Tomcat, and deploy Nginx using Deployment Manager.",
      "C": "Implement managed instance groups for Tomcat and Nginx. Migrate MySQL to Cloud SQL, RabbitMQ to Cloud Pub/Sub, Hadoop to Cloud Dataproc, and NAS to Compute Engine with Persistent Disk storage.",
      "D": "Implement managed instance groups for the Tomcat and Nginx. Migrate MySQL to Cloud SQL, RabbitMQ to Cloud Pub/Sub, Hadoop to Cloud Dataproc, and NAS to Cloud Storage."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "To handle 10x growth with minimal application changes and good ROI: Use MIGs for Tomcat/Nginx for web tier scalability. Migrate MySQL to Cloud SQL (managed MySQL). Migrate RabbitMQ to Cloud Pub/Sub (managed, scalable messaging). Migrate Hadoop/Spark to Cloud Dataproc (managed Hadoop/Spark). Migrate NAS data (images, logs, backups) to Cloud Storage (scalable object storage). Option D maps existing components to appropriate scalable, managed GCP services with relatively low migration friction.",
    "conditions": [
      "Expect 10x growth (data/traffic) in 1 year",
      "Migrate production in 6 months",
      "Solution must scale",
      "Minimize major app changes",
      "Maximize ROI"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL 5.7, 8 core CPUs, 128 GB RAM, 2x 5 TB HDD (RAID 1). Redis 3 server cluster, 4 core CPUs, 32GB RAM each. Compute: 40 Web App servers (Tomcat/Java, Nginx, 4 core CPUs, 32 GB RAM). 20 Apache Hadoop/Spark servers (8 core CPUs, 128 GB RAM, 4x 5 TB HDD RAID 1). 3 RabbitMQ servers (8 core CPUs, 32GB RAM). Misc servers (Jenkins, monitoring, bastion, scanners, 8 core CPUs, 32GB RAM). Storage: iSCSI for VM hosts. Fibre channel SAN for MySQL (1 PB total, 400 TB free). NAS for images/logs/backups (100 TB total, 35 TB free).\n<strong>Business Requirements </strong><br> - Reliable/reproducible env. Improve security/IAM. Improve agility/innovation speed. Analyze/optimize performance.\n<strong>Technical Requirements -</strong> Easy non-prod env creation. Automation framework. CI/CD process. Prod failover support. Encrypt data. Multiple private connections.\n<strong>Executive Statement -</strong> Investors concerned re: scale/cost. Competitor threat. Idle capacity (80% off-peak). Capex high. TCO analysis shows 30-50% cloud savings."
  }, {
    "id": 272,
    "topic": "DevOps",
    "question": "For this question, refer to the Dress4Win case study (v2 - listed above).\nConsidering the given <strong>Business Requirements </strong><br>, how would you automate the deployment of web and transactional data layers?",
    "options": {
      "A": "Deploy Nginx and Tomcat using Cloud Deployment Manager to Compute Engine. Deploy a Cloud SQL server to replace MySQL. Deploy Jenkins using Cloud Deployment Manager.",
      "B": "Deploy Nginx and Tomcat using Cloud Launcher. Deploy a MySQL server using Cloud Launcher. Deploy Jenkins to Compute Engine using Cloud Deployment Manager scripts.",
      "C": "Migrate Nginx and Tomcat to App Engine. Deploy a Cloud Datastore server to replace the MySQL server in a high-availability configuration. Deploy Jenkins to Compute Engine using Cloud Launcher.",
      "D": "Migrate Nginx and Tomcat to App Engine. Deploy a MySQL server using Cloud Launcher. Deploy Jenkins to Compute Engine using Cloud Launcher."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "The technical requirements specify implementing an automation framework. Cloud Deployment Manager (CDM) is GCP's native Infrastructure as Code (IaC) service. Using CDM to define and deploy the Compute Engine instances for Nginx/Tomcat (likely within Managed Instance Groups), the Cloud SQL instance (managed MySQL replacement), and potentially the Jenkins server provides the required automation for provisioning these layers.",
    "conditions": [
      "Automate deployment of web layer (Nginx/Tomcat on GCE)",
      "Automate deployment of transactional data layer (MySQL replacement -> Cloud SQL)",
      "Requirement: Implement an automation framework"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL 5.7, 8 core CPUs, 128 GB RAM, 2x 5 TB HDD (RAID 1). Redis 3 server cluster, 4 core CPUs, 32GB RAM each. Compute: 40 Web App servers (Tomcat/Java, Nginx, 4 core CPUs, 32 GB RAM). 20 Apache Hadoop/Spark servers (8 core CPUs, 128 GB RAM, 4x 5 TB HDD RAID 1). 3 RabbitMQ servers (8 core CPUs, 32GB RAM). Misc servers (Jenkins, monitoring, bastion, scanners, 8 core CPUs, 32GB RAM). Storage: iSCSI for VM hosts. Fibre channel SAN for MySQL (1 PB total, 400 TB free). NAS for images/logs/backups (100 TB total, 35 TB free).\n<strong>Business Requirements </strong><br> - Reliable/reproducible env. Improve security/IAM. Improve agility/innovation speed. Analyze/optimize performance.\n<strong>Technical Requirements -</strong> Easy non-prod env creation. Automation framework. CI/CD process. Prod failover support. Encrypt data. Multiple private connections.\n<strong>Executive Statement -</strong> Investors concerned re: scale/cost. Competitor threat. Idle capacity (80% off-peak). Capex high. TCO analysis shows 30-50% cloud savings."
  },
  {
    "id": 273,
    "topic": "Compute",
    "question": "For this question, refer to the Dress4Win case study (v2 - listed above).\nWhich of the compute services should be migrated as-is and would still be an optimized architecture for performance in the cloud?",
    "options": {
      "A": "Web applications deployed using App Engine standard environment",
      "B": "RabbitMQ deployed using an unmanaged instance group",
      "C": "Hadoop/Spark deployed using Cloud Dataproc Regional in High Availability mode",
      "D": "Jenkins, monitoring, bastion hosts, security scanners services deployed on custom machine types"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "The existing environment uses Apache Hadoop/Spark servers. Cloud Dataproc is GCP's managed Hadoop and Spark service, designed to run existing Hadoop/Spark jobs with minimal modification ('as-is'). Dataproc provides an optimized, scalable, and managed environment, often with better performance than self-managed clusters, fulfilling the 'optimized architecture' requirement. Migrating web apps to App Engine (A) requires changes. RabbitMQ (B) should ideally be migrated to Pub/Sub. Miscellaneous servers (D) on GCE aren't necessarily optimized without analysis.",
    "conditions": [
      "Identify compute service to migrate as-is",
      "Resulting architecture should be optimized for performance"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL 5.7, 8 core CPUs, 128 GB RAM, 2x 5 TB HDD (RAID 1). Redis 3 server cluster, 4 core CPUs, 32GB RAM each. Compute: 40 Web App servers (Tomcat/Java, Nginx, 4 core CPUs, 32 GB RAM). 20 Apache Hadoop/Spark servers (8 core CPUs, 128 GB RAM, 4x 5 TB HDD RAID 1). 3 RabbitMQ servers (8 core CPUs, 32GB RAM). Misc servers (Jenkins, monitoring, bastion, scanners, 8 core CPUs, 32GB RAM). Storage: iSCSI for VM hosts. Fibre channel SAN for MySQL (1 PB total, 400 TB free). NAS for images/logs/backups (100 TB total, 35 TB free).\n<strong>Business Requirements </strong><br> - Reliable/reproducible env. Improve security/IAM. Improve agility/innovation speed. Analyze/optimize performance.\n<strong>Technical Requirements -</strong> Easy non-prod env creation. Automation framework. CI/CD process. Prod failover support. Encrypt data. Multiple private connections.\n<strong>Executive Statement -</strong> Investors concerned re: scale/cost. Competitor threat. Idle capacity (80% off-peak). Capex high. TCO analysis shows 30-50% cloud savings."
  },
  {
    "id": 274,
    "topic": "Operations",
    "question": "For this question, refer to the Dress4Win case study (v2 - listed above).\nTo be legally compliant during an audit, Dress4Win must be able to give insights in all administrative actions that modify the configuration or metadata of resources on Google Cloud.\nWhat should you do?",
    "options": {
      "A": "Use Stackdriver Trace to create a Trace list analysis.",
      "B": "Use Stackdriver Monitoring to create a dashboard on the project's activity.",
      "C": "Enable Cloud Identity-Aware Proxy in all projects, and add the group of Administrators as a member.",
      "D": "Use the Activity page in the GCP Console and Stackdriver Logging to provide the required insight."
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Admin Activity audit logs record administrative actions that modify resource configuration or metadata. These logs are automatically collected by Cloud Logging (formerly Stackdriver Logging) and are also displayed in the GCP Console's Activity page. These logs provide the necessary details (who, what, when, where) for auditing purposes.",
    "conditions": [
      "Legal compliance/audit requirement",
      "Provide insight into all admin actions modifying resources/metadata"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL 5.7, 8 core CPUs, 128 GB RAM, 2x 5 TB HDD (RAID 1). Redis 3 server cluster, 4 core CPUs, 32GB RAM each. Compute: 40 Web App servers (Tomcat/Java, Nginx, 4 core CPUs, 32 GB RAM). 20 Apache Hadoop/Spark servers (8 core CPUs, 128 GB RAM, 4x 5 TB HDD RAID 1). 3 RabbitMQ servers (8 core CPUs, 32GB RAM). Misc servers (Jenkins, monitoring, bastion, scanners, 8 core CPUs, 32GB RAM). Storage: iSCSI for VM hosts. Fibre channel SAN for MySQL (1 PB total, 400 TB free). NAS for images/logs/backups (100 TB total, 35 TB free).\n<strong>Business Requirements </strong><br> - Reliable/reproducible env. Improve security/IAM. Improve agility/innovation speed. Analyze/optimize performance.\n<strong>Technical Requirements -</strong> Easy non-prod env creation. Automation framework. CI/CD process. Prod failover support. Encrypt data. Multiple private connections.\n<strong>Executive Statement -</strong> Investors concerned re: scale/cost. Competitor threat. Idle capacity (80% off-peak). Capex high. TCO analysis shows 30-50% cloud savings."
  },
  {
    "id": 275,
    "topic": "Security",
    "question": "For this question, refer to the Dress4Win case study (v2 - listed above).\nYou are responsible for the security of data stored in Cloud Storage for your company, Dress4Win. You have already created a set of Google Groups and assigned the appropriate users to those groups. You should use Google best practices and implement the simplest design to meet the requirements.\nConsidering Dress4Win's business and technical requirements, what should you do?",
    "options": {
      "A": "Assign custom IAM roles to the Google Groups you created in order to enforce security requirements. Encrypt data with a customer-supplied encryption key when storing files in Cloud Storage.",
      "B": "Assign custom IAM roles to the Google Groups you created in order to enforce security requirements. Enable default storage encryption before storing files in Cloud Storage.",
      "C": "Assign predefined IAM roles to the Google Groups you created in order to enforce security requirements. Utilize Google's default encryption at rest when storing files in Cloud Storage.",
      "D": "Assign predefined IAM roles to the Google Groups you created in order to enforce security requirements. Ensure that the default Cloud KMS key is set before storing files in Cloud Storage."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Google best practices recommend using predefined IAM roles whenever possible and assigning them to Groups for easier management. Cloud Storage encrypts data at rest by default using Google-managed keys, meeting the technical requirement for encryption at rest with the simplest approach. Option C combines these practices. Custom roles (A, B) are only needed if predefined roles are insufficient. CSEK (A) or CMEK (D) add complexity unnecessary for the stated requirements.",
    "conditions": [
      "Secure data in Cloud Storage",
      "Google Groups already set up",
      "Use Google best practices",
      "Implement simplest design",
      "Meet requirements (including encryption at rest)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL 5.7, 8 core CPUs, 128 GB RAM, 2x 5 TB HDD (RAID 1). Redis 3 server cluster, 4 core CPUs, 32GB RAM each. Compute: 40 Web App servers (Tomcat/Java, Nginx, 4 core CPUs, 32 GB RAM). 20 Apache Hadoop/Spark servers (8 core CPUs, 128 GB RAM, 4x 5 TB HDD RAID 1). 3 RabbitMQ servers (8 core CPUs, 32GB RAM). Misc servers (Jenkins, monitoring, bastion, scanners, 8 core CPUs, 32GB RAM). Storage: iSCSI for VM hosts. Fibre channel SAN for MySQL (1 PB total, 400 TB free). NAS for images/logs/backups (100 TB total, 35 TB free).\n<strong>Business Requirements </strong><br> - Reliable/reproducible env. Improve security/IAM. Improve agility/innovation speed. Analyze/optimize performance.\n<strong>Technical Requirements -</strong> Easy non-prod env creation. Automation framework. CI/CD process. Prod failover support. Encrypt data. Multiple private connections.\n<strong>Executive Statement -</strong> Investors concerned re: scale/cost. Competitor threat. Idle capacity (80% off-peak). Capex high. TCO analysis shows 30-50% cloud savings."
  },
  {
    "id": 276,
    "topic": "Migration",
    "question": "For this question, refer to the Dress4Win case study (v2 - listed above).\nYou want to ensure that your on-premises architecture meets <strong>Business Requirements </strong><br> before you migrate your solution.\nWhat change in the on-premises architecture should you make?",
    "options": {
      "A": "Replace RabbitMQ with Google Pub/Sub.",
      "B": "Downgrade MySQL to v5.7, which is supported by Cloud SQL for MySQL.",
      "C": "Resize compute resources to match predefined Compute Engine machine types.",
      "D": "Containerize the micro-services and host them in Google Kubernetes Engine."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "The question asks for changes *on-premises* before migration. The existing MySQL version is 5.8 (per v2 context, though v1 listed 5.7). If the target is Cloud SQL for MySQL, ensuring the on-premises version matches a supported Cloud SQL version (like 5.7, assuming 5.8 wasn't fully supported or standard at the time) *before* migration simplifies the database replication or import process. Options A, C, D describe actions taken *in the cloud* or *as part of* the migration, not preparatory changes on-premises.",
    "conditions": [
      "Ensure on-prem architecture meets requirements before migration",
      "Identify change to make on-premises",
      "Existing on-prem MySQL version is 5.8 (in v2 case study)"
    ],
    "caseStudyContext": "<strong>Company overview: </strong><br>- Dress4Win is a web-based company that helps their users organize and manage their personal wardrobe using a web app and mobile application. The company also cultivates an active social network that connects their users with designers and retailers. They monetize their services through advertising, e-commerce, referrals, and a freemium app model. The application has grown from a few servers in the founder's garage to several hundred servers and appliances in a colocated data center. However, the capacity of their infrastructure is now insufficient for the application's rapid growth. Because of this growth and the company's desire to innovate faster, Dress4Win is committing to a full migration to a public cloud.\n<strong>Solution Concept </strong><br> - For the first phase of their migration to the cloud, Dress4Win is moving their development and test environments. They are also building a disaster recovery site, because their current infrastructure is at a single location. They are not sure which components of their architecture they can migrate as is and which components they need to change before migrating them.\n<strong>Existing Technical Environment </strong><br> - The Dress4Win application is served out of a single data center location. All servers run Ubuntu LTS v16.04. Databases: MySQL 5.8, 8 core CPUs, 128 GB RAM, 2x 5 TB HDD (RAID 1). Redis 3 server cluster, 4 core CPUs, 32GB RAM each. Compute: 40 Web App servers (Tomcat/Java, Nginx, 4 core CPUs, 32 GB RAM). 20 Apache Hadoop/Spark servers (8 core CPUs, 128 GB RAM, 4x 5 TB HDD RAID 1). 3 RabbitMQ servers (8 core CPUs, 32GB RAM). Misc servers (Jenkins, monitoring, bastion, scanners, 8 core CPUs, 32GB RAM). Storage: iSCSI for VM hosts. Fibre channel SAN for MySQL (1 PB total, 400 TB free). NAS for images/logs/backups (100 TB total, 35 TB free).\n<strong>Business Requirements </strong><br> - Reliable/reproducible env. Improve security/IAM. Improve agility/innovation speed. Analyze/optimize performance.\n<strong>Technical Requirements -</strong> Easy non-prod env creation. Automation framework. CI/CD process. Prod failover support. Encrypt data. Multiple private connections.\n<strong>Executive Statement -</strong> Investors concerned re: scale/cost. Competitor threat. Idle capacity (80% off-peak). Capex high. TCO analysis shows 30-50% cloud savings."
  },
  {
    "id": 278,
    "topic": "Storage",
    "question": "Your company wants to try out the cloud with low risk. They want to archive approximately 100 TB of their log data to the cloud and test the analytics features available to them there, while also retaining that data as a long-term disaster recovery backup.\nWhich two steps should they take? (Choose 2 answers)",
    "options": {
      "A": "Load logs into Google BigQuery.",
      "B": "Load logs into Google Cloud SQL.",
      "C": "Import logs into Google Stackdriver.",
      "D": "Insert logs into Google Cloud Bigtable.",
      "E": "Upload log files into Google Cloud Storage."
    },
    "correctAnswer": [
      "A",
      "E"
    ],
    "explanation": "E: Uploading the raw log files to Cloud Storage provides a cost-effective, durable location for long-term archival and DR backup. A: Loading the data from Cloud Storage (or directly) into BigQuery enables testing GCP's powerful analytics capabilities using a familiar SQL interface.",
    "conditions": [
      "Archive 100 TB log data to cloud (low risk)",
      "Test cloud analytics features",
      "Retain data as long-term DR backup"
    ],
    "caseStudyContext": null
  },
  {
    "id": 282,
    "topic": "Operations",
    "question": "Your customer wants to capture multiple GBs of aggregate real-time key performance indicators (KPIs) from their game servers running on Google Cloud Platform and monitor the KPIs with low latency.\nHow should they capture the KPIs?",
    "options": {
      "A": "Store time-series data from the game servers in Google Bigtable, and view it using Google Data Studio.",
      "B": "Output custom metrics to Stackdriver from the game servers, and create a Dashboard in Stackdriver Monitoring Console to view them.",
      "C": "Schedule BigQuery load jobs to ingest analytics files uploaded to Cloud Storage every ten minutes, and visualize the results in Google Data Studio.",
      "D": "Insert the KPIs into Cloud Datastore entities, and run ad hoc analysis and visualizations of them in Cloud Datalab."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Cloud Monitoring (formerly Stackdriver) is designed for ingesting, storing, and visualizing time-series metrics, including custom metrics from applications. Sending KPIs as custom metrics (B) allows for low-latency dashboarding and alerting directly within the Monitoring console, fitting the real-time monitoring requirement.",
    "conditions": [
      "Capture aggregate real-time KPIs from game servers",
      "Volume: Multi-GB",
      "Monitor KPIs with low latency"
    ],
    "caseStudyContext": null
  },
  {
    "id": 285,
    "topic": "Storage",
    "question": "Your company wants to migrate their 10-TB on-premises database export into Cloud Storage You want to minimize the time it takes to complete this activity, the overall cost and database load The bandwidth between the on-premises environment and Google Cloud is 1 Gbps You want to follow Google-recommended practices What should you do?",
    "options": {
      "A": "Use the Data Transfer appliance to perform an offline migration",
      "B": "Use a commercial partner ETL solution to extract the data from the on-premises database and upload it into Cloud Storage",
      "C": "Develop a Dataflow job to read data directly from the database and write it into Cloud Storage",
      "D": "Compress the data and upload it with gsutii -m to enable multi-threaded copy"
    },
    "correctAnswer": [
      "D"
    ],
    "explanation": "Transferring 10 TB over 1 Gbps is feasible (approx. 1 day). Compressing the data reduces size, and using `gsutil -m` for parallel uploads (D) optimizes the use of the available bandwidth, minimizing transfer time for the existing export file without impacting the source DB. Transfer Appliance (A) is generally for larger datasets or slower links. Dataflow (C) or ETL (B) add complexity for a file transfer.",
    "conditions": [
      "Migrate 10 TB on-prem DB export to GCS",
      "Minimize time, cost, DB load",
      "1 Gbps bandwidth available",
      "Follow Google recommended practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 288,
    "topic": "Databases",
    "question": "You are using Cloud SQL as the database backend for a large CRM deployment. You want to scale as usage increases and ensure that you don’t run out of storage, maintain 75% CPU usage cores, and keep replication lag below 60 seconds. What are the correct steps to meet your requirements?",
    "options": {
      "A": "1) Enable automatic storage increase for the instance. 2) Create a Stackdriver alert when CPU usage exceeds 75%, and change the instance type to reduce CPU usage. 3) Create a Stackdriver alert for replication lag, and shard the database to reduce replication time.",
      "B": "1) Enable automatic storage increase for the instance. 2) Change the instance type to a 32-core machine type to keep CPU usage below 75%. 3) Create a Stackdriver alert for replication lag, and shard the database to reduce replication time.",
      "C": "1) Create a Stackdriver alert when storage exceeds 75%, and increase the available storage on the instance to create more space. 2) Deploy memcached to reduce CPU load. 3) Change the instance type to a 32-core machine type to reduce replication lag.",
      "D": "1) Create a Stackdriver alert when storage exceeds 75%, and increase the available storage on the instance to create more space. 2) Deploy memcached to reduce CPU load. 3) Create a Stackdriver alert for replication lag, and change the instance type to a 32-core machine type to reduce replication lag."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To meet the requirements: 1. Storage: Enable Cloud SQL's automatic storage increase feature. 2. CPU: Monitor CPU utilization with Cloud Monitoring and set an alert at 75%. If triggered, manually or automatically resize the instance (change machine type). 3. Replication Lag: Monitor lag with Cloud Monitoring and set an alert at 60 seconds. If triggered, investigate and potentially implement strategies like sharding (complex) or query optimization. Option A describes these reactive monitoring and management steps.",
    "conditions": [
      "Cloud SQL backend for large CRM",
      "Scale with usage",
      "Prevent storage running out",
      "Maintain <= 75% CPU usage",
      "Keep replication lag <= 60 seconds"
    ],
    "caseStudyContext": null
  },
  {
    "id": 289,
    "topic": "Networking",
    "question": "Your company has a project in Google Cloud with three Virtual Private Clouds (VPCs). There is a Compute Engine instance on each VPC. Network subnets do not overlap and must remain separated. The network configuration is shown below. [Diagram shows VPC #1 (subnet #1, Instance #1), VPC #2 (subnet #2, Instance #2), VPC #3 (subnet #3, Instance #3) with no connections between them]. Instance #1 is an exception and must communicate directly with both Instance #2 and Instance #3 via internal IPs. How should you accomplish this?",
    "options": {
      "A": "Create a cloud router to advertise subnet #2 and subnet #3 to subnet #1.",
      "B": "Add two additional NICs to Instance #1 with the following configuration:•NIC1VPC: VPC #2SUBNETWORK: subnet #2•NIC2VPC: VPC #3SUBNETWORK: subnet #3Update firewall rules to enable traffic between instances.",
      "C": "Create two VPN tunnels via CloudVPN:•1 between VPC #1 and VPC #2.•1 between VPC #2 and VPC #3.Update firewall rules to enable traffic between the instances.",
      "D": "Peer all three VPCs:•Peer VPC #1 with VPC #2.•Peer VPC #2 with VPC #3.Update firewall rules to enable traffic between the instances."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "A single Compute Engine instance can have multiple network interface controllers (NICs), each attached to a different VPC network. To allow Instance #1 to communicate directly via internal IPs with instances in VPC #2 and VPC #3, add two additional NICs to Instance #1: one connected to VPC #2/subnet #2, and another connected to VPC #3/subnet #3 (B). Appropriate firewall rules must also be configured in each VPC to allow the traffic.",
    "conditions": [
      "3 separate VPCs (VPC #1, #2, #3) with instances (#1, #2, #3)",
      "Non-overlapping subnets",
      "Instance #1 needs direct internal IP communication with Instance #2 and Instance #3"
    ],
    "caseStudyContext": null
  },
  {
    "id": 290,
    "topic": "Application Modernization",
    "question": "Your company has developed a monolithic, 3-tier application to allow external users to upload and share files. The solution cannot be easily enhanced and lacks reliability. The development team would like to re-architect the application to adopt microservices and a fully managed service approach, but they need to convince their leadership that the effort is worthwhile. Which advantage(s) should they highlight to leadership?",
    "options": {
      "A": "The new approach will be significantly less costly, make it easier to manage the underlying infrastructure, and automatically manage the CI/CD pipelines.",
      "B": "The monolithic solution can be converted to a container with Docker. The generated container can then be deployed into a Kubernetes cluster.",
      "C": "The new approach will make it easier to decouple infrastructure from application, develop and release new features, manage the underlying infrastructure, manage CI/CD pipelines and perform A/B testing, and scale the solution if necessary.",
      "D": "The process can be automated with Migrate for Compute Engine."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Migrating from a monolith to microservices/managed services offers significant advantages: improved agility (easier/faster feature releases), independent scalability, better fault isolation (reliability), reduced operational burden via managed services, easier infrastructure management, and enablement of modern DevOps practices like CI/CD and A/B testing. Option C highlights these key benefits relevant to leadership.",
    "conditions": [
      "Existing monolithic app",
      "Difficult to enhance, lacks reliability",
      "Plan: Re-architect to microservices & managed services",
      "Justify effort to leadership"
    ],
    "caseStudyContext": null
  },
  {
    "id": 294,
    "topic": "Storage",
    "question": "You have an application that makes HTTP requests to Cloud Storage. Occasionally the requests fail with HTTP status codes of 5xx and 429. How should you handle these types of errors?",
    "options": {
      "A": "Use gRPC instead of HTTP for better performance.",
      "B": "Implement retry logic using a truncated exponential backoff strategy.",
      "C": "Make sure the Cloud Storage bucket is multi-regional for geo-redundancy.",
      "D": "Monitor https://status.cloud.google.com/feed.atom and only make requests if Cloud Storage is not reporting an incident."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "5xx (server errors) and 429 (rate limiting) errors are often transient. The standard best practice is to retry requests that fail with these codes using an exponential backoff strategy (B). This involves waiting progressively longer between retries, adding jitter, and setting a maximum backoff time.",
    "conditions": [
      "App makes HTTP requests to GCS",
      "Occasional 5xx and 429 errors"
    ],
    "caseStudyContext": null
  },
  {
    "id": 298,
    "topic": "DevOps",
    "question": "Your company's user-feedback portal comprises a standard LAMP stack replicated across two zones. It is deployed in the us-central1 region and uses autoscaled managed instance groups on all layers, except the database. Currently, only a small group of select customers have access to the portal. The portal meets a 99.99% availability SLA under these conditions However next quarter, your company will be making the portal available to all users, including unauthenticated users. You need to develop a resiliency testing strategy to ensure the system maintains the SLA once they introduce additional user load. What should you do?",
    "options": {
      "A": "Capture existing users input, and replay captured user load until autoscale is triggered on all layers. At the same time, terminate all resources in one of the zones.",
      "B": "Create synthetic random user input, replay synthetic load until autoscale logic is triggered on at least one layer, and introduce \"chaos\" to the system by terminating random resources on both zones.",
      "C": "Expose the new system to a larger group of users, and increase group size each day until autoscale logic is triggered on all layers. At the same time, terminate random resources on both zones.",
      "D": "Capture existing users input, and replay captured user load until resource utilization crosses 80%. Also, derive estimated number of users based on existing users usage of the app, and deploy enough resources to handle 200% of expected load."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "Resiliency testing involves simulating realistic load and failure conditions. Since the load profile might change, replaying existing user load (A) provides a baseline. Triggering autoscaling confirms scaling mechanisms work. Simulating a complete zonal failure by terminating all resources in one zone (A) is a clear, impactful disaster scenario to test the multi-zone redundancy and failover capabilities under load. Option B uses synthetic load (good) but random termination is less predictable than a full zone failure. Option C involves real users in disruptive tests. Option D lacks failure injection.",
    "conditions": [
      "LAMP stack portal, multi-zone MIGs (except DB)",
      "Currently meets 99.99% SLA with limited users",
      "Opening to all users (increased/different load profile)",
      "Need resiliency testing strategy for new load"
    ],
    "caseStudyContext": null
  },
  {
    "id": 300,
    "topic": "Compute",
    "question": "A development team at your company has created a dockerized HTTPS web application. You need to deploy the application on Google Kubernetes Engine (GKE) and make sure that the application scales automatically. How should you deploy to GKE?",
    "options": {
      "A": "Use the Horizontal Pod Autoscaler and enable cluster autoscaling. Use an Ingress resource to load-balance the HTTPS traffic.",
      "B": "Use the Horizontal Pod Autoscaler and enable cluster autoscaling on the Kubernetes cluster. Use a Service resource of type LoadBalancer to load-balance the HTTPS traffic.",
      "C": "Enable autoscaling on the Compute Engine instance group. Use an Ingress resource to load-balance the HTTPS traffic.",
      "D": "Enable autoscaling on the Compute Engine instance group. Use a Service resource of type LoadBalancer to load-balance the HTTPS traffic."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "For autoscaling in GKE: Enable Horizontal Pod Autoscaler (HPA) for the Deployment and enable Cluster Autoscaler for the node pools. For exposing HTTPS traffic: An Ingress resource typically configures an L7 HTTP(S) Load Balancer, which is ideal for HTTPS. However, a Service of type LoadBalancer creates an L4 Network Load Balancer. While Ingress (A) is generally preferred for HTTPS, the provided answer B suggests using Service type LoadBalancer. Both HPA and Cluster Autoscaling are correctly included in A and B. Option B is chosen based on the provided text file answer, though A (using Ingress) aligns better with typical HTTPS best practices.",
    "conditions": [
      "Deploy dockerized HTTPS web app on GKE",
      "Ensure automatic scaling"
    ],
    "caseStudyContext": null
  },
  {
    "id": 303,
    "topic": "Data Analytics",
    "question": "Your company is using BigQuery as its enterprise data warehouse. Data is distributed over several Google Cloud projects. All queries on BigQuery need to be billed on a single project. You want to make sure that no query costs are incurred on the projects that contain the data. Users should be able to query the datasets, but not edit them. How should you configure users’ access roles?",
    "options": {
      "A": "Add all users to a group. Grant the group the role of BigQuery user on the billing project and BigQuery dataViewer on the projects that contain the data.",
      "B": "Add all users to a group. Grant the group the roles of BigQuery dataViewer on the billing project and BigQuery user on the projects that contain the data.",
      "C": "Add all users to a group. Grant the group the roles of BigQuery jobUser on the billing project and BigQuery dataViewer on the projects that contain the data.",
      "D": "Add all users to a group. Grant the group the roles of BigQuery dataViewer on the billing project and BigQuery jobUser on the projects that contain the data."
    },
    "correctAnswer": [
      "A"
    ],
    "explanation": "To run queries billed to the 'billing project', users need permissions like `bigquery.jobs.create`, included in `roles/bigquery.user` and `roles/bigquery.jobUser`. To read data from 'data projects', users need `roles/bigquery.dataViewer`. Option A grants `bigquery.user` (allowing job creation and potentially dataset creation) on the billing project and `dataViewer` on data projects. Option C uses `jobUser` which is slightly more least-privilege for just running queries, but `bigquery.user` is also commonly used and is the answer provided in the text.",
    "conditions": [
      "BigQuery DWH across multiple projects",
      "Centralized billing on 'billing project'",
      "No query costs on 'data projects'",
      "Users need query ability, not edit ability"
    ],
    "caseStudyContext": null
  },
  {
    "id": 306,
    "topic": "Data Analytics",
    "question": "Your applications will be writing their logs to BigQuery for analysis. Each application should have its own table. Any logs older than 45 days should be removed. You want to optimize storage and follow Google recommended practices. What should you do?",
    "options": {
      "A": "Configure the expiration time for your tables at 45 days",
      "B": "Make the tables time-partitioned, and configure the partition expiration at 45 days",
      "C": "Rely on BigQuery’s default behavior to prune application logs older than 45 days",
      "D": "Create a script that uses the BigQuery command line tool (bq) to remove records older than 45 days"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Using time-partitioned tables and setting a partition expiration (B) is the most efficient and recommended way to manage log data retention in BigQuery. It automatically deletes old data at the partition level, optimizing storage costs and management effort.",
    "conditions": [
      "Writing app logs to BQ (separate table per app)",
      "Remove logs older than 45 days",
      "Optimize storage, follow Google practices"
    ],
    "caseStudyContext": null
  },
  {
    "id": 308,
    "topic": "IAM & Security",
    "question": "Your customer is moving their corporate applications to Google Cloud Platform. The security team wants detailed visibility of all projects in the organization. You provision the Google Cloud Resource Manager and set up yourself as the org admin. What Google Cloud Identity and Access Management (Cloud IAM) roles should you give to the security team'?",
    "options": {
      "A": "Org viewer, project owner",
      "B": "Org viewer, project viewer",
      "C": "Org admin, project browser",
      "D": "Project owner, network admin"
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "Granting `roles/resourcemanager.organizationViewer` allows viewing the organization hierarchy. Granting `roles/viewer` at the organization level allows viewing resources within all projects. This combination (B) provides comprehensive visibility without granting modification permissions.",
    "conditions": [
      "Customer moving apps to GCP",
      "Security team needs detailed visibility of ALL projects",
      "Org Admin already set up"
    ],
    "caseStudyContext": null
  },
  {
    "id": 309,
    "topic": "App Engine",
    "question": "Your customer is receiving reports that their recently updated Google App Engine application is taking approximately 30 seconds to load for some of their users. This behavior was not reported before the update. What strategy should you take?",
    "options": {
      "A": "Work with your ISP to diagnose the problem.",
      "B": "Open a support ticket to ask for network capture and flow data to diagnose the problem, then roll back your application.",
      "C": "Roll back to an earlier known good release initially, then use Stackdriver Trace and logging to diagnose the problem in a development/test/staging environment.",
      "D": "Roll back to an earlier known good release, then push the release again at a quieter period to investigate. Then use Stackdriver Trace and logging to diagnose the problem."
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "When a recent deployment causes issues, the immediate priority is to restore service by rolling back to the previous known good version. After rollback, investigate the issue safely in a non-production environment using diagnostic tools like Cloud Trace (for latency) and Cloud Logging (for errors). Option C follows this standard incident response and troubleshooting process.",
    "conditions": [
      "App Engine app recently updated",
      "Increased load times (~30s) reported post-update"
    ],
    "caseStudyContext": null
  },
  {
    "id": 314,
    "topic": "Data Analytics",
    "question": "Your company has a Google Cloud project that uses BlgQuery for data warehousing There are some tables that contain personally identifiable information (PI!) Only the compliance team may access the PH. The other information in the tables must be available to the data science team. You want to minimize cost and the time it takes to assign appropriate access to the tables What should you do?",
    "options": {
      "A": "* 1 From the dataset where you have the source data, create views of tables that you want to share, excluding Pll* 2 Assign an appropriate project-level IAM role to the members of the data science team 3 Assign access controls to the dataset that contains the view",
      "B": "* 1 From the dataset where you have the source data, create materialized views of tables that you want to share excluding Pll* 2 Assign an appropriate project-level IAM role to the members of the data science team 3. Assign access controls to the dataset that contains the view.",
      "C": "* 1 Create a dataset for the data science team* 2 Create views of tables that you want to share excluding Pll* 3 Assign an appropriate project-level IAM role to the members of the data science team 4 Assign access controls to the dataset that contains the view* 5 Authorize the view to access the source dataset",
      "D": "* 1. Create a dataset for the data science team.* 2. Create materialized views of tables that you want to share, excluding Pll* 3. Assign an appropriate project-level IAM role to the members of the data science team * 4 Assign access controls to the dataset that contains the view* 5 Authorize the view to access the source dataset"
    },
    "correctAnswer": [
      "C"
    ],
    "explanation": "Authorized Views are the standard BigQuery mechanism for this use case. Create a separate dataset for data science. Create views in that dataset selecting only non-PII columns. Grant data scientists access to the view dataset. Authorize the views to read from the source dataset (C). This securely restricts access without data duplication or excessive permissions.",
    "conditions": [
      "BQ tables with PII",
      "Compliance team: full access",
      "Data science team: non-PII access only",
      "Minimize cost and setup time"
    ],
    "caseStudyContext": null
  },
  {
    "id": 319,
    "topic": "IAM & Security",
    "question": "How can you enable users defined in Microsoft Active Directory to access GCP resources using their on-premises usernames and passwords?",
    "options": {
      "A": "Use the Password Sync tool to replicate the passwords into GCP.",
      "B": "Use Google Cloud Directory Sync (GCDS) to synchronize users with Cloud Identity and configure single sign-on (SSO) via SAML 2.0.",
      "C": "Provision users in Cloud Identity and require users to set their passwords to match their on-premises ones.",
      "D": "Configure Cloud Identity to authenticate directly against Active Directory using the LDAP protocol."
    },
    "correctAnswer": [
      "B"
    ],
    "explanation": "The standard method is to use GCDS to provision user identities from AD into Cloud Identity/Workspace, and then configure SAML 2.0 SSO between GCP (as SP) and AD FS or another IdP connected to AD (as IdP). This allows users to authenticate using their existing AD credentials without syncing passwords to Google (B). Password Sync (A) replicates passwords, often undesirable. Manual matching (C) is insecure. Direct LDAP auth (D) isn't the standard federated approach.",
    "conditions": [
      "Enable AD users to access GCP resources",
      "Use on-premises usernames/passwords"
    ],
    "caseStudyContext": null
  }
]